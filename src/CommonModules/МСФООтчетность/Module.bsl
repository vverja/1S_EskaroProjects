////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ
//

//Выполняет в строке ГДЕ замену символов ЧТО на соответствующие по номерам символы из строки НаЧто
//
Функция ЗаменитьОдниСимволыДругими(Что,Где,НаЧто) Экспорт
	Рез = Где;
	Для Сч=1 По СтрДлина(Что) Цикл
		Рез = СтрЗаменить(Рез,Сред(Что,Сч,1),Сред(НаЧто,Сч,1));
	КонецЦикла;
	Возврат Рез;
КонецФункции

// Проверяет, написана ли строка только русскими и латинскими буквами 
//
// Параметры:
//  СтрокаПараметр - строка, проверяемая строка.
//
// Возвращаемое значение:
//		Истина - строка состоит из допустимых символов
//		Ложь - в строке встречаются недопустимые символы
// 
// Описание:
//		Строка проверяется на наличие только русских и латинских букв;
//		кроме того,	допускаются дефис, "Ё", "ё".
//
Функция СтрокаНаписанаРусскимиИлиЛатинскими(Знач СтрокаПараметр) Экспорт
	
	СтрокаПараметр = СокрЛП(СтрокаПараметр);	

	Русские = 0;     
	КоличествоСимволов = СтрДлина(СтрокаПараметр);
	
	Если  КоличествоСимволов > 0 Тогда
		ПервыйСимвол = КодСимвола(Лев(СтрокаПараметр,1)); 
		Если  (ПервыйСимвол >= 192) или (ПервыйСимвол = 184) или (ПервыйСимвол = 168) Тогда
			Русские = 1;
		КонецЕсли;
	КонецЕсли;
	
	СписокДопустимыхЗначений = Новый СписокЗначений;
	СписокДопустимыхЗначений.Добавить(184);   // ё
	СписокДопустимыхЗначений.Добавить(168);   // Ё
	СписокДопустимыхЗначений.Добавить(45);   //  "-"

	Для Сч = 1 По КоличествоСимволов Цикл
		Код = КодСимвола(Сред(СтрокаПараметр,Сч));   
		// Большие латинские буквы: 65 - 90
		// Маленькие латинские буквы: 97 - 122
		// Русские буквы: 192 и больше
		
		//русские:
		Если (Русские = 1) Тогда
			Если (СписокДопустимыхЗначений.НайтиПоЗначению(Код) = Неопределено) и (Код < 192)  Тогда
				Возврат 0;
			КонецЕсли;

		// латинские:	
		Иначе 
			Если (Код <> 45) и 
			((Код < 65) или	(Код > 90) и (Код < 97) или (Код > 122))  Тогда    
				Возврат 0;
			КонецЕсли;
		КонецЕсли;
			
	КонецЦикла;
	
	Возврат 1;

КонецФункции // СтрокаНаписанаРусскимиИлиЛатинскими()

// Дополняет строку указанным символом до указанной длины
//
// Параметры: 
//  Стр            - Дополняемая строка
//  Длина          - Требуемая длина результирующей строки
//  Чем            - Символ, которым дополняется строка
//
// Возвращаемое значение:
//  Строка дополненная указанным символом до указанной длины
//
Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 по СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции 

// Выполянет преобразование цифры в римскую нотацию 
//
// Параметры
//		Цифра - число, целое, от 0 до 9
//      РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка - строки, соответствующие римские цифры
//
// Возвращаемое значение
//		строка
//
// Описание
//		записывает "обычную" цифру римскими цифрами,
//		например:
//				ПреобразоватьЦифруВРимскуюНотацию(7,"I","V","X") = "VII"
//
Функция ПреобразоватьЦифруВРимскуюНотацию(Цифра,РимскаяЕдиница,РимскаяПятерка,РимскаяДесятка) Экспорт

	РимскаяЦифра="";
	Если Цифра = 1 Тогда
	   РимскаяЦифра = РимскаяЕдиница
	ИначеЕсли Цифра = 2 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 3 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 4 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяПятерка;
	ИначеЕсли Цифра = 5 Тогда
	   РимскаяЦифра = РимскаяПятерка;
	ИначеЕсли Цифра = 6 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница;
	ИначеЕсли Цифра = 7 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 8 Тогда
	   РимскаяЦифра = РимскаяПятерка + РимскаяЕдиница + РимскаяЕдиница + РимскаяЕдиница;
	ИначеЕсли Цифра = 9 Тогда
	   РимскаяЦифра = РимскаяЕдиница + РимскаяДесятка;
	КонецЕсли;
	Возврат РимскаяЦифра;

КонецФункции //ПреобразоватьЦифруВРимскуюНотацию

// Выполянет преобразование арабского числа в римское 
//
// Параметры
//		АрабскоеЧисло - число, целое, от 0 до 999
//
// Возвращаемое значение
//		строка
//
// Описание
//		записывает "обычное" число римскими цифрами,
//		например:
//				ПреобразоватьЧислоВРимскуюНотацию(17) = "ХVII"
//
Функция ПреобразоватьЧислоВРимскуюНотацию(АрабскоеЧисло, ИспЛатинскиеБуквы = Ложь) Экспорт
	
	РимскоеЧисло="";
	cRab = ДополнитьСтроку(АрабскоеЧисло,3);

	Если ИспЛатинскиеБуквы Тогда
		c1 = "I";c5 = "V";c10 = "X";c50 = "L";c100 ="C";c500 = "M";c1000 = "D";
		
	Иначе
		c1 = "1";c5 = "У";c10 = "Х";c50 = "Л";c100 ="С";c500 = "М";c1000 = "Д";
	КонецЕсли;

	nEd = Число(Сред(cRab,3,1));
	nDs = Число(Сред(cRab,2,1));
	nSt = Число(Сред(cRab,1,1));

	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nSt,c100,c500,c1000);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nDs,c10,c50,c100);
	РимскоеЧисло = РимскоеЧисло + ПреобразоватьЦифруВРимскуюНотацию(nEd,c1,c5,c10);

	Возврат РимскоеЧисло;
	
КонецФункции //ПреобразоватьЧислоВРимскуюНотацию

// Выполянет преобразование римского числа в арабское
//
// Параметры
//		РимскоеЧисло - строка, число, записанное римскими цифрами
//
// Возвращаемое значение
//		число
//
// Описание
//		преобразует число, записанное римскими цифрами, в "обычное" число,
//		например:
//				ПреобразоватьЧислоВАрабскуюНотацию("ХVII") = 17
//
Функция ПреобразоватьЧислоВАрабскуюНотацию(РимскоеЧисло) Экспорт
	
	АрабскоеЧисло=0;

	c1 = "1";c5 = "У";c10 = "Х";c50 = "Л";c100 ="С";c500 = "М";c1000 = "Д";

	РимскоеЧисло = СокрЛП(РимскоеЧисло);
	ЧислоСимволов = СтрДлина(РимскоеЧисло);

	Для Сч=1 По ЧислоСимволов Цикл
	   Если Сред(РимскоеЧисло,Сч,1) = c1000 Тогда
		  АрабскоеЧисло = АрабскоеЧисло+1000;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c500 Тогда
		  АрабскоеЧисло = АрабскоеЧисло+500;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c100 Тогда
		  Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c500) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c1000)) Тогда
			 АрабскоеЧисло = АрабскоеЧисло-100;
		  Иначе
			 АрабскоеЧисло = АрабскоеЧисло+100;
		  КонецЕсли;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c50 Тогда
		  АрабскоеЧисло = АрабскоеЧисло+50;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c10 Тогда
		  Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c50) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c100)) Тогда
			 АрабскоеЧисло = АрабскоеЧисло-10;
		  Иначе
			 АрабскоеЧисло = АрабскоеЧисло+10;
		  КонецЕсли;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c5 Тогда
		  АрабскоеЧисло = АрабскоеЧисло+5;
	   ИначеЕсли Сред(РимскоеЧисло,Сч,1) = c1 Тогда
		  Если (Сч < ЧислоСимволов) И ((Сред(РимскоеЧисло,Сч+1,1) = c5) ИЛИ (Сред(РимскоеЧисло,Сч+1,1) = c10)) Тогда
			 АрабскоеЧисло = АрабскоеЧисло-1;
		  Иначе
			 АрабскоеЧисло = АрабскоеЧисло+1;
		  КонецЕсли;
	   КонецЕсли;
	КонецЦикла;
	Возврат АрабскоеЧисло;
КонецФункции //ПреобразоватьЧислоВАрабскуюНотацию

// КонвертацияОтчетнойФормы
// СтруктураМногостраничныхРазделов - структура многостраничных страниц
// ПоказателиОтчета - показатели отчета
// ВерсияФормы - старая версия формы
// ВызванноИзОтчета - откуда вызывается процедура, Истина из отчета при восстановлении, Ложь - извне
//
Процедура КонвертацияОтчетнойФормы(СохраненныйДок = Неопределено, ЭтаФормаД = Неопределено, ВерсияФормы = Неопределено, ПоказателиОтчета = Неопределено) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ДанныеМногостраничныхРазделов;
	Перем ДанныеМногострочныхРазделов;

	Если СохраненныйДок = Неопределено Тогда
		ВызванноИзОтчета = Истина;
	Иначе
		ВызванноИзОтчета = Ложь;
	КонецЕсли;

	Если НЕ ВызванноИзОтчета Тогда

		Если СохраненныйДок = Неопределено Тогда
			Возврат;
		КонецЕсли;

		// Текущая Версия - будет оставаться в отчете всегда прежняя версия, записываться новая не будет
		// поэтому строчки комментарятся
		//ТекущаяВерсия = Отчеты[СохраненныйДок.ИсточникОтчета].ПолучитьФорму(СохраненныйДок.ВыбраннаяФорма).мВерсияФормы;
		ТекущаяВерсия = -1;

		// восстанавливаем сохраненные данные отчета
		СписокСохранения = СохраненныйДок.ДанныеОтчета.Получить();

		Если ВерсияФормы = Неопределено Тогда
			// Получим версию формы, в которой был сохранен отчет
			СписокСохранения.Свойство("ВерсияФормы", ВерсияФормы);
		КонецЕсли;

		Если НЕ СписокСохранения.Свойство( "ПоказателиОтчета", ПоказателиОтчета) Тогда
			Возврат;
		КонецЕсли;

		// Если многостраничных разделов нет, то нечего конвертировать.
		Если (НЕ СписокСохранения.Свойство("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов))
		Или (ДанныеМногостраничныхРазделов = Неопределено) Тогда
			Возврат;
		КонецЕсли;

		ВыбраннаяФорма = СохраненныйДок.ИсточникОтчета;

		// Считываем данные многострочной части
		Если НЕ СписокСохранения.Свойство("ДанныеМногострочныхРазделов", ДанныеМногострочныхРазделов) Тогда
			МногострочнаяЧастьОтсутствует = Истина;
		Иначе
			МногострочнаяЧастьОтсутствует = Ложь;
		КонецЕсли;

		Если ДанныеМногострочныхРазделов = Неопределено Тогда
			МногострочнаяЧастьОтсутствует = Истина;
		Иначе
			МногострочнаяЧастьОтсутствует = Ложь;
		КонецЕсли;

	Иначе

		ТекущаяВерсия = ЭтаФормаД.мВерсияФормы;
		ВыбраннаяФорма = ЭтаФормаД.мСохраненныйДок.ИсточникОтчета;

		Попытка
			ДанныеМногостраничныхРазделов = ЭтаФормаД.мСтруктураМногостраничныхРазделов;
		Исключение
			ДанныеМногостраничныхРазделов = Неопределено;
		КонецПопытки;

		Если ДанныеМногостраничныхРазделов = Неопределено Тогда
			Возврат;
		КонецЕсли;

		МногострочнаяЧастьОтсутствует = Ложь;

		// Считываем данные многострочной части
		Попытка
			ДанныеМногострочныхРазделов = ЭтаФормаД.мСтруктураМногострочныхРазделов;
		Исключение
			МногострочнаяЧастьОтсутствует = Истина;
		КонецПопытки;

		Если ДанныеМногострочныхРазделов = Неопределено Тогда
			МногострочнаяЧастьОтсутствует = Истина;
		КонецЕсли;

		// Показатель будет изменен
		ПоказателиОтчета = ПоказателиОтчета;
	КонецЕсли;

	// Если версии равны, то выходим
	Если ТекущаяВерсия = ВерсияФормы Тогда
		Возврат;
	КонецЕсли;

		Список = Новый СписокЗначений;
		Для Каждого ПоказателиСтраницы Из ПоказателиОтчета Цикл

			ИмяТекТабличноеПоле = ПоказателиСтраницы.Ключ;
			ПоказателиТаблПоле  = ПоказателиСтраницы.Значение;
			ИмяСтраницы = СтрЗаменить(ИмяТекТабличноеПоле, "ПолеТабличногоДокумента", "");

			Если ДанныеМногостраничныхРазделов.Свойство(ИмяСтраницы, ТаблицаСтраницРаздела) Тогда
				// если раздел многостраничный тогда ...

				// Страница для удаления
				Список.Добавить(ИмяСтраницы);

				Если ВызванноИзОтчета Тогда
					Сообщить("Идет обновление структуры разделов декларации. " + ИмяСтраницы + " ...");
				КонецЕсли;

				Если ТаблицаСтраницРаздела.Количество() = 0 Тогда

					// Добавим пустую страницу
					МногостраничностьОбеспечена = ТаблицаСтраницРаздела.Добавить();
					МногостраничностьОбеспечена.Представление      = "Новая страница";
					МногостраничностьОбеспечена.АктивнаяСтраница   = Истина;
					// Добавим данные
					ТаблицаСтраницРаздела[0].Данные           = ПоказателиТаблПоле;

					МногострочнаяЧастьОтсутствуетПоСтруктуреМногостраничнойЧасти = Ложь;
					ДопСтроки = Неопределено;

					Попытка
					// Поле ДанныеДопСтрок есть не во всех многостраничных разделах
						ДопСтроки = ТаблицаСтраницРаздела[0].ДанныеДопСтрок;
					Исключение
						// на доп. листе нет многострочной части
						МногострочнаяЧастьОтсутствуетПоСтруктуреМногостраничнойЧасти = Истина;
					КонецПопытки;

					// Если поле многострочности есть, а данные = Неопределено, то считаем, что нет многострочной части
					//МногострочнаяЧастьОтсутствуетПоСтруктуреМногостраничнойЧасти = ?(ДопСтроки = Неопределено, Истина, Ложь);

					// Не используем переменную МногострочнаяЧастьОтсутствуетПоСтруктуреМногостраничнойЧасти
					// т.к. если нет доп. страниц в разделе, то многострочность запишется в отчете в переменную
					// данные многостраничных частей - мСтруктураМногострочныхЧастей, которую ранее мы и считали
					Если НЕ МногострочнаяЧастьОтсутствует Тогда

						// Объявим переменную для сбора многострочных частей
						СтруктураДанныхДопСтрокРаздела = Новый Структура;

						// Переберем всю многострочную часть
						Для Каждого ЭлементСтруктуры Из ДанныеМногострочныхРазделов Цикл

							ИмяГруппы = ЭлементСтруктуры.Ключ;

							// Найдем многострочные части, для нужного нам листа и соберем их вместе, в случае
							// если на одном листе больше одной мнг. части.

							Если ОпределитьПринадлежностьМногострочнойЧастиКЛистуДекларации(ИмяГруппы, ВыбраннаяФорма, 1) = ИмяСтраницы Тогда

								ПромТаблицаДопСтрокРаздела = Новый ТаблицаЗначений;
								ДанныеМногострочныхРазделов.Свойство(ИмяГруппы, ПромТаблицаДопСтрокРаздела);
								ТаблицаДопСтрокГруппы1 = ПромТаблицаДопСтрокРаздела.Скопировать();
								СтруктураДанныхДопСтрокРаздела.Вставить(ИмяГруппы, ТаблицаДопСтрокГруппы1);

							КонецЕсли; // Имя страницы равно имя из структуры многостраничной части

						КонецЦикла; // Для Каждого

						// Запишем в структуру многостраничного раздела, если
						// многострочная часть присутствует (по структуре мСтруктураМногостраничной части
						// или (многострочная часть присутствует (по мСтруктураМногострочныхРазделов) И есть поле
						// И в структуре данныхДопСтрокРаздела, больше 0, т.е. больше одного блока
						// таким образом учитываем вариант, когда
						// на многостраничном разделе 1 лист, содержит многострочные части
						Если ((НЕ МногострочнаяЧастьОтсутствуетПоСтруктуреМногостраничнойЧасти)
						И (НЕ МногострочнаяЧастьОтсутствует))
						Или ((НЕ МногострочнаяЧастьОтсутствует) И (СтруктураДанныхДопСтрокРаздела.Количество()>0)) Тогда
							ТаблицаСтраницРаздела[0].ДанныеДопСтрок = СтруктураДанныхДопСтрокРаздела;
						КонецЕсли;

					КонецЕсли;
				КонецЕсли; // Если кол-во страниц = 0
			КонецЕсли; // Если многостраничный документ
		КонецЦикла;

		Для Каждого Зн Из Список Цикл
			// Сообщить(Зн.Значение);
			// Удалим лишние разделы из Показателей Отчета
			ПоказателиОтчета.Удалить("ПолеТабличногоДокумента" + Зн.Значение);
		КонецЦикла;

		Если НЕ ВызванноИзОтчета Тогда

			// вставляем данные, которые изменили
			СписокСохранения.Вставить("ПоказателиОтчета", ПоказателиОтчета);

			// вставляем данные многостраничных разделов
			СписокСохранения.Вставить("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов);

			// вствляем версию формы
			//СписокСохранения.Вставить("ВерсияФормы", ТекущаяВерсия);

			ХранилищеДанных = Новый ХранилищеЗначения(СписокСохранения);
			СохраненныйДокОбъект = СохраненныйДок.ПолучитьОбъект();
			СохраненныйДокОбъект.ДанныеОтчета = ХранилищеДанных;
			СохраненныйДокОбъект.Записать();
		Иначе
			// Если вызвано из формы при восстановлении
			ЭтаФормаД.мСтруктураМногостраничныхРазделов = ДанныеМногостраничныхРазделов;
		КонецЕсли;


КонецПроцедуры // КонвертацияОтчетнойФормы2

// ИзменитьИменаПоказателейВСохраненномОтчете
// Универсальная процедура изменения названий показателей в структурах регл. отчетности.
// Перед использованием процедуры необходимо заполнить таблицу ТаблицаНастройки
// У таблицы есть следующие поля, по которым производится отбор:
//  Источник        - источник декларации, которую требуется обработать.
//  Раздел          - название раздела декларации.
//  СтарыйПоказатель- название старого (текущего) показателя в декларации.
//  НовыйПоказатель - название старого (текущего) показателя в декларации.
//  ВыбраннаяФорма  - форма, которую необходимо конвертировать, если указано "", то все формы источника.
//
// Параметры:
//  СохраненныйДок  - ссылка на документ РО
//
Процедура ИзменитьИменаПоказателейВСохраненномОтчете(СохраненныйДок) Экспорт

	// Получим источник отчета
	Источник = СохраненныйДок.ИсточникОтчета;
	Форма = СохраненныйДок.ВыбраннаяФорма;

	// Создадим таблицу с требуемыми изменениями
	ТаблицаНастройки = Новый ТаблицаЗначений;
	ТаблицаНастройки.Колонки.Добавить("Источник");
	ТаблицаНастройки.Колонки.Добавить("Раздел");
	ТаблицаНастройки.Колонки.Добавить("СтарыйПоказатель");
	ТаблицаНастройки.Колонки.Добавить("НовыйПоказатель");
	ТаблицаНастройки.Колонки.Добавить("ВыбраннаяФорма");

	// Наполним таблицу старыми и новыми названиями показателей
	Для Инд = 1 По 12 Цикл

		НовСтр = ТаблицаНастройки.Добавить();
		НовСтр.Источник = "РегламентированныйОтчетНДС";
		НовСтр.Раздел = "Раздел1_2";
		НовСтр.ВыбраннаяФорма = ""; // Признак всех форм
		НовСтр.СтарыйПоказатель = "ИНН" + Строка(Инд);
		НовСтр.НовыйПоказатель = "ИННР12" + Строка(Инд);

		НовСтр = ТаблицаНастройки.Добавить();
		НовСтр.Источник = "РегламентированныйОтчетНДС";
		НовСтр.Раздел = "Раздел2_2";
		НовСтр.ВыбраннаяФорма = ""; // Признак всех форм
		НовСтр.СтарыйПоказатель = "ИНН" + Строка(Инд);
		НовСтр.НовыйПоказатель = "ИННР22" + Строка(Инд);

		Если Инд <= 9 Тогда

			НовСтр = ТаблицаНастройки.Добавить();
			НовСтр.Источник = "РегламентированныйОтчетНДС";
			НовСтр.Раздел = "Раздел1_2";
			НовСтр.ВыбраннаяФорма = ""; // Признак всех форм
			НовСтр.СтарыйПоказатель = "КПП" + Строка(Инд);
			НовСтр.НовыйПоказатель = "КППР12" + Строка(Инд);

			НовСтр = ТаблицаНастройки.Добавить();
			НовСтр.Источник = "РегламентированныйОтчетНДС";
			НовСтр.ВыбраннаяФорма = ""; // Признак всех форм
			НовСтр.Раздел = "Раздел2_2";
			НовСтр.СтарыйПоказатель = "КПП" + Строка(Инд);
			НовСтр.НовыйПоказатель = "КППР22" + Строка(Инд);

		КонецЕсли;

	КонецЦикла;

	// Проверим, есть ли в таблице изменений, данный отчет, по источнику.
	Если ТаблицаНастройки.Найти(Источник, "Источник") = Неопределено Тогда
		Возврат;
	КонецЕсли;

	// Определим переменные для работы с многостраничными частями документа.
	ДанныеМногостраничныхРазделов = Неопределено;
	ДанныеРаздела = Неопределено;
	ПоказателиРаздела = Неопределено;

	// Восстанавливаем сохраненные данные отчета
	СохраненныйСписок = СохраненныйДок.ДанныеОтчета.Получить();
	ЕстьМногостраничность = Ложь;
	Если СохраненныйСписок.Свойство("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов) Тогда
		ЕстьМногостраничность = Истина;
	КонецЕсли;

	ЕстьПоказателиОтчета = Ложь;
	ПоказателиОтчета = Неопределено;
	Если СохраненныйСписок.Свойство( "ПоказателиОтчета", ПоказателиОтчета ) Тогда
		ЕстьПоказателиОтчета = Истина;
	КонецЕсли;

	ПроизошлиИзмененияВМногостраничномРазделе = Ложь;
	ПроизошлиИзмененияВПоказателяхОтчета = Ложь;

	// Организуем цикл по таблице настроек.
	Для Каждого СтрокаИзменений Из ТаблицаНастройки Цикл

		// Отберем нужные отчеты с необходимой формой, либо с любыми формами внутри источника.
		Если (СтрокаИзменений.Источник <> Источник И Форма <> СтрокаИзменений.ВыбраннаяФорма)
		   Или (СтрокаИзменений.Источник <> Источник И СтрокаИзменений.ВыбраннаяФорма = "") Тогда
			Продолжить;
		КонецЕсли;

		// Если показатели отчета считаны
		Если ЕстьПоказателиОтчета Тогда

			// Если ли раздел в структуре ПоказателейОтчета
			Если ПоказателиОтчета.Свойство(СтрокаИзменений.Раздел, ПоказателиРаздела) Тогда
				Попытка
					// Получим значение требуемого показателя.
					Значение = ПоказателиРаздела[СтрокаИзменений.СтарыйПоказатель];
				Исключение
					Продолжить;
				КонецПопытки;

				// Удалим старый
				ПоказателиРаздела.Удалить(СтрокаИзменений.СтарыйПоказатель);
				// Вставим новый
				ПоказателиРаздела.Вставить(СтрокаИзменений.НовыйПоказатель, Значение);
				// Вставим данные в общую структуру
				ПоказателиОтчета.Вставить(СтрокаИзменений.Раздел, ПоказателиРаздела);
				// Возведем признак модифицированности структуры
				ПроизошлиИзмененияВПоказателяхОтчета = Истина;

				// Если показатель есть в ПоказателяхОтчета, то далее в многостраничных частях поиск НЕ осуществляем.
				Продолжить;

			КонецЕсли;

		КонецЕсли;

		Если ЕстьМногостраничность Тогда
			РазделСчитан = Ложь;
			Если ДанныеМногостраничныхРазделов.Свойство(СтрокаИзменений.Раздел, ДанныеРаздела) Тогда
				РазделСчитан = Истина;
			КонецЕсли;

			Если НЕ РазделСчитан Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если ЕстьМногостраничность Тогда

			СтруктураДок = ДанныеРаздела;
			Лист = -1;
			Для Каждого ЭлементР Из ДанныеРаздела Цикл

				Попытка
					Значение = ЭлементР.Данные[СтрокаИзменений.СтарыйПоказатель];
				Исключение
					// Требуемого параметра нет на листе многостраничного документа.
					Продолжить;
				КонецПопытки;

				Лист = Лист + 1;
				СтруктураДок[Лист].Данные.Удалить(СтрокаИзменений.СтарыйПоказатель);
				СтруктураДок[Лист].Данные.Вставить(СтрокаИзменений.НовыйПоказатель, Значение);
			КонецЦикла;

			Если Лист <> -1 Тогда
				ДанныеРаздела = СтруктураДок;
				ПроизошлиИзмененияВМногостраничномРазделе = Истина;
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если ПроизошлиИзмененияВМногостраничномРазделе Тогда
		// вставляем данные многостраничных разделов
		СохраненныйСписок.Вставить("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов);
	КонецЕсли;

	Если ПроизошлиИзмененияВПоказателяхОтчета Тогда
		СохраненныйСписок.Вставить("ПоказателиОтчета", ПоказателиОтчета);
	КонецЕсли;

	Если ПроизошлиИзмененияВМногостраничномРазделе Или ПроизошлиИзмененияВПоказателяхОтчета Тогда

		Сообщить("Произведены изменения в структуре данных регламентированного отчета: " + СохраненныйДок.НаименованиеОтчета);

		ХранилищеДанных = Новый ХранилищеЗначения(СохраненныйСписок);
		СохраненныйДокОбъект = СохраненныйДок.ПолучитьОбъект();
		СохраненныйДокОбъект.ДанныеОтчета = ХранилищеДанных;
		СохраненныйДокОбъект.Записать();

	КонецЕсли;

КонецПроцедуры // ИзменитьИменаПоказателейВСохраненномОтчете

// ОпределитьПринадлежностьМногострочнойЧастиКЛистуДекларации
//
Функция ОпределитьПринадлежностьМногострочнойЧастиКЛистуДекларации(ИдГруппы, ИмяФормы, НомерКонвертации)

	Если НомерКонвертации = 1 Тогда
		Результат = "";
		Если ИмяФормы = "РегламентированныйОтчетАкцизыПриложение1" Тогда

			Если (ИдГруппы = "П0000200010")
			Или (ИдГруппы = "П0000200020")
			Или (ИдГруппы = "П0000200030")
			Или (ИдГруппы = "П0000200040")
			Или (ИдГруппы = "П0000200050")
			Или (ИдГруппы = "П0000200060")
			Или (ИдГруппы = "П0000200070")
			Или (ИдГруппы = "П0000200080")
			Или (ИдГруппы = "П0000200090")
			Или (ИдГруппы = "П0000200100")
			Или (ИдГруппы = "П0000200110") Тогда
				Результат = "Раздел2";
			ИначеЕсли (ИдГруппы = "П0002100050") Или (ИдГруппы = "П0002100070") Тогда
				Результат = "Приложение1";
			ИначеЕсли (ИдГруппы = "П0002200050") Или (ИдГруппы = "П0002200070") Тогда
				Результат = "Приложение2";
			ИначеЕсли ИдГруппы = "П0002300050" Тогда
				Результат = "Приложение3";
			ИначеЕсли ИдГруппы = "П0002400050" Тогда
				Результат = "Приложение4";
			ИначеЕсли ИдГруппы = "П0002500010" Тогда
				Результат = "Приложение5";
			ИначеЕсли ИдГруппы = "П0000400070" Тогда
				Результат = "Приложение7";
			КонецЕсли;

		ИначеЕсли ИмяФормы = "РегламентированныйОтчетНДС" Тогда
			Если ИдГруппы = "П0000500010" Тогда
				Результат = "Раздел5";
			ИначеЕсли ИдГруппы = "П0000600010" Тогда
				Результат = "Раздел6";
			КонецЕсли;

		ИначеЕсли ИмяФормы = "РегламентированныйОтчетНДС0" Тогда
			Если ИдГруппы = "П0000300050" Тогда
				Результат = "Раздел3";
			ИначеЕсли ИдГруппы = "П0000300060" Тогда
				Результат = "Раздел3";
			КонецЕсли;

		ИначеЕсли ИмяФормы = "РегламентированныйОтчетДоходыЗаПределамиРФ" Тогда
			Если ИдГруппы = "П0000200100" Тогда
				Результат = "Раздел2";
			ИначеЕсли (ИдГруппы = "П0000300070")
				Или (ИдГруппы = "П0000300080")
				Или (ИдГруппы = "П0000300090")
				Или (ИдГруппы = "П0000300110")
				Или (ИдГруппы = "П0000300120")
				Или (ИдГруппы = "П0000300130") Тогда
				Результат = "Раздел3";
			КонецЕсли;

		ИначеЕсли ИмяФормы = "РегламентированныйОтчетАкцизыПриложение3" Тогда

			Если ИдГруппы = "П0002100050" Тогда
				Результат = "Приложение1";
			Иначе
				Результат = "Приложение2";
			КонецЕсли;

		ИначеЕсли ИмяФормы = "РегламентированныйОтчетАкцизыПриложение5" Тогда

			Если ИдГруппы = "П0002400050" Тогда
				Результат = "Приложение1";
			ИначеЕсли ИдГруппы = "П0002500040" Тогда
				Результат = "Приложение2";
			ИначеЕсли ИдГруппы = "П0002600050" Тогда
				Результат = "Приложение3";
			ИначеЕсли ИдГруппы = "П0002700040" Тогда
				Результат = "Приложение4";
			КонецЕсли;

		КонецЕсли;

		Возврат Результат;

	КонецЕсли;

КонецФункции // ОпределитьПринадлежностьМногострочнойЧастиКЛистуДекларации

// КонвертацияФормМСФО
// Процедура перебирает формы регламентированной отчетности и у 6-ти форм МСФО
// в случае отсутствия показателя ВыбраннойФормы, записывает "МСФО" - для восстановления
// и возможности корректной работы с отчетностью МСФО.
// Параметры:
//  Нет.
// Возвращаемое значение:
//  Нет.
//
Процедура КонвертацияФормМСФО() Экспорт

	Если ИдКонфигурации() <> "УПП" Тогда
		Возврат;
	КонецЕсли;

	ВыборкаРегламентированныхОтчетов = Документы.РегламентированныйОтчет.Выбрать();

	Сообщить("Идет обработка отчетности МСФО...");
	Пока ВыборкаРегламентированныхОтчетов.Следующий() Цикл
		
		ИмяОтчета = СокрЛП(ВыборкаРегламентированныхОтчетов.ИсточникОтчета);
		
		Если ИмяОтчета = "МСФОБаланс" ИЛИ
			 ИмяОтчета = "МСФОДвижениеКапитала" ИЛИ
			 ИмяОтчета = "МСФОДДС" ИЛИ
			 ИмяОтчета = "МСФОПрибылиИУбытки" ИЛИ
			 ИмяОтчета = "МСФОПримечания" ИЛИ
			 ИмяОтчета = "МСФОУчетнаяПолитика" Тогда

			// Если ВыбраннаяФорма пустое значение.
			Если ПустоеЗначение(ВыборкаРегламентированныхОтчетов.ВыбраннаяФорма) Тогда
				СписокСохранения = ВыборкаРегламентированныхОтчетов.Ссылка.ДанныеОтчета.Получить();

				// Получим версию формы, в которой был сохранен отчет
				ВерсияФормы = Неопределено;
				СписокСохранения.Свойство("ВерсияФормы", ВерсияФормы);

				Если (ИмяОтчета = "МСФОБаланс" И (ВерсияФормы = "30/01/2004"             Или ВерсияФормы = "30/01/2005"))
				   ИЛИ (ИмяОтчета = "МСФОДвижениеКапитала" И (ВерсияФормы = "30/09/2003" Или ВерсияФормы = "30/09/2005"))
				   ИЛИ (ИмяОтчета = "МСФОДДС" И (ВерсияФормы = "30/09/2003"              Или ВерсияФормы = "30/09/2005"))
				   ИЛИ (ИмяОтчета = "МСФОПрибылиИУбытки" И (ВерсияФормы = "30/09/2003"   Или ВерсияФормы = "30/09/2005"))
				   ИЛИ (ИмяОтчета = "МСФОПримечания" И (ВерсияФормы = "30/09/2003"       Или ВерсияФормы = "30/09/2005"))
				   ИЛИ (ИмяОтчета = "МСФОУчетнаяПолитика" И ВерсияФормы = "30/09/2004") Тогда
					// ХранилищеДанных = Новый ХранилищеЗначения(СписокСохранения);
					СохраненныйДокОбъект = ВыборкаРегламентированныхОтчетов.Ссылка.ПолучитьОбъект();
					// СохраненныйДокОбъект.ДанныеОтчета = ХранилищеДанных;
					СохраненныйДокОбъект.ВыбраннаяФорма = "МСФО";
					СохраненныйДокОбъект.Записать();
					Сообщить("Документ " + ВыборкаРегламентированныхОтчетов.НаименованиеОтчета + " изменен успешно.");
				КонецЕсли;

			КонецЕсли;

		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры // КонвертацияФормМСФО

// роДобавитьКолонкуАвтоматическогоПредставленияВСтруктуруМногостраничныхРазделов
//
Процедура роДобавитьКолонкуАвтоматическогоПредставленияВСтруктуруМногостраничныхРазделов() Экспорт

	Перем ДанныеМногостраничныхРазделов;
	Перем ТаблицаМногостраничногоДокумента;
	Перем мОписаниеТиповБулево;

	МассивБулево = Новый Массив;
	МассивБулево.Добавить(Тип("Булево"));
	мОписаниеТиповБулево    = Новый ОписаниеТипов(МассивБулево);
	СчетчикУспешныхИзменений = 0;
	СчетчикНеУспешныхИзменений = 0;

	Выборка = Документы.РегламентированныйОтчет.Выбрать();

	Сообщить("Изменяется структура многостраничных разделов в регламентированных отчетах ...");
	Пока Выборка.Следующий() Цикл

		Док = Выборка.ПолучитьОбъект();
		ДанныеОтчета = Док.ДанныеОтчета.Получить();

		Если ДанныеОтчета = Неопределено ИЛИ ТипЗнч(ДанныеОтчета) <> Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;

		МногостраничностьВДекларацииОтсутствует = Истина;
		ИзмененияВнесены = Ложь;

		// Получим данные многостраничных разделов.
		Если ДанныеОтчета.Свойство("ДанныеМногостраничныхРазделов", ДанныеМногостраничныхРазделов) Тогда

			МногостраничностьВДекларацииОтсутствует = Ложь;

			// В каждый раздел многостраничного документа добавим колонку АвтоматическоеПредставление
			Для Каждого ЭлементСтруктуры Из ДанныеМногостраничныхРазделов Цикл

				//ДанныеМногостраничныхРазделов.Свойство(ЭлементСтруктуры.Ключ, ТаблицаМногостраничногоДокумента);
				ТаблицаМногостраничногоДокумента = ЭлементСтруктуры.Значение;

				Если ТаблицаМногостраничногоДокумента.Колонки.Найти("АвтоматическоеПредставление") = Неопределено Тогда
					// Возводим признак изменения структуры многостраничных разделов.
					ИзмененияВнесены = Истина;
					ТаблицаМногостраничногоДокумента.Колонки.Добавить("АвтоматическоеПредставление", мОписаниеТиповБулево);

					// Проставим признак автозаполнения представления.
					Для Каждого Элемент Из ТаблицаМногостраничногоДокумента Цикл
						Элемент.АвтоматическоеПредставление = Истина;
					КонецЦикла;

				КонецЕсли;

			КонецЦикла;

		КонецЕсли;

		Если НЕ МногостраничностьВДекларацииОтсутствует И ИзмененияВнесены Тогда
			ХранилищеДанных = Новый ХранилищеЗначения(ДанныеОтчета);
			Док.ДанныеОтчета = ХранилищеДанных;
			ДокументЗаписан = Истина;
			Попытка
				Док.Записать();
			Исключение
				ДокументЗаписан = Ложь;
			КонецПопытки;

			Если ДокументЗаписан Тогда
				//Сообщить("Документ " + Выборка.НаименованиеОтчета + " изменен успешно.");
				СчетчикУспешныхИзменений = СчетчикУспешныхИзменений + 1;
			Иначе
				//Сообщить("Документ " + Выборка.НаименованиеОтчета + " не удалось изменить.");
				СчетчикНеУспешныхИзменений = СчетчикНеУспешныхИзменений + 1;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Если (СчетчикУспешныхИзменений <> 0) Или (СчетчикНеУспешныхИзменений <> 0) Тогда
		Сообщить("Изменено отчетов: " + Строка(СчетчикУспешныхИзменений) + "; не изменено: " + Строка(СчетчикНеУспешныхИзменений));
	КонецЕсли;

КонецПроцедуры // роДобавитьКолонкуАвтоматическогоПредставленияВСтруктуруМногостраничныхРазделов

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫБОРКИ ДАННЫХ 
//

// Возвращает сокращенный уникальный идентификатор текущей конфигурации.
Функция ИДКонфигурации() Экспорт
	Возврат РегламентированнаяОтчетность.ИДКонфигурации();
КонецФункции // ИДКонфигурации()

// Возвращает номер редакции текущей конфигурации.
//  Номер редакции выделяется из полного номера версии конфигурации 
// и представляет собой все символы до второй точки.
//
Функция РедакцияКонфигурации() Экспорт
	
	Перем Версия;
	Перем ПерваяТочка;

	Версия = Метаданные.Версия;
	ПерваяТочка = Найти(Версия, ".");

	Возврат СокрЛП(Лев(Версия, Найти(Сред(Версия, ПерваяТочка + 1), ".") + ПерваяТочка - 1));

КонецФункции // РедакцияКонфигурации()

#Если Клиент Тогда

#КонецЕсли
	
//Проверяет на наличие только русских букв (допускаются пробелы и дефис и некоторые спец символы)
Функция СтрокаНаписанаПоРусски(Знач СтрокаПараметр) Экспорт

	СтрокаПараметр = СокрЛП(СтрокаПараметр);	

	СписокДопустимыхЗначений = Новый СписокЗначений;
	СписокДопустимыхЗначений.Добавить(184); 
	СписокДопустимыхЗначений.Добавить(168);
	СписокДопустимыхЗначений.Добавить(45);
	СписокДопустимыхЗначений.Добавить(46);
	СписокДопустимыхЗначений.Добавить(32);
	СписокДопустимыхЗначений.Добавить(48);
	СписокДопустимыхЗначений.Добавить(49);
	СписокДопустимыхЗначений.Добавить(50);
	СписокДопустимыхЗначений.Добавить(51);
	СписокДопустимыхЗначений.Добавить(52);
	СписокДопустимыхЗначений.Добавить(53);
	СписокДопустимыхЗначений.Добавить(54);
	СписокДопустимыхЗначений.Добавить(55);
	СписокДопустимыхЗначений.Добавить(56);
	СписокДопустимыхЗначений.Добавить(57);

	Для Сч=1 По СтрДлина(СтрокаПараметр) Цикл
		Код = КодСимвола(СтрокаПараметр,Сч);
		Если (Код<192) И (СписокДопустимыхЗначений.НайтиПоЗначению(Код) = Неопределено) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;

	Возврат Истина;
КонецФункции 

//Функция возвращает информацию об ответственных лицах организации и их должностях 
Функция ОтветственныеЛицаОрганизаций(Организация, ДатаСреза, Исполнитель = Неопределено) Экспорт

	Возврат РегламентированнаяОтчетность.ОтветственныеЛицаОрганизаций(Организация, ДатаСреза, Исполнитель);

КонецФункции // ОтветственныеЛицаОрганизаций()

//Представляет адрес в "удобочитаемом" виде	для отражения в формах
//
//	Параметры: 
//		АдреснаяСтрока (строка), адрес представление которого нужно вернуть.
//		Способ - способ представления адреса (если=1, то возвращает представление адреса без индекса)
//
//	Возвращаемое значение:
//		строку - представление адреса
//
//	Описание:
//		Предназначена для формирования адресной строки в "удобочитаемом" виде
//		для отражения в формах.
//
Функция ПредставлениеАдреса(Знач АдреснаяСтрока, Способ = 0, ПредставлениеПустого = "<<Адрес не задан>>") Экспорт

	Если НЕ ЗначениеЗаполнено(СтрЗаменить(АдреснаяСтрока,",","")) Тогда
		Возврат ПредставлениеПустого;
	КонецЕсли;

	СтруктураАдрес = РазложитьАдрес(АдреснаяСтрока);
	Если АдресСоответствуетТребованиям(СтруктураАдрес) Тогда
		Адрес = "";
		Если ЗначениеЗаполнено(СтруктураАдрес.Страна) Тогда
			СсылкаНаСтрану = Справочники.КлассификаторСтранМира.НайтиПоКоду(СтруктураАдрес.Страна);
			Если НЕ СсылкаНаСтрану.Пустая() Тогда
				Адрес = Адрес +", "+ СсылкаНаСтрану.Наименование;
			Иначе
				Адрес = Адрес +", "+ СтруктураАдрес.Страна;
			КонецЕсли;
		КонецЕсли;

		Если ЗначениеЗаполнено(СтруктураАдрес.Индекс)и(Способ<>1) тогда
			Адрес = Адрес + СтруктураАдрес.Индекс;
		КонецЕсли;	 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Регион),", "+СтруктураАдрес.Регион,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Район),", "+СтруктураАдрес.Район,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Город),", "+СтруктураАдрес.Город,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.НаселенныйПункт),", "+СтруктураАдрес.НаселенныйПункт,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Улица),", "+СтруктураАдрес.Улица,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Дом),", д."+СтруктураАдрес.Дом,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Корпус),", корп. "+СтруктураАдрес.Корпус,""); 
		Адрес =Адрес + ?(ЗначениеЗаполнено(СтруктураАдрес.Квартира),", кв. "+СтруктураАдрес.Квартира,""); 

		Адрес = Сред(Адрес,1);//Убрали первую запятую
	Иначе
		Адрес = СтрЗаменить(АдреснаяСтрока, Символы.ПС, ", ");
	КонецЕсли;
	Возврат Адрес;
КонецФункции	// глПредставлениеАдреса

//Определяет соответствие основных параметров адреса требованиям ФНС
//
Функция АдресСоответствуетТребованиям(Знач СтруктураАдрес) Экспорт
	
	Город = СтруктураАдрес.Город;
	Город = СтрЗаменить(Город,"с/с","");
	Город = СтрЗаменить(Город,"с/а","");  
	Город = СтрЗаменить(Город,"с/мо","");
	Город = СтрЗаменить(Город,"с/о",""); 
	НаселенныйПункт = СтруктураАдрес.НаселенныйПункт;
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"ж/д_","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"ж/д","");  
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/р","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/ст",""); 
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"п/о",""); 

	// Элементы классификатора KLADR. Встречаются элементы с "/". "(", ")".
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"/","");
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,"(",""); 
	НаселенныйПункт = СтрЗаменить(НаселенныйПункт,")",""); 

	Улица = СтруктураАдрес.Улица; 

	// Элементы классификатора сокращений.
	Улица = СтрЗаменить(Улица,"ж/д_","");
	Улица = СтрЗаменить(Улица,"ж/д","");  
	Улица = СтрЗаменить(Улица,"п/о","");
	Улица = СтрЗаменить(Улица,"п/ст",""); 
	Улица = СтрЗаменить(Улица,"п/р","");

	// Элементы классификатора STREET. Встречаются улицы с "/". "(", ")". 
	Улица = СтрЗаменить(Улица,"/","");
	Улица = СтрЗаменить(Улица,"(","");
	Улица = СтрЗаменить(Улица,")","");

	Если СтруктураАдрес.Количество()<>10 Тогда // должно быть 10 элементов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Страна) > 3  Тогда   // код страны не > 3 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СокрЛП(СтруктураАдрес.Индекс)) <> 6  Тогда   // в индексе ровно 6 символов
		Возврат Ложь;
	ИначеЕсли Не ОбщегоНазначения.ТолькоЦифрыВСтроке(СтруктураАдрес.Индекс) Тогда   // индекс состоит из цифр
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Регион) > 45 Тогда   // наим.региона не > 45 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Район) > 35 Тогда   // наим.района не > 35 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(СтруктураАдрес.Район) Тогда   // наим.района написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Город) > 35 Тогда   // наим.города не > 35 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(Город) Тогда   // наим.города написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.НаселенныйПункт) > 45 Тогда   // наим.нас.пункта не > 45 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(НаселенныйПункт) Тогда   // наим.нас.пункта написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Улица) > 45 Тогда   // наим.улицы не > 45 символов
		Возврат Ложь;
	ИначеЕсли НЕ СтрокаНаписанаПоРусски(Улица) Тогда   // наим.улицы написано не русскими буквами
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Дом) > 10 Тогда   // номер дома не > 10 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Корпус) > 10 Тогда   // номер корпуса не > 10 символов
		Возврат Ложь;
	ИначеЕсли СтрДлина(СтруктураАдрес.Квартира)> 10 Тогда   // номер квартиры не > 10 символов
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции	

//Получает текст файла сведений из регистра
Функция ПолучитьТекстФайлаИзРегистра(ДокументСсылка) 

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ДокументСсылка" , ДокументСсылка);

	Запрос.Текст = "ВЫБРАТЬ
	|	АрхивДанныхРегламентированнойОтчетности.Данные
	|ИЗ
	|	РегистрСведений.АрхивДанныхРегламентированнойОтчетности КАК АрхивДанныхРегламентированнойОтчетности
	|
	|ГДЕ
	|	АрхивДанныхРегламентированнойОтчетности.Объект = &ДокументСсылка";

	ВыборкаДанных = Запрос.Выполнить().Выбрать();

	Если ВыборкаДанных.Следующий() тогда
		Возврат ВыборкаДанных.Данные;
	Иначе	
		Возврат "";
	КонецЕсли;	 

КонецФункции	

//Получает текст файла сведений, сформированного по данным документа
Функция ПолучитьТекстФайла(ДокументОбъект,Отказ) Экспорт

	Если ДокументОбъект.Проведен тогда
		//Для проведенного документа берём сохраненный ранее текст файла 
		Отказ = Ложь;
		Возврат ПолучитьТекстФайлаИзРегистра(ДокументОбъект.Ссылка);

	Иначе
		Возврат ДокументОбъект.СформироватьВыходнойФайл(Отказ);

	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ПРЕОБРАЗОВАНИЯ ЗНАЧЕНИЙ
//

//Собирает из элементов структуры адреса строку записи адреса в формате 9 запятых
Функция СобратьАдрес(Знач СтруктураАдрес) Экспорт

	Возврат ""+ СтруктураАдрес.Страна + "," + СтруктураАдрес.Индекс + ","+ СтруктураАдрес.Регион + ","
	+ СтруктураАдрес.Район  + "," + СтруктураАдрес.Город  + ","+ СтруктураАдрес.НаселенныйПункт + ","
	+ СтруктураАдрес.Улица  + "," + СтруктураАдрес.Дом    + ","+ СтруктураАдрес.Корпус + "," + СтруктураАдрес.Квартира

КонецФункции	 

//Разбивает серию документа удостоверяющего личность на 2 части: до и после разделителя
Функция РазложитьСериюДокумента(Знач ВидДокумента, Знач СерияДокумента) Экспорт

	Часть1 = "";
	Часть2 = "";
	
	Если ЗначениеЗаполнено(ВидДокумента) тогда
		
		КодДока = ВидДокумента.КодИМНС;

		Если (КодДока = "01") или (КодДока = "03")  Тогда
			//Свидетельство о рождении или Паспорт гражданина СССР. . Разделитель групп - "-"
			Разделитель = Найти(СерияДокумента, "-");
			Часть1 = ?(Разделитель = 0, СерияДокумента, ЗаменитьОдниСимволыДругими("1УХЛС", ВРег(СокрЛП(Лев(СерияДокумента, Разделитель-1))), "IVXLC"));
			Часть2 = ?(Разделитель = 0, "", СокрЛП(Сред(СерияДокумента, Разделитель + 1)));
		ИначеЕсли (КодДока = "02") Или (КодДока = "22") Тогда
			//Загранпаспорт гражданина СССР и РФ - первая часть не заполняется, заполняется только вторая часть
			Часть2 = СерияДокумента;
		ИначеЕсли КодДока = "21"  Тогда
			//Паспорт гражданина Российской Федерации. Разделитель групп - " "
			Разделитель = Найти(СерияДокумента, " ");
			Часть1 = ?(Разделитель = 0, СерияДокумента, СокрЛП(Лев(СерияДокумента, Разделитель - 1)));
			Часть2 = ?(Разделитель = 0, "", СокрЛП(Сред(СерияДокумента, Разделитель + 1)));
		Иначе	
			Часть1 = СерияДокумента;
		КонецЕсли;
		
	КонецЕсли;	 

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Часть1",Часть1);
	СтруктураВозврата.Вставить("Часть2",Часть2);
	Возврат СтруктураВозврата;
	
КонецФункции	 

//Возвращает строковое представление места рождения
Функция ПредставлениеМестаРождения(Знач СтрокаМестоРождения) Экспорт

	СтруктураМестоРождения = РазложитьМестоРождения(СтрокаМестоРождения, Ложь);

    Если СтруктураМестоРождения.Особое = 1 Тогда
	
		Представление	=	"особое" +
		?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.НаселенныйПункт),		"",	"  "	+	СокрЛП(СтруктураМестоРождения.НаселенныйПункт))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Район),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Район))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Область),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Область))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Страна),	"",	"  "	+	СокрЛП(СтруктураМестоРождения.Страна));
	
	Иначе
	
		Представление	= "" + ?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.НаселенныйПункт),		"",	"Населенный пункт: " + СокрЛП(СтруктураМестоРождения.НаселенныйПункт))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Район),	"",	", район:  " + СокрЛП(СтруктураМестоРождения.Район))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Область),	"",	", область: "	+	СокрЛП(СтруктураМестоРождения.Область))
		+?(НЕ ЗначениеЗаполнено(СтруктураМестоРождения.Страна),	"",	", страна: "	+	СокрЛП(СтруктураМестоРождения.Страна));
		
		Если Лев(Представление, 1) = ","  Тогда
			Представление = Сред(Представление, 2)
		КонецЕсли;
			
	КонецЕсли; 

	Возврат Представление;
КонецФункции	 

//Функция раскладывает строку с данными об адресе (в формате 9 запятых) на элементы структуры
Функция РазложитьАдрес(Знач СтрокаАдрес) Экспорт
	
	Страна = "";
	Индекс = "";
	Регион = "";
	Район = "";
	Город = "";
	НаселенныйПункт = "";
	Улица ="";
	Дом ="";
	Корпус ="";
	Квартира ="";

	МассивАдрес	=	ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(СтрокаАдрес);
	ЭлементовВМассиве = МассивАдрес.Количество();   

	Если ЭлементовВМассиве	>	0	тогда
		Страна	=	СокрЛП(МассивАдрес[0]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	1	тогда
		Индекс	=	СокрЛП(МассивАдрес[1]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	2	тогда
		Регион	=	СокрЛП(МассивАдрес[2]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	3	тогда
		Район	=	СокрЛП(МассивАдрес[3]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	4	тогда
		Город	=	СокрЛП(МассивАдрес[4]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	5	тогда
		НаселенныйПункт	=	СокрЛП(МассивАдрес[5]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	6	тогда
		Улица	=	СокрЛП(МассивАдрес[6]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	7	тогда
		Дом	=	СокрЛП(МассивАдрес[7]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	8	тогда
		Корпус	=	СокрЛП(МассивАдрес[8]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	9	тогда
		Квартира	=	СокрЛП(МассивАдрес[9]);
	КонецЕсли;

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Страна",Страна);
	СтруктураВозврата.Вставить("Индекс",Индекс);
	СтруктураВозврата.Вставить("Регион",Регион);
	СтруктураВозврата.Вставить("Район",Район);
	СтруктураВозврата.Вставить("Город",Город);
	СтруктураВозврата.Вставить("НаселенныйПункт",НаселенныйПункт);
	СтруктураВозврата.Вставить("Улица",Улица);
	СтруктураВозврата.Вставить("Дом",Дом);
	СтруктураВозврата.Вставить("Корпус",Корпус);
	СтруктураВозврата.Вставить("Квартира",Квартира);

	Возврат СтруктураВозврата;
	
КонецФункции	 

//Функция раскладывает строку с данными о месте рождения на элементы структуры
Функция РазложитьМестоРождения(Знач СтрокаМестоРождения, ВерхнийРегистр = Истина) Экспорт

	Особое = 0;НаселенныйПункт	= "";Район	= "";Область	= "";Страна	= "";

	//МассивМестоРождения	=	ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(Врег(СтрокаМестоРождения));
	МассивМестоРождения	=	ОбщегоНазначения.РазложитьСтрокуВМассивПодстрок(?(ВерхнийРегистр, Врег(СтрокаМестоРождения), СтрокаМестоРождения));
	
	ЭлементовВМассиве = МассивМестоРождения.Количество();   
	Если ЭлементовВМассиве	>	0	тогда
		Если СокрЛП(МассивМестоРождения[0]) = "1" тогда
			Особое	=	1;
		КонецЕсли;	 
	КонецЕсли;
	Если ЭлементовВМассиве	>	1	тогда
		НаселенныйПункт	=	СокрЛП(МассивМестоРождения[1]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	2	тогда
		Район	=	СокрЛП(МассивМестоРождения[2]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	3	тогда
		Область	=	СокрЛП(МассивМестоРождения[3]);
	КонецЕсли;
	Если ЭлементовВМассиве	>	4	тогда
		Страна	=	СокрЛП(МассивМестоРождения[4]);
	КонецЕсли;

	СтруктураВозврата = Новый Структура;
	СтруктураВозврата.Вставить("Особое",Особое);
	СтруктураВозврата.Вставить("НаселенныйПункт",НаселенныйПункт);
	СтруктураВозврата.Вставить("Район",Район);
	СтруктураВозврата.Вставить("Область",Область);
	СтруктураВозврата.Вставить("Страна",Страна);
	Возврат СтруктураВозврата;
	
КонецФункции	 

#Если Клиент Тогда

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДИАЛОГАМИ
//

//Выполняет запись документа в случае подтверждения пользователем
Функция ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,ТекстВопросаПодтверждения) Экспорт

	Если ДокументОбъект.ЭтоНовый() или ДокументОбъект.Модифицированность() Тогда
		Ответ  = Вопрос(ТекстВопросаПодтверждения, РежимДиалогаВопрос.ОКОтмена);
		Если Ответ = КодВозвратаДиалога.ОК Тогда
			ДокументОбъект.Записать();
		Иначе
			Возврат ложь;
		КонецЕсли;
	КонецЕсли;

	Возврат Истина;

КонецФункции

//Предлагает пользователю указать каталог для выгрузки декларации в электронном виде
Функция ПолучитьПутьВыгрузки(ПутьДляВыгрузки = Неопределено) Экспорт

	ФормаПараметровСохранения = роПолучитьОбщуюФорму("НастройкаПараметровСохраненияРегламентированногоОтчета");
	ФормаПараметровСохранения.ПутьДляВыгрузки = ПутьДляВыгрузки;

	РезВыбора = ФормаПараметровСохранения.ОткрытьМодально();
	Если РезВыбора = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	Если НЕ РезВыбора Тогда
		Возврат Ложь;
	Иначе
		Возврат ФормаПараметровСохранения.ПутьДляВыгрузки;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ СВЕДЕНИЙ
//

//Предоставляет сформированный файл сведений документа для просмотра
Процедура ПоказатьФайлДокумента(ДокументОбъект, ЗаголовокОкна) Экспорт

	Вопрос = "Перед формированием файла необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;	 

	ЕстьОшибки = Ложь;
	ТекстФайла = ПолучитьТекстФайла(ДокументОбъект,ЕстьОшибки);
	Если ЕстьОшибки тогда
		Возврат;
	КонецЕсли;	 
	
	//Если ТипЗнч(ТекстФайла) = Тип("Строка") Тогда
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстФайла); 
		ТекстовыйДокумент.Показать(ЗаголовокОкна, "Файл сведений");
	//Иначе //тип("ТекстовыйДокумент")	
	//	ТекстФайла.Показать(ЗаголовокОкна, "Файл сведений");
	//КонецЕсли; 
	
КонецПроцедуры	 

//Записывает файл сведений документа в каталог, указанный пользователем
Процедура ЗаписатьФайлДокументаНаДискету(ДокументОбъект, ТекущийПользователь, ИмяФайла) Экспорт
	
	Вопрос = "Перед формированием файла необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;

	ЕстьОшибки = Ложь;
	ТекстФайла = ПолучитьТекстФайла(ДокументОбъект,ЕстьОшибки);
	Если ЕстьОшибки тогда
		Возврат;
	КонецЕсли;

	Длг = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.ВыборКаталога);

	Длг.Каталог = УправлениеПользователями.ПолучитьЗначениеПоУмолчанию(ТекущийПользователь,"ОсновнойКаталогФайлов");
	Длг.Заголовок = "Укажите каталог";

	Если Длг.Выбрать() Тогда
		ИмяФайла = Длг.Каталог+"\" + ИмяФайла;
		//Если ТипЗнч(ТекстФайла) = Тип("Строка") Тогда
			ТекстовыйДокумент = Новый ТекстовыйДокумент;
			ТекстовыйДокумент.УстановитьТекст(ТекстФайла); 
			ТекстовыйДокумент.Записать(ИмяФайла,КодировкаТекста.OEM);
		//Иначе//тип("ТекстовыйДокумент")
		//	ТекстФайла.Записать(ИмяФайла, КодировкаТекста.OEM);
		//КонецЕсли;	
		Предупреждение("Файл-пачка записан под именем: "+ИмяФайла);
	КонецЕсли;
	
КонецПроцедуры	

//Печатает файл сведений документа
Процедура РаспечататьФайлДокумента(ДокументОбъект) Экспорт
	Вопрос = "Перед печатью необходимо записать документ. Записать?";
	Если НЕ ТребованиеЗаписиДокументаУдовлетворено(ДокументОбъект,Вопрос) тогда
		Возврат;
	КонецЕсли;	
	ДокументОбъект.ПечатьФайла();
КонецПроцедуры 


#КонецЕсли

// Проверяет указанный Реквизит на пустое значение.
// Значение Реквизита сравнивается с пустым значением соответствующего Реквизиту типа.
// Реквизит типа Строка считается пустым, если в нем не содержится значащих символов.
Функция ПустоеЗначение(Реквизит) Экспорт

	Если Реквизит = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Если ТипЗнч(Реквизит) = Тип("Строка") Тогда
		Возврат ПустаяСтрока(Реквизит);
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Число") Тогда
		Если Реквизит = 0 Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	ИначеЕсли ТипЗнч(Реквизит) = Тип("Дата") Тогда
		Если Реквизит = Дата('00010101') Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;

КонецФункции

// Проверяет указанную строку КодПок на соответствие требованиям, предъявляемым
// к именам предписанных показателей в форматах представления отчетности версий 2.00, 2.01 и 3.00
Функция ЭтоКодПоказателяП(КодПок) Экспорт
	
	Если СтрДлина(КодПок) < 13 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Пок = СокрЛП(КодПок);
	
	Если Сред(Пок, 1, 1) = "П" Тогда
		
		Для Сч = 2 По 13 Цикл
			
			КодСимв = КодСимвола(Пок, Сч);
			
			Если НЕ ((КодСимв >= КодСимвола("0", 1)) И (КодСимв <= КодСимвола("9", 1))) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Истина;
		
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

// Добавляет строку в текст с электронным представлением отчета
// Строка добавляется в формате ИмяПоказателя:ЗначениеПоказателя
// Параметры:
// Текст          - ТекстовыйДокумент, в который требуется добавить строку.
// ЗначениеЯчейки - значение показателя, который следует вывести.
// ИмяЯчейки      - имя показателя, который следует вывести.
// ПризнакФормата - строка с описанием формата показателя
// ФорматВыгрузки - второй параметр функции Формат (для показателей с признаком "Е" и "С")
Процедура ВывестиПоказатель(Текст, ЗначениеЯчейки, ИмяЯчейки, ПризнакФормата, ФорматВыгрузки) Экспорт
	
	Если ПустоеЗначение(ЗначениеЯчейки) И ПризнакФормата <> "Д" Тогда
		Текст.ДобавитьСтроку(ИмяЯчейки + ":")
	Иначе
		Если ПризнакФормата = "Е" Тогда
			ТекстЯчейкиКакЧисло = Число(СокрЛ(ЗначениеЯчейки));
			Если ТекстЯчейкиКакЧисло = 0 Тогда
				Текст.ДобавитьСтроку(ИмяЯчейки + ":")
			Иначе
				Текст.ДобавитьСтроку(ИмяЯчейки + ":" + СокрЛ(Формат(ЗначениеЯчейки,ФорматВыгрузки)));
			КонецЕсли;
		ИначеЕсли ПризнакФормата = "Д" Тогда 
			Если ПустоеЗначение(Дата(ЗначениеЯчейки)) = 1 Тогда
				Текст.ДобавитьСтроку(ИмяЯчейки + ":");
			Иначе
				Текст.ДобавитьСтроку(ИмяЯчейки + ":" + СокрЛ(Формат(ЗначениеЯчейки,"ДФ=dd.MM.yyyy; ДЛФ=D")));
			КонецЕсли;	
		Иначе
			Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда
				Знч = Формат(ЗначениеЯчейки, "ЧРД=.; ЧГ=0");
			Иначе
				Знч = ЗначениеЯчейки;
			КонецЕсли;
			Если ЗначениеЯчейки = "0" Тогда
				Текст.ДобавитьСтроку(ИмяЯчейки + ":")
			Иначе	
				Текст.ДобавитьСтроку(ИмяЯчейки + ":" + ВРЕГ(СокрЛП(Знч)));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;	
	
КонецПроцедуры

// Вычисляет значение показателя отчета по указанному "корню" имени показателя
// Например, 
// для показателей "ИНН_1"," ИНН_2" и т.д. "корнем" является "ИНН"
// для показателей "КПП1_1", "КПП1_2" и т.д. "корнем" является "КПП1"
// Параметры:
// Табл - таблица значений, описывающая показатели листа отчета
// Корень - строка - "корень", значение для которого требуется получить 
Функция ВычислитьЗначениеПоКорню(Табл, Корень) Экспорт
	
	Табл2 = Табл.Скопировать();
	ИтоговоеЗначение = "";
	
	Для Каждого Стр Из Табл2 Цикл
		
		Имя = Стр.Имя;
		//Если Лев(Имя, СтрДлина(Корень)) = Корень Тогда
		Если Имя = Корень Тогда
			ИтоговоеЗначение = ИтоговоеЗначение + Стр.Знач;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ((ВРЕГ(Лев(Корень, 4)) = "ДАТА") ИЛИ (СтрЧислоВхождений(Корень, "Дата") <> 0)) 
		И (((СтрДлина(ИтоговоеЗначение)=8) ИЛИ (СтрДлина(ИтоговоеЗначение)=6)) ИЛИ (ПустаяСтрока(ИтоговоеЗначение)))Тогда
		
		Если ПустаяСтрока(ИтоговоеЗначение) Тогда
			ИтоговоеЗначение = "00.00.0000";
		Иначе
			ИтоговоеЗначение = Лев(ИтоговоеЗначение, 2) + "." + Сред(ИтоговоеЗначение, 3, 2) + "." + Сред(ИтоговоеЗначение, 5);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ИтоговоеЗначение;
	
КонецФункции

//Функция собирает значения из отдельных "ячеек", например, ИНН1 из ИНН1_1 + ИНН1_2 + ...
Функция СвернутьДанныеТабличногоПоля(Данные) Экспорт
	
	ТП = Новый ТаблицаЗначений;
	ТП.Колонки.Добавить("Имя");
	ТП.Колонки.Добавить("Кол");
	ТП.Колонки.Добавить("Номер");
	ТП.Колонки.Добавить("Знач");
	//ТП.Колонки.Вставить(3, "КолСимвОснования");
	
	Для Каждого Стр Из Данные Цикл
		НоваяСтрока = ТП.Добавить();
		НоваяСтрока.Имя = Стр.Ключ;
		//Стр.Ключ = НоваяСтрока.Имя;
		НоваяСтрока.Кол = 1;
		НоваяСтрока.Знач = Стр.Значение;
	КонецЦикла;
	
	ТП.Сортировать("Имя");
	
	Для Каждого Стр Из ТП Цикл
		Имя = Стр.Имя;
		
		Если ЭтоКодПоказателяП(Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		ПризнакКвадратика = Ложь;//признак того, что значение является частью другого значения
		
		НомерСимвола = СтрДлина(Имя);
		Было_ = Ложь;//признак того, что в текущем наименовании показателя уже встречался символ "_"
		БылаЦифра = Ложь;
		
		Пока НомерСимвола > 0 Цикл
			
			Симв = Сред(Имя, НомерСимвола, 1);
			КодСимв = КодСимвола(Симв, 1);
			
			Если (КодСимв >= КодСимвола("0", 1) И КодСимв <= КодСимвола("9", 1)) ИЛИ (Симв = "_") Тогда
				
				Если Симв = "_" Тогда
					Если БылаЦифра Тогда
						
						ПризнакКвадратика = Истина;
						НомерСимвола = НомерСимвола - 1;
						Прервать;
						
					КонецЕсли;
				Иначе//это цифра
					БылаЦифра = Истина;
				КонецЕсли;
				
			Иначе
				Прервать;
			КонецЕсли;
			
			НомерСимвола = НомерСимвола - 1;
			
		КонецЦикла;
		
		Если БылаЦифра Тогда
			Корень = Лев(Стр.Имя, НомерСимвола);
			Номер = Сред(Стр.Имя, НомерСимвола + 1);
			Попытка
				Стр.Номер = Число( ?( Лев(Номер, 1) = "_", Сред(Номер, 2), Номер));
			Исключение
				Сообщить("Ошибки преобразования номера из окончания: " + Корень + " === " + Номер, СтатусСообщения.Важное);
			Конецпопытки;
			Стр.Имя = Корень;
		КонецЕсли;
		
	КонецЦикла;
	
	ТП.Сортировать("Имя, Номер");
	
	ТП2 = ТП.Скопировать();
	ТП2.Свернуть("Имя", "Кол");
	
	Для Каждого Стр Из ТП2 Цикл
		Если Стр.Имя = "П" Тогда
			Продолжить;
		КонецЕсли;
		Если Стр.Кол > 1 Тогда
			ЗначениеСводногоПоказателя = ВычислитьЗначениеПоКорню(ТП, Стр.Имя);
			//Сообщить(Стр.Имя + " = " + ЗначениеСводногоПоказателя);
			НайдЗнач = Неопределено;
			Если НЕ Данные.Свойство(Стр.Имя, НайдЗнач) Тогда
				Данные.Вставить(Стр.Имя, ЗначениеСводногоПоказателя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции


// Для указанного раздела возвращает структуру, описывающую подразделы.
// Параметры:
// ИмяРаздела - строка - имя раздела, для которого требуется определить подразделы
// мТаблицаСоставПоказателей - таблица значений, хранящая характеристики предписанных 
// показателей отчета
// МногострочныеИсключения - список значений, в котором указаны коды показателей,
// которые являются частью многострочного раздела и которые имеют номер строки, 
// отличный от предыдущего показателя, но которые не следует помещать в отдельный подраздел.
Функция РазбитьПоПодразделам(ИмяРаздела, мТаблицаСоставПоказателей, МногострочныеИсключения = Неопределено) Экспорт

	Если МногострочныеИсключения = Неопределено Тогда
		МногострочныеИсключения = Новый СписокЗначений;
	КонецЕсли;

	Подразделы = Новый Структура;
	СтрокиФорматаТекРаздела = мТаблицаСоставПоказателей.НайтиСтроки(Новый Структура("ИмяПоляТаблДокумента",ИмяРаздела));
	ПослМногостр = "^^^";
	ПослКодПоказателя = "П000000000000";

	Для Каждого Стр из СтрокиФорматаТекРаздела Цикл

		КодПоказателя = Стр.КодПоказателяПоСоставу;
		Многостр = Стр.ПризнМногострочности;
		Если КодПоказателя = "###" или КодПоказателя = "===" или Лев(КодПоказателя, 2) = "//" Тогда
			Продолжить;
		КонецЕсли;
		Если Многостр <> ПослМногостр Тогда
			Подразделы.Вставить(КодПоказателя, Многостр);
			ПослМногостр = Многостр;
		ИначеЕсли (Многостр = ПослМногостр) и (МногоСтр = "/") и (Лев(ПослКодПоказателя, 11) <> Лев(КодПоказателя, 11))
					и МногострочныеИсключения.НайтиПоЗначению(КодПоказателя) = Неопределено Тогда
			Подразделы.Вставить(КодПоказателя, Многостр);
			ПослМногостр = Многостр;
		КонецЕсли;

		ПослКодПоказателя = КодПоказателя;

	КонецЦикла;

	Возврат Подразделы;

КонецФункции

// Проверяет показатель на пустое значение.
// Параметры
// НазваниеОтчета - пользовательское представление отчета.
// Стр - строка таблицы значений, содержащая описание показателя, который требуется проверить
// Значение - значение показателя
// ВыводитьСообщения - признак, указывающий на необходимость добавления описания ошибки
// (ошибка - отсутствие значения у обязательного к заполнению показателя) в таблицу сообщений, 
// определенную в модуле формы, из которой вызвана функция
// НомерСтраницы - номер страницы, на которой находится прверяемый показатель
// НомерСтроки   - номер строки многострочной части, на которой находится показатель
// ПроверкаЗаполненияСтр - признак того, что функция вызвана из процедур проверки 
// на наличие заполненных показателей в разделе, на листе либо в строке многострочной части
// ФормаВыводаСообщений - форма, из которой была вызвана функция
Функция ПроверитьНаПустоеЗначение(НазваниеОтчета, Стр, Значение, ВыводитьСообщения, НомерСтраницы = Неопределено, НомерСтроки = Неопределено, ПроверкаЗаполненияСтр = 0, ФормаВыводаСообщений = Неопределено) Экспорт
	//возможны три варианта Стр.Обязательность:
	//"Н" - показатель "белый"
	//"О" - показатель обязательный
	//"" - показатель необязательный
	
	Если Найти(Стр.Обязательность, "Н") <> 0 и ПроверкаЗаполненияСтр = 1 Тогда
		Возврат 1; 
	КонецЕсли;
	
	Если Найти(Стр.Обязательность, "Н") <> 0 и ПроверкаЗаполненияСтр = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Если Стр.Обязательность = "" и ПроверкаЗаполненияСтр = 0 Тогда
		Возврат 0;
	КонецЕсли;
	
	Если ПустоеЗначение(Значение) Тогда
		Если ВыводитьСообщения Тогда
			Раздел = РазделПоКодуПоказателя(Стр.КодПоказателяПоСоставу);
			Стрк = СтрокаПоКодуПоказателя(Стр.КодПоказателяПоСоставу);
			Графа = ГрафаПоКодуПоказателя(Стр.КодПоказателяПоСоставу);
			
			Если ФормаВыводаСообщений <> Неопределено Тогда
				НовСтр = ФормаВыводаСообщений.ТаблицаСообщений.Добавить();
				НовСтр.Раздел = Стр.ИмяПоляТаблДокумента;
				НовСтр.Строка = Стрк;
				НовСтр.Графа = Графа;
				НовСтр.Страница = НомерСтраницы;
				НовСтр.СтрокаПП = НомерСтроки;
				Попытка
					КодНаФорме = Стр.КодПоказателяПоСтруктуре;
				Исключение
					КодНаФорме = Стр.КодПоказателяПоФорме;
				КонецПопытки;
				НовСтр.ИмяЯчейки = ?(ПустаяСтрока(КодНаФорме), Стр.КодПоказателяПоСоставу, КодНаФорме); 
				НовСтр.Описание = "Не задано значение";
			КонецЕсли;

		КонецЕсли;
		Возврат 1;
	Иначе
		Возврат 0;
	КонецЕсли;
		
КонецФункции

// Проверяет корректность заполнения показателя (по дополнительному описанию).
// Параметры
// НазваниеОтчета - пользовательское представление отчета.
// Стр - строка таблицы значений, содержащая описание показателя, который требуется проверить
// Значение - значение показателя
// ВыводитьСообщения - признак, указывающий на необходимость добавления описания ошибки
// (ошибка - отсутствие значения у обязательного к заполнению показателя) в таблицу сообщений, 
// определенную в модуле формы, из которой вызвана функция
// ФормаВыводаСообщений - форма, из которой была вызвана функция
Функция ПроверитьНаКорректность(НазваниеОтчета, Стр, Значение, ВыводитьСообщения, НомерСтраницы = Неопределено, ФормаВыводаСообщений = Неопределено) Экспорт
	
	ДопОписание = СокрЛП(Стр.ДопОписание);
	Если ПустаяСтрока(ДопОписание) Тогда
		Возврат 0;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Строка") И ЭтоКодПоказателяП(Стр.КодПоказателяПоСоставу) Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Возвращает номер раздела для указанного предписанного показателя
Функция РазделПоКодуПоказателя(КодПоказателя)
	Возврат Сред(КодПоказателя, 2, 5);
КонецФункции

// Возвращает номер строки для указанного предписанного показателя
Функция СтрокаПоКодуПоказателя(КодПоказателя)
	Возврат Сред(КодПоказателя, 9, 3);
КонецФункции

// Возвращает номер графы для указанного показателя
Функция ГрафаПоКодуПоказателя(КодПоказателя)
	КодГрафы = Строка(Число(Сред(КодПоказателя, 12, 2)));
	Возврат ?(КодГрафы = "0", "", КодГрафы);
КонецФункции

// Формирует пользовательское представление показателя по его коду
Функция УдобочитаемоеПредставлениеПоКодуПоказателя(КодПоказателя) Экспорт
	
	Если ЭтоКодПоказателяП(КодПоказателя) Тогда
		КодРаздела = Сред(КодПоказателя, 2, 5);
		КодСтроки = Сред(КодПоказателя, 9, 3);
		КодГрафы = Строка(Число(Сред(КодПоказателя, 12, 2)));
		Возврат "Раздел " + КодРаздела + ", Строка " + КодСтроки + ?(КодГрафы = "0", "", ", Графа " + КодГрафы);
	Иначе
		Возврат КодПоказателя;
	КонецЕсли;
	
КонецФункции

// Формирует пользовательское представление документа вида РегламентированныйОтчет
Функция ПредставлениеДокументаРеглОтч(Док) Экспорт
	
	Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	Если Док.Вид = 0 Тогда
		Представление = Представление + "(Первичный";
	Иначе
		Представление = Представление + "(Корректирующий, номер корректировки " + Док.Вид;
	КонецЕсли;
	Если ПустаяСтрока(Док.КодИМНС) Тогда
		Представление = Представление + ")";
	Иначе
		Представление = Представление + ". ИФНС: " + СокрЛП(Док.КодИМНС) + ")";
	КонецЕсли;
	Возврат Представление;
	
КонецФункции

// Проверяет правильность заполнения Ф.И.О.
Функция ФИОНаписаноВерно(Знач СтрокаПараметр) Экспорт
	
	СтрокаПараметр = СокрЛП(СтрокаПараметр);	
    
	СписокДопустимыхЗначений = Новый СписокЗначений;
	СписокДопустимыхЗначений.Добавить(КодСимвола(" ")); 
	СписокДопустимыхЗначений.Добавить(КодСимвола("-"));
	СписокДопустимыхЗначений.Добавить(КодСимвола("ё"));
	СписокДопустимыхЗначений.Добавить(КодСимвола("Ё"));
	
	Для Сч = 1 По СтрДлина(СтрокаПараметр) Цикл
		Код = КодСимвола(Сред(СтрокаПараметр, Сч));
		Если (((Код >= КодСимвола("A")) И (Код <= КодСимвола("z"))) ИЛИ ((Код >= КодСимвола("А")) И (Код <= КодСимвола("я")))) ИЛИ (СписокДопустимыхЗначений.НайтиПоЗначению(Код) <> Неопределено) Тогда
			Продолжить;
		Иначе
			Возврат	0;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 1;
	
КонецФункции // ФИОНаписаноВерно()

// Возвращает значение первого значащего из реквизитов, указанных в параметрах.
// Если оба реквизита неопределены, функция возвращает Неопределено
Функция ПолучитьРеквизит(Реквизит1, Реквизит2) Экспорт
	Если Реквизит1 <> Неопределено И Не ПустаяСтрока(Реквизит1) тогда
		Возврат Реквизит1;
	ИначеЕсли Реквизит2 <> Неопределено И НЕ Пустаястрока(Реквизит2) Тогда
		Возврат Реквизит2;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Создает и возвращает копию структуры Структура1
Функция СкопированнаяСтруктура(Структура1) Экспорт
	
	Структура2 = Новый Структура;
	
	Для Каждого Зап из Структура1 Цикл
		Структура2.Вставить(Зап.Ключ, Зап.Значение);
	КонецЦикла;
	
	Возврат Структура2;
	
КонецФункции

// Возвращает количество строк, соответствующих предписанным показателям 
// в указанном ТекстовомДокументе
Функция ПолучитьКоличествоПоказателей(Текст) Экспорт

	#Если Клиент Тогда
		Состояние("Определение количества выгруженных показателей ...");
	#КонецЕсли

	КоличествоПоказателей = 0;

	Для НомСтр = 1 По Текст.КоличествоСтрок() Цикл

		ТекСтр = СокрЛ(Текст.ПолучитьСтроку(Текст.КоличествоСтрок() - НомСтр + 1));

		Если Лев(ТекСтр, 11) = "КолПокФОтч:" Тогда
			Прервать;
		КонецЕсли;

		Если СтрДлина(ТекСтр)<14 Тогда
			Продолжить;
		КонецЕсли;

		Если (Сред(ТекСтр, 1, 1) = "П") и (Сред(ТекСтр, 14, 1) = ":") Тогда

			ЭтоПоказатель = Ложь;

			Для НСимв = 2 По 13 Цикл

				ТекСимв = Сред(ТекСтр, НСимв, 1);

				Если (ТекСимв = "0") или (ТекСимв = "1") ИЛИ (ТекСимв = "2") ИЛИ (ТекСимв = "3") ИЛИ (ТекСимв = "4")
					ИЛИ (ТекСимв = "5") ИЛИ (ТекСимв = "6") ИЛИ (ТекСимв = "7") ИЛИ (ТекСимв = "8") ИЛИ (ТекСимв = "9") Тогда

					ЭтоПоказатель = Истина;

				Иначе

					ЭтоПоказатель = Ложь;
					Прервать;

				КонецЕсли;

			КонецЦикла;

			Если ЭтоПоказатель Тогда
				КоличествоПоказателей = КоличествоПоказателей + 1;
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	#Если Клиент Тогда
		Состояние(Неопределено);
	#КонецЕсли

	Возврат Формат(КоличествоПоказателей, "ЧН=; ЧГ=0");

КонецФункции

//Находит строку в тексте с определением параметра КолПокФОтч
Функция НайтиКолПокФОтч(Текст) Экспорт

	Для Сч = 1 По Текст.Количествострок() Цикл

		ТекИнд = Текст.Количествострок() - Сч + 1;
		Если Лев(Текст.ПолучитьСтроку(ТекИнд), 11) = "КолПокФОтч:" Тогда
			Возврат ТекИнд;
		КонецЕсли;

	КонецЦикла;

	Возврат -1;

КонецФункции

// Преобразовывает исходную строку по формату представления реквизитов типа ФИО.
// Разделительные пробелы заменяет запятыми и преобразовывает символы в верхний
// регистр.
// 
// Возвращаемое значение:
//   строка, преобразованная по формату МНС.
//
Функция СтрЗаменитьПробелы(ИсхСтрока) Экспорт
	
	ПромСтр=СокрЛП(ИсхСтрока); 
	
	Если ПустаяСтрока(ПромСтр) Тогда
		ПромСтр = ",,";
		
		Возврат ПромСтр;
	КонецЕсли;

	// сначала удаляем возможный недопустимый символ '.'
	ЧП = СтрЧислоВхождений(ПромСтр,".");
	Если ЧП>0 Тогда
		Для К=1 По ЧП Цикл
			РезСтр=СтрЗаменить(ПромСтр,"."," ");
			ПромСтр=РезСтр;
		КонецЦикла; 
	КонецЕсли;
	
	// Число разделительных пробелов
	ЧП=СтрЧислоВхождений(ПромСтр," ");
	Если ЧП>0 Тогда
		Для К=1 По ЧП Цикл
			РезСтр  = СтрЗаменить(ПромСтр," ",",");
			ПромСтр = РезСтр;
		КонецЦикла; 
	КонецЕсли;
	
	// проверяем соответствие формату представления
	КолЗап = СтрЧислоВхождений(ПромСтр,",");
	Если КолЗап < 2 Тогда
		// дополняем недостающими запятыми
		Для Ном=(КолЗап+1) По 2 Цикл
			ПромСтр=ПромСтр+",";
		КонецЦикла;
	ИначеЕсли КолЗап > 2 Тогда
		Пока СтрЧислоВхождений(ПромСтр, ",") <> 2 Цикл
			НайденПовтор = 0;
			
			ПозицияЗапятой = Найти(ПромСтр, ",");
			Если Сред(ПромСтр, ПозицияЗапятой + 1, 1) = "," Тогда
				НачПозиция	 = ПозицияЗапятой;
				НайденПовтор = 1;
			Иначе
				ПозицияЗапятой2 = Найти(Сред(ПромСтр, ПозицияЗапятой + 1), ",");
				Если Сред(ПромСтр, ПозицияЗапятой + ПозицияЗапятой2 + 1, 1) = "," Тогда
					НачПозиция	 = ПозицияЗапятой + ПозицияЗапятой2;
					НайденПовтор = 1;
				КонецЕсли;
			КонецЕсли;	
			
			Если НайденПовтор = 1 Тогда
				ПромСтр = Лев(ПромСтр, НачПозиция) + Сред(ПромСтр, НачПозиция + 2);
			Иначе
				Если Прав(ПромСтр, 1) = "," Тогда
					// лишние хвостовые пробелы удаляем
					ПромСтр = Лев(ПромСтр, СтрДлина(ПромСтр) - 1);
				Иначе
					// лишние запятые заменяем пробелами
					ПромСтр = Лев(ПромСтр, ПозицияЗапятой - 1) + " " + Сред(ПромСтр, ПозицияЗапятой + 1); 
				КонецЕсли;
			КонецЕсли;
				
		КонецЦикла;
	КонецЕсли;
		
	Возврат ВРег(ПромСтр);         
	
КонецФункции // СтрЗаменитьПробелы()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УНИВЕРСАЛЬНОЙ ПЕЧАТИ
//

// Проверяет принадлежность строки табличного документа по номеру, указанному
// в параметре СледСтрока, группе строк ГруппаСтрок табличного документа  
Функция ЕстьСоответствующаяОбластьГруппСтрок(СледСтрока, ГруппыСтрок)
	Для Каждого ГруппаСтрок Из ГруппыСтрок Цикл
		Если ГруппаСтрок.Верх <= СледСтрока И ГруппаСтрок.Низ >= СледСтрока Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ЕстьСоответствующаяОбластьГруппСтрок()

// Возвращает максимальное количество строк многострочных частей,
// описываемых в структуре МногострочныеЧасти
Функция МаксимальноеКоличествоОбластейМногострочнойЧасти(МногострочныеЧасти)
	Максимум = 0;
	Для Каждого Эл Из МногострочныеЧасти Цикл
		Максимум = Макс(Максимум, Эл.Значение.Количество());
	КонецЦикла;
	Возврат Максимум;
КонецФункции // МаксимальноеКоличествоОбластейМногострочнойЧасти()

// Проверяет является ли описываемая в элементе списка значений
// ЭлСпКоорд строка частью одной из многострочных частей, описываемых в 
// структуре МногострочныеЧасти
Функция ЭтоОднаИзМногострочныхЧастей(ЭлСпКоорд, МногострочныеЧасти, ШагСтроки = 1)
	Коорд = ЭлСпКоорд.Значение;
	Для Каждого Эл Из МногострочныеЧасти Цикл
		Для Каждого ЭлСп Из Эл.Значение Цикл
			Если Число(ЭлСп.Представление) + ШагСтроки - 1 = Коорд Тогда
				Возврат Эл.Значение;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // МаксимальноеКоличествоОбластейМногострочнойЧасти()

// Разбивает табличный документ, соответствующий разделу с именем ИмяРаздела
// на части, ограниченные горизонтальным разделителем страниц, верхней или нижней границами
// табличного документа.
Функция ПолучитьКартуЛистовРаздела(Форма, ИмяРаздела)
	Карта = Новый ТаблицаЗначений;
	Карта.Колонки.Добавить("Верх");
	Карта.Колонки.Добавить("Низ");
	ТаблПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяРаздела];
	КолСтрок = ТаблПоле.ВысотаТаблицы;
	НачСтрока = 1;
	Для Сч = 1 По КолСтрок Цикл
		Если ТаблПоле.Область(Сч, 0, Сч, 0).КонецСтраницы Тогда
			НовСтр = Карта.Добавить();
			НовСтр.Верх = НачСтрока;
			НовСтр.Низ = Сч;
			НачСтрока = Сч + 1;
		КонецЕсли;
	КонецЦикла;
	Если (Карта.Количество() = 0) ИЛИ (Карта.Получить(Карта.Количество() - 1).Низ <> КолСтрок) Тогда
		НовСтр = Карта.Добавить();
		НовСтр.Верх = ?(Карта.Количество() = 1, 1, Карта.Получить(Карта.Количество() - 2).Низ + 1);
		НовСтр.Низ = КолСтрок;
	КонецЕсли;
	Возврат Карта;
КонецФункции // ПолучитьКартуЛистовРаздела()

#Если Клиент Тогда
	
// Возвращает координату нижней строки области с именем ИмяОбласти раздела с именем Раздел.
// Для областей, ограничивающих многострочные части раздела, возвращается координата
// нижней строки многострочной части.
Функция ПолучитьНизМногострочнойЧасти(Форма, Раздел, ИмяОбласти)
	ГруппыСтрок = ПолучитьКартуИменованныхГруппСтрок(Форма, Раздел);
	ТаблПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Раздел];
	Обл = ТаблПоле.ПолучитьОбласть(ИмяОбласти);
	Низ = ТаблПоле.Области.Найти(ИмяОбласти).Низ + 1;
	Пока Не ЕстьСоответствующаяОбластьГруппСтрок(Низ, ГруппыСтрок) Цикл
		Низ = Низ + 1;
	Конеццикла;
	Возврат Низ - 1;
КонецФункции //ПолучитьНизМногострочнойЧасти()

// Возвращает строки многострочной части в виде табличных документов
// Параметры:
// Форма - объект Форма из которого вызвана печать
// Раздел - имя печатаемого раздела
// ИмяОбласти - имя области многострочной части
Функция ПолучитьОбластиМногострочнойЧасти(Форма, Раздел, ИмяОбласти)
	
	ОбластиМногострочнойЧасти = Новый СписокЗначений;
	Если ИмяОбласти = Неопределено Тогда
		Возврат ОбластиМногострочнойЧасти;
	КонецЕсли;
	ГруппыСтрок = ПолучитьКартуИменованныхГруппСтрок(Форма, Раздел);
	ТаблПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Раздел];
	Обл = ТаблПоле.ПолучитьОбласть(ИмяОбласти);
	
	Шаг = ПолучитьШагСтрокиДляТабличногоПоля(Обл);
	
	Для Сч = 1 По Обл.ВысотаТаблицы / Шаг Цикл
		ОблВрем = Обл.ПолучитьОбласть((Сч - 1) * Шаг + 1, 0, Сч * Шаг, 0);
		ОбластиМногострочнойЧасти.Добавить(ОблВрем, ТаблПоле.Области.Найти(ИмяОбласти).Верх + (Сч - 1) * Шаг);
	КонецЦикла;
	СледСтрока = ТаблПоле.Области.Найти(ИмяОбласти).Низ + 1;
	Пока Не ЕстьСоответствующаяОбластьГруппСтрок(СледСтрока, ГруппыСтрок) Цикл
		ОблВрем = ТаблПоле.ПолучитьОбласть(СледСтрока,0,СледСтрока + Шаг - 1,0);
		ОбластиМногострочнойЧасти.Добавить(ОблВрем, СледСтрока);
		СледСтрока = СледСтрока + Шаг;
	Конеццикла;
	Возврат ОбластиМногострочнойЧасти;
	
КонецФункции // ПолучитьОбластиМногострочнойЧасти()

// Возвращает массив имен многострочных частей табличного поля с именем ИмяТабличногоПоля.
// Поиск многострочных частей в табличном поле ограничивается верхней и нижней координатами - 
// Верх и Низ соответственно.
Функция	ПолучитьКартуМногострочныхСекцийЛиста(Форма, ИмяТабличногоПоля, Верх, Низ)
	ТаблДок = Форма.ЭлементыФормы[ИмяТабличногоПоля];
	МассивМногострочныхЧастей = Новый Массив;
	Для Каждого Обл Из ТаблДок.Области Цикл
		Если Обл.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки И Обл.Верх >= Верх И Обл.Низ <= Низ И Найти(ВРЕГ(Обл.Имя), "МНОГОСТРОЧНАЯЧАСТЬ") <> 0 Тогда
			МассивМногострочныхЧастей.Добавить(Обл.Имя);
		КонецЕсли;
	КонецЦикла;
	Если МассивМногострочныхЧастей.Количество() = 0 Тогда
		Возврат Неопределено;
	Иначе
		Возврат МассивМногострочныхЧастей;
	КонецЕсли;
КонецФункции // ПолучитьКартуМногострочныхСекцийЛиста()

// Возвращает количество готовых к выводу на печать листов формата A4 для 
// раздела с именем ИмяЛиста. Сфомированные листы хранятся в списке значений мПечатныеФормы
Функция КоличествоЛистовПоИмениЛиста(мПечатныеФормы, ИмяЛиста)
	КоличествоВхождений = 0;
	Для Каждого ЭлСп Из мПечатныеФормы Цикл
		Если ЭлСп.Представление = ИмяЛиста Тогда
			КоличествоВхождений = КоличествоВхождений + 1;
		КонецЕсли;
	КонецЦикла;
	Возврат КоличествоВхождений;
КонецФункции

// Формирует готовый к выводу на печать лист формата A4. Лист - это область табличного документа,
// ограниченная снизу и сверху горизонтальными разделителями страниц или границами
// табличного документа.
// Параметры:
// Форма - форма отчета, из которой вызывается печать
// СтруктураПараметровЛиста - структура, содержащая параметры исходного листа
Процедура ВывестиНаПечатьЛистОбщая(Форма, СтруктураПараметровЛиста) Экспорт
	Перем ИмяЛиста;           // имя выводимого на печать листа;
	Перем Ориентация;         // ориентация страницы;
	Перем ИмяТабличногоПоля;  // имя табличного поля, который выводится на печать;
	Перем ИмяОбластиТаблПоля; // имя области дабличного документа, выводимой на печать;
	Перем ВидПечати;          // строка, задающая способ печати
	Перем ИмяОбластиМногострочнойЧасти;
	
	СтруктураПараметровЛиста.Свойство("НаименованиеЛиста",  ИмяЛиста);
	СтруктураПараметровЛиста.Свойство("ОриентацияЛиста",    Ориентация);
	СтруктураПараметровЛиста.Свойство("ИмяТабличногоПоля",  ИмяТабличногоПоля);
	СтруктураПараметровЛиста.Свойство("ИмяОбластиТаблПоля", ИмяОбластиТаблПоля);
	СтруктураПараметровЛиста.Свойство("ВидПечати",          ВидПечати);
	
	СтруктураПараметровЛиста.Вставить("ВидПечати", "Пакетная печать");	

	ИмяРаздела = Сред(ИмяТабличногоПоля, 24);
	СтруктураПараметровЛиста.Вставить("ИмяРаздела", ИмяРаздела);	
	
	КартаСтраницРаздела = ПолучитьКартуЛистовРаздела(Форма, ИмяРаздела);
	НомЛиста = 0;
	
	Для Каждого Стр Из КартаСтраницРаздела Цикл
		
		НомЛиста = НомЛиста + 1;
		СтруктураПараметровЛиста.Вставить("Верх", Стр.Верх);
		СтруктураПараметровЛиста.Вставить("Низ", Стр.Низ);
		
		МассивМногострочныхЧастей = Неопределено;
		
		Состояние(Форма.Заголовок + ". Формирование печатной формы " + ИмяЛиста + ". Лист №" + (КоличествоЛистовПоИмениЛиста(Форма.мПечатныеФормы, ИмяЛиста) + 1));
		
		СтруктураПараметровЛиста.Вставить("МногострочнаяЧасть", ПолучитьКартуМногострочныхСекцийЛиста(Форма, ИмяТабличногоПоля, Стр.Верх, Стр.Низ));
			
		ПечатныеЛисты = ВывестиНаПечатьЛистРаздела(Форма, СтруктураПараметровЛиста);
		
		Для Каждого Эл Из ПечатныеЛисты Цикл
			Форма.мПечатныеФормы.Добавить(Эл, ИмяЛиста);
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ВывестиНаПечатьЛистОбщая()

// Пытается проставить номер страницы НомерЛиста в соответствующие ячейки табличного документа ТаблДок.
// Возвращает Истина, если удалось проставить номер. В противном случае возвращает Ложь.
Функция УдалосьПроставитьНомерСтраницы(ТаблДок,Знач НомерЛиста)
	
	ОбластиСНомерамиЛистов = Новый СписокЗначений;
	Для Каждого Обл Из ТаблДок.Значение.Области Цикл
		Если Обл.ТипОбласти <> ТипОбластиЯчеекТабличногоДокумента.Прямоугольник ИЛИ Обл.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;
		КрайнийПравыйСимвол = Прав(Обл.Имя, 1);
		Если Лев(ВРЕГ(Обл.Имя), 6) = "НОМСТР" И (КодСимвола(КрайнийПравыйСимвол) >= КодСимвола("0") И КодСимвола(КрайнийПравыйСимвол) <= КодСимвола("9"))Тогда
			ОбластиСНомерамиЛистов.Добавить(Обл, Обл.Имя);
		КонецЕсли;
		ОбластиСНомерамиЛистов.СортироватьПоПредставлению(НаправлениеСортировки.Убыв);
	КонецЦикла;
	
	Цифры = Новый Массив;
	Для Инд = 1 По 9 Цикл
		Цифра = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
		НомерЛиста = Цел(НомерЛиста / 10);
		Если ПустаяСтрока(Цифра) Тогда
			Прервать;
		Иначе
			Цифры.Добавить(Цифра);
		КонецЕсли;
	КонецЦикла;
	
	Для Инд = 0 По ОбластиСНомерамиЛистов.Количество() - 1 Цикл
		ОбластиСНомерамиЛистов.Получить(Инд).Значение.Значение = Формат(?(Цифры.Количество() > Инд, Цифры[Инд], 0), "ЧЦ=1; ЧН=0; ЧГ=");
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // УдалосьПроставитьНомерСтраницы()

// Проставляет номера листов на каждом листе и общее количество листов на титульном;
// после нумерации выводит листыв в общую форму ПечатьРегламентированныхОтчетов.
// Параметры:
// Форма - объект типа Форма, из которого была вызвана печать.
// ВидПечати - строка, задающая действие, которое следует произвести с печатными формами: 
// непосредственная печать или предварительный просмотр.
// ПризнакНумеруемыхФорм - данный параметр следует установить в Ложь для тех
// печатных форм, в которых не предусмотрены области для нумерации листов и 
// указания общего количества листов (например, форма 4ФСС и т.п.).
Процедура ПроставитьНомераЛистов(Форма, ВидПечати, ПризнакНумеруемыхФорм = Истина) Экспорт;
	
	Если ПризнакНумеруемыхФорм Тогда
		Если Форма.мСчетчикСтраниц <> Истина Тогда
			НомерЛиста = 1;
			Для Каждого Эл Из Форма.мПечатныеФормы Цикл
				Если НЕ УдалосьПроставитьНомерСтраницы(Эл.Значение, НомерЛиста) Тогда
					Сообщить("Не удалось проставить номер страницы для " + Эл.Представление);
					Продолжить;
				КонецЕсли;
				НомерЛиста = НомерЛиста + 1;
			КонецЦикла;
			Если Форма.мПечатныеФормы.Количество() <> 0 Тогда
				ТаблДок = Форма.мПечатныеФормы.Получить(0).Значение.Значение;
				ЦифрВОбщемКоличествеЛистов = 0;
				Для ОбратныйИндекс = 1 По 9 Цикл
					Индекс = 10 - ОбратныйИндекс;
					Если ТаблДок.Области.Найти("СоставленаНа" + Индекс) <> Неопределено Тогда
						ЦифрВОбщемКоличествеЛистов = Индекс;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=" + ЦифрВОбщемКоличествеЛистов + "; ЧН=0; ЧВН=; ЧГ=");
				Для Инд = 1 По ЦифрВОбщемКоличествеЛистов Цикл
					ТекИнд = ЦифрВОбщемКоличествеЛистов - Инд + 1;
					Попытка
						ТаблДок.Области["СоставленаНа" + ТекИнд].Значение = Сред(ВсегоЛистов, ТекИнд, 1);
					Исключение
					КонецПопытки;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	НомераЛистов = Новый СписокЗначений;
	ИдентификаторФормы = ?(Форма.ВладелецФормы = Неопределено, Форма, Форма.ВладелецФормы);
	
	ПредПросмотр = роПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", ИдентификаторФормы);
	Если Форма.ВладелецФормы = Неопределено И ПредПросмотр.Открыта() Тогда
		ПредПросмотр.Закрыть();
		ПредПросмотр = роПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", Форма);
	КонецЕсли;
	ПредПросмотр.ЗакрыватьПриЗакрытииВладельца = Ложь;
	НомерЛиста = 1;
	ПредПросмотр.СписокПечатаемыхЛистов.Очистить();
	Для Каждого Эл Из Форма.мПечатныеФормы Цикл
		НовСтр = ПредПросмотр.СписокПечатаемыхЛистов.Добавить();
		НомЛиста = НомераЛистов.НайтиПоЗначению(Эл.Представление);
		Если НомЛиста = Неопределено Тогда
			НомЛиста = НомераЛистов.Добавить(Эл.Представление, "1");
			НЛиста = 1;
		Иначе
			НЛиста = Число(НомЛиста.Представление) + 1;
			НомЛиста.Представление = Строка(Число(НомЛиста.Представление) + 1);
		КонецЕсли;
		НовСтр.Наименование = Эл.Представление + ". Лист №" + НЛиста;
		Если ТипЗнч(Эл.Значение) <> Тип("ТабличныйДокумент") Тогда
			НовСтр.ТабличныйДокумент = Эл.Значение.Значение;
		Иначе
			НовСтр.ТабличныйДокумент = Эл.Значение;
		КонецЕсли;
		НовСтр.Идентификатор = Форма;
		НомерЛиста = НомерЛиста + 1;
	КонецЦикла;
	ПредПросмотр.ВидПечати = ВидПечати;
	ПредПросмотр.Открыть();
	
КонецПроцедуры // ПроставитьНомераЛистов()

// Для раздела с именем Раздел формирует таблицу значений, в которой перечисляются
// имена и вертикальные координаты областей - групп строк табличного документа, соответствующего
// данному разделу.
Функция ПолучитьКартуИменованныхГруппСтрок(Форма, Раздел)
	Карта = Новый ТаблицаЗначений;
	Карта.Колонки.Добавить("Верх");
	Карта.Колонки.Добавить("Низ");
	ТаблПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Раздел];
	Для Каждого Обл Из ТаблПоле.Области Цикл
		Если Обл.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки Тогда
			НовСтр = Карта.Добавить();
			НовСтр.Верх = Обл.Верх;
			НовСтр.Низ = Обл.Низ;
		КонецЕсли;
	КонецЦикла;
	Возврат Карта;
КонецФункции //ПолучитьКартуИменованныхГруппСтрок()

// Для заданной по номеру НомСтр строки многострочной части, описываемой в элементе 
// списка значений МногострочныеЧасти, формирует и возвращает табличный документ,
// в котором очищены ячейки, содержащие значения и не защищенные от изменения пользователем.
Функция ПолучитьПустуюСтрокуМногострочнойЧасти(МногострочныеЧасти, НомСтр)
	ПерваяСтрока = МногострочныеЧасти.Значение.Получить(НомСтр).Значение;
	ИтоговыйТабличныйДокумент = Новый ТабличныйДокумент;
	ИтоговыйТабличныйДокумент.Вывести(ПерваяСтрока);
	Для Каждого Область Из ИтоговыйТабличныйДокумент.Области Цикл
		Если Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник И Область.СодержитЗначение Тогда //И НЕ Область.Защита Тогда
			Область.Значение = Неопределено;
		КонецЕсли;
	КонецЦикла;
	Возврат ИтоговыйТабличныйДокумент;
КонецФункции // ПолучитьПустуюСтрокуМногострочнойЧасти()

// Возвращает печатную форму (лист формата A4) листа раздела, не содержащего многострочные части.
// Параметры исходного листа задаются в структуре СтруктураПараметровЛиста.
Функция ВывестиНаПечатьЛистРазделаБезМногострочныхЧастей(Форма, СтруктураПараметровЛиста)
	Перем ИмяЛиста;           // имя выводимого на печать листа;
	Перем Ориентация;         // ориентация страницы;
	Перем ИмяТабличногоПоля;  // имя табличного поля, который выводится на печать;
	Перем ИмяОбластиТаблПоля; // имя области дабличного документа, выводимой на печать;
	Перем ВидПечати;          // строка, задающая способ печати
	Перем Верх;
	Перем Низ;

	СтруктураПараметровЛиста.Свойство("НаименованиеЛиста",  ИмяЛиста);
	СтруктураПараметровЛиста.Свойство("ОриентацияЛиста",    Ориентация);
	СтруктураПараметровЛиста.Свойство("ИмяТабличногоПоля",  ИмяТабличногоПоля);
	СтруктураПараметровЛиста.Свойство("ИмяОбластиТаблПоля", ИмяОбластиТаблПоля);
	СтруктураПараметровЛиста.Свойство("ВидПечати",          ВидПечати);
	СтруктураПараметровЛиста.Свойство("Верх",               Верх);
	СтруктураПараметровЛиста.Свойство("Низ",                Низ);

	ПечатнаяФорма = Новый ТабличныйДокумент();
	
	ПечатнаяФорма.ОтображатьЗаголовки = Ложь;
	ПечатнаяФорма.ОтображатьСетку     = Ложь;
	ПечатнаяФорма.ЧерноБелыйПросмотр  = Истина;
	ПечатнаяФорма.ЧерноБелаяПечать    = Истина;
	ПечатнаяФорма.Автомасштаб         = Истина;
	ПечатнаяФорма.ОриентацияСтраницы  = Ориентация;
	
	ТабличноеПоле = Форма.ЭлементыФормы[ИмяТабличногоПоля];

	// Создаем список выводимых на печать областей таблицы.
	СписокВыводимыхНаПечатьОбластей = Новый СписокЗначений();
	
	// Перебираем все области таблицы и добавляем в список 
	// только те области, которые являются секциями таблицы.
	Для каждого Область Из ТабличноеПоле.Области Цикл
		
		Если Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки Тогда
			// Добавляем в список имя области и ее верхнюю координату.
			Если Область.Верх < Верх ИЛИ Область.Низ > Низ Тогда
				Продолжить;
			КонецЕсли;
			
			СписокВыводимыхНаПечатьОбластей.Добавить(Область.Верх, Область.Имя);
		КонецЕсли;
		
	КонецЦикла;
	
	// Сортируем список в порядке расположения областей в таблице (по верхней координате).
	СписокВыводимыхНаПечатьОбластей.СортироватьПоЗначению();

	// Выполняем цикл до тех пор, пока не закончатся области, выводимые на печать.
	Пока СписокВыводимыхНаПечатьОбластей.Количество() > 0 Цикл
		
		// В том случае, если в имени области не встречается строка "ПустаяСтрока", то
		// выводим область в результирующую таблицу и удаляем из списка.
		Если СтрЧислоВхождений(ВРег(СписокВыводимыхНаПечатьОбластей[0].Представление), ВРег("ПустаяСтрока")) = 0 Тогда
			
			ОбластьВыводимаяНаПечать = ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей[0].Представление);
			СписокВыводимыхНаПечатьОбластей.Удалить(0);
			
			ПечатнаяФорма.Вывести(ОбластьВыводимаяНаПечать);
			Продолжить;
			
		КонецЕсли;
		
		// Получаем области "ПустаяСтрока" и "Ограничители", одновременно удаляя их из списка.
		ОбластьПустаяСтрока = ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей[0].Представление);
		СписокВыводимыхНаПечатьОбластей.Удалить(0);
		ОбластьОграничители = ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей[0].Представление);
		СписокВыводимыхНаПечатьОбластей.Удалить(0);
		
		// Создаем массив выводимых областей.
		ВыводимыеОбласти = Новый Массив();
		
		// Добавляем в массив выводимые области таблицы для того, 
		// чтобы проверить: поместятся ли они на текущий лист.
		ВыводимыеОбласти.Добавить(ОбластьПустаяСтрока);
		ВыводимыеОбласти.Добавить(ОбластьОграничители);
		
		// Проверяем вывод области "Ограничители".
		флОбластьОграничителиУмещаетсяНаСтраницу = ПечатнаяФорма.ПроверитьВывод(ОбластьОграничители);
		
		Пока флОбластьОграничителиУмещаетсяНаСтраницу Цикл
			
			// Проверяем вывод областей "ПустаяСтрока" и "Ограничители".
			флВыводимыеОбластиУмещаютсяНаСтраницу = ПечатнаяФорма.ПроверитьВывод(ВыводимыеОбласти);
			
			Если флВыводимыеОбластиУмещаютсяНаСтраницу Тогда
				ПечатнаяФорма.Вывести(ОбластьПустаяСтрока);
			Иначе
				ПечатнаяФорма.Вывести(ОбластьОграничители);
				ПечатнаяФорма.ВывестиГоризонтальныйРазделительСтраниц();
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
			
	КонецЦикла;		
	
	Если ВидПечати = "ПоказатьБланк" Тогда
		ПечатнаяФорма.Показать(СокрП(Форма.Заголовок) + " (" + СокрП(ИмяЛиста) + ")");
	ИначеЕсли ВидПечати = "ПечататьСразу" Тогда
		ПечатнаяФорма.Напечатать();
	КонецЕсли;
	
	Возврат ПечатнаяФорма;
	
КонецФункции // ВывестиНаПечатьЛистРазделаБезМногострочныхЧастей()

Процедура ОбнулитьИтоговыеПоказателиНаТекущемЛисте(ТаблДок)
	
	Для НомерИтоговыхПоказателей = 0 По 10 Цикл
		ОбластьИтоговыеПоказатели = ТаблДок.Области.Найти("ИтоговыеПоказатели" + Формат(НомерИтоговыхПоказателей, ""));
		Если ОбластьИтоговыеПоказатели <> Неопределено Тогда
			Для Стр = ОбластьИтоговыеПоказатели.Верх По ОбластьИтоговыеПоказатели.Низ Цикл
				Для Кол = ОбластьИтоговыеПоказатели.Лево По ОбластьИтоговыеПоказатели.Право Цикл
					ТекОбл = ТаблДок.Область(Стр, Кол, Стр, Кол);
					Если ТекОбл.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник И ТекОбл.СодержитЗначение = Истина Тогда
						ТекОбл.Значение = Неопределено;
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает список значений, содержащий печатные формы - листы формата A4, готовые к выводу на печать.
// Листы формируются на основании исходного табличного документа, параметры которого и другие настройки
// печати хранятся в структуре СтруктураПараметровЛиста.
// Процедура рассчитана на печать разделов, содержащих одну или несколько многострочных частей.
Функция ВывестиНаПечатьЛистРаздела(Форма, СтруктураПараметровЛиста)
	Перем ИмяЛиста;           // имя выводимого на печать листа;
	Перем Ориентация;         // ориентация страницы;
	Перем ИмяТабличногоПоля;  // имя табличного поля, который выводится на печать;
	Перем ИмяОбластиТаблПоля; // имя области дабличного документа, выводимой на печать;
	Перем ВидПечати;          // строка, задающая способ печати
	Перем ИмяОбластиМногострочнойЧасти;
	Перем ИмяРаздела;
	Перем МногострочныеЧасти;
	Перем Верх;
	Перем Низ;
	
	СписокПечатныхФорм = Новый СписокЗначений;
	
	СтруктураПараметровЛиста.Свойство("НаименованиеЛиста",  ИмяЛиста);
	СтруктураПараметровЛиста.Свойство("ОриентацияЛиста",    Ориентация);
	СтруктураПараметровЛиста.Свойство("ИмяТабличногоПоля",  ИмяТабличногоПоля);
	СтруктураПараметровЛиста.Свойство("ИмяОбластиТаблПоля", ИмяОбластиТаблПоля);
	СтруктураПараметровЛиста.Свойство("ВидПечати",          ВидПечати);
	СтруктураПараметровЛиста.Свойство("ИмяРаздела",         ИмяРаздела);
	СтруктураПараметровЛиста.Свойство("МногострочнаяЧасть", ИмяОбластиМногострочнойЧасти);
	СтруктураПараметровЛиста.Свойство("Верх",               Верх);
	СтруктураПараметровЛиста.Свойство("Низ",                Низ);
	
	Если ИмяОбластиМногострочнойЧасти = Неопределено Тогда
		СписокПечатныхФорм.Добавить(ВывестиНаПечатьЛистРазделаБезМногострочныхЧастей(Форма, СтруктураПараметровЛиста));
		Возврат СписокПечатныхФорм;
	КонецЕсли;
	
	//Если ИмяОбластиМногострочнойЧасти.Количество() = 1 Тогда
	//	СписокПечФорм = ВывестиНаПечатьЛистРазделаСОднойМногострочнойЧастью(Форма, СтруктураПараметровЛиста);
	//	Для Каждого Эл Из СписокПечФорм Цикл
	//		СписокПечатныхФорм.Добавить(Эл.Значение);
	//	КонецЦикла;
	//	Возврат СписокПечатныхФорм;
	//КонецЕсли;
	
	//ИмяЛиста = "";
	//Ориентация = ОриентацияСтраницы.Ландшафт;
	ИмяТабличногоПоля = "ПолеТабличногоДокумента" + ИмяРаздела;
	
	ТабличноеПоле = Форма.ЭлементыФормы[ИмяТабличногоПоля];

    // Создаем список выводимых на печать областей таблицы.
	СписокВыводимыхНаПечатьОбластей = Новый СписокЗначений();
	
	// Перебираем все области таблицы и добавляем в список 
	// только те области, которые являются секциями таблицы.
	Для Каждого Область Из ТабличноеПоле.Области Цикл
		
		Если Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки Тогда
			
			Если Область.Верх < Верх ИЛИ Область.Низ > Низ Тогда
				Продолжить;
			КонецЕсли;
			
			Если Найти(ВРЕГ(Область.Имя), "МНОГОСТРОЧНАЯЧАСТЬ") <> 0 Тогда
				СписокВыводимыхНаПечатьОбластей.Добавить(ПолучитьНизМногоСтрочнойЧасти(Форма, ИмяРаздела, Область.Имя), Область.Имя);
			Иначе
				СписокВыводимыхНаПечатьОбластей.Добавить(Область.Низ, Область.Имя);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	МногострочныеЧасти = Новый Структура;
	Если ТипЗнч(ИмяОбластиМногострочнойЧасти) = Тип("Строка") Тогда
		МногострочныеЧасти.Вставить(ИмяОбластиМногострочнойЧасти, ПолучитьОбластиМногоСтрочнойЧасти(Форма, ИмяРаздела, ИмяОбластиМногострочнойЧасти));
	Иначе
		Для Каждого Эл Из ИмяОбластиМногострочнойЧасти Цикл
			МногострочныеЧасти.Вставить(Эл, ПолучитьОбластиМногоСтрочнойЧасти(Форма, ИмяРаздела, Эл));
		КонецЦикла;
	КонецЕсли;
	
	// Сортируем список в порядке расположения областей в таблице (по верхней координате).
	СписокВыводимыхНаПечатьОбластей.СортироватьПоЗначению();
	флПрервать = Ложь;
	КоличествоСтрок = 0;
	
	Строки = Новый Массив;
	
	ПустойТабличныйДокумент = Новый ТабличныйДокумент;
	
	ПустыеСтрокиМногострочныхЧастей = Новый Массив(МногострочныеЧасти.Количество());
	НомСтр = 0;
	Для Каждого Эл Из МногострочныеЧасти Цикл
		ПустыеСтрокиМногострочныхЧастей[НомСтр] = ПолучитьПустуюСтрокуМногострочнойЧасти(Эл, 0);
		НомСтр = НомСтр + 1;
	КонецЦикла;
	
	//ОчиститьМногострочныеЧастиОтПустыхСтрок(МногострочныеЧасти);
	
	НомСтр = 0;
	Для Каждого Эл Из МногострочныеЧасти Цикл
		Если Эл.Значение.Количество() = 0 Тогда
			Эл.Значение.Добавить(ПустыеСтрокиМногострочныхЧастей[НомСтр], "-1");
		КонецЕсли;
		НомСтр = НомСтр + 1;
	КонецЦикла;
	
	Пока МаксимальноеКоличествоОбластейМногострочнойЧасти(МногострочныеЧасти) > 0 Цикл
		
		//ПечатнаяФорма.Очистить();
		ПечатнаяФорма = Новый ТабличныйДокумент();
		
		ПечатнаяФорма.ОтображатьЗаголовки = Ложь;
		ПечатнаяФорма.ОтображатьСетку     = Ложь;
		ПечатнаяФорма.ЧерноБелыйПросмотр  = Истина;
		ПечатнаяФорма.ЧерноБелаяПечать    = Истина;
		ПечатнаяФорма.Автомасштаб         = Истина;
		ПечатнаяФорма.ОриентацияСтраницы  = Ориентация;
		
		НомСтр = 0;
		Для Каждого Эл Из МногострочныеЧасти Цикл
			Если Эл.Значение.Количество() = 0 Тогда
				Эл.Значение.Добавить(ПустыеСтрокиМногострочныхЧастей[НомСтр], "-1");
			КонецЕсли;
			НомСтр = НомСтр + 1;
		КонецЦикла;
		
		Для Сч = 0 По СписокВыводимыхНаПечатьОбластей.Количество() - 1 Цикл
			ОбластьВыводимаяНаПечать = ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление);
			Если Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "ОГРАНИЧИТЕЛИ") <> 0 Тогда
				ОбластьОграничители = ОбластьВыводимаяНаПечать;
				Продолжить;
			КонецЕсли;
			Если Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "ПУСТАЯСТРОКА") <> 0 Тогда
				ОбластьПустаяСтрока = ОбластьВыводимаяНаПечать;
				Продолжить;
			КонецЕсли;                                                                                   
			Если МногострочныеЧасти.Свойство(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление) Тогда
				Продолжить;
			КонецЕсли;
			ПечатнаяФорма.Вывести(ОбластьВыводимаяНаПечать);
		КонецЦикла;
		
		Строки.Очистить();
		Инд = 0;
		Для Каждого Эл Из МногострочныеЧасти Цикл
			Попытка
				Строки.Добавить(Эл.Значение.Получить(0).Значение);
			Исключение
				Строки.Добавить(ПустыеСтрокиМногострочныхЧастей[Инд]);
			КонецПопытки;
			Инд = Инд + 1;
		КонецЦикла;
		Строки.Добавить(ОбластьПустаяСтрока);
		Строки.Добавить(ОбластьОграничители);
		
		Ном = 1;
		Пока ПечатнаяФорма.ПроверитьВывод(Строки) Цикл
			Ном = Ном + 1;
			НомерЭлементаТабличнойЧасти = 0;
			Для Каждого Эл Из МногострочныеЧасти Цикл
				Если Эл.Значение.Количество() > 0 Тогда
					ПечатнаяФорма.Вывести(Строки[НомерЭлементаТабличнойЧасти]);				
					НомерЭлементаТабличнойЧасти = НомерЭлементаТабличнойЧасти + 1;
				КонецЕсли;
			КонецЦикла;

			Если МаксимальноеКоличествоОбластейМногострочнойЧасти(МногострочныеЧасти) >= Ном Тогда
				НомерМнЧ = 0;
				Для Каждого Эл Из МногострочныеЧасти Цикл
					Попытка
						Строки[НомерМнЧ] = Эл.Значение.Получить(Ном - 1).Значение;
					Исключение
						Строки[НомерМнЧ] = ПустойТабличныйДокумент;//?(Ном = 1, ПустыеСтрокиМногострочныхЧастей[НомерМнЧ], ПустойТабличныйДокумент);
					КонецПопытки;
					НомерМнЧ = НомерМнЧ + 1;
				КонецЦикла;
			Иначе
				Прервать;
			КонецЕсли;
		КонецЦикла;
				
		КоличествоВыводимыхСтрок = Ном - 1;
		//Защита против частей разделов, которые не помещаются на лист, если даже
		//выводить по одной строке из каждой многострочной части.
		Если КоличествоВыводимыхСтрок = 0 Тогда
			КоличествоВыводимыхСтрок = 1;
		КонецЕсли;
		
		ИтоговыйТаблДок = Новый ТабличныйДокумент;
		ИтоговыйТаблДок.ОтображатьЗаголовки = Ложь;
		ИтоговыйТаблДок.ОтображатьСетку     = Ложь;
		ИтоговыйТаблДок.ЧерноБелыйПросмотр  = Истина;
		ИтоговыйТаблДок.ЧерноБелаяПечать    = Истина;
		ИтоговыйТаблДок.Автомасштаб         = Истина;
		ИтоговыйТаблДок.ОриентацияСтраницы  = Ориентация;
		
		НомерМногострочнойЧасти = -1;
		
		Для Сч = 0 По СписокВыводимыхНаПечатьОбластей.Количество() - 1 Цикл
			ОбластьВыводимаяНаПечать = ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление);
			Если Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "ОГРАНИЧИТЕЛИ") <> 0 
				  ИЛИ Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "ПУСТАЯСТРОКА") <> 0 Тогда
				Продолжить;
			КонецЕсли;
			Рез = ЭтоОднаИзМногострочныхЧастей(СписокВыводимыхНаПечатьОбластей.Получить(Сч), МногострочныеЧасти, ПолучитьШагСтрокиДляТабличногоПоля(ТабличноеПоле.ПолучитьОбласть(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление)));
			//Если Рез = Ложь И Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "МНОГОСТРОЧНАЯЧАСТЬ") <> 0 Тогда
			//	Продолжить
			//КонецЕсли;
			Если Рез <> Ложь ИЛИ Найти(ВРЕГ(СписокВыводимыхНаПечатьОбластей.Получить(Сч).Представление), "МНОГОСТРОЧНАЯЧАСТЬ") <> 0 Тогда
				НомерМногострочнойЧасти = НомерМногострочнойЧасти + 1;
				ТаблЧастьВыведена = Истина;
				Если Рез = Ложь Тогда
					НомМнЧ = -1;
					Для Каждого ЭлСтр Из МногострочныеЧасти Цикл
						НомМнЧ = НомМнЧ + 1;
						Если НомМнЧ = НомерМногострочнойЧасти Тогда
							ИтоговыйТаблДок.Вывести(ЭлСтр.Значение.Получить(0).Значение);
							ЭлСтр.Значение.Удалить(0);
							Прервать;
						КонецЕсли;
					КонецЦикла;
				Иначе
					Для Инд = 0 По КоличествоВыводимыхСтрок - 1 Цикл
						Если Рез.Количество() >= Инд + 1 Тогда
							ИтоговыйТаблДок.Вывести(Рез.Получить(Инд).Значение);
						КонецЕсли;
					КонецЦикла;
					Для Инд = 0 По КоличествоВыводимыхСтрок - 1 Цикл
						Если Рез.Количество() > 0 Тогда
							Рез.Удалить(0);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			ИтоговыйТаблДок.Вывести(ОбластьВыводимаяНаПечать);				
		КонецЦикла;
		
		ВыводимыеОбласти = Новый Массив;
		ВыводимыеОбласти.Добавить(ОбластьОграничители);
		//ВыводимыеОбласти.Добавить(ОбластьПустаяСтрока);
		
		// Проверяем вывод области "Ограничители".
		флОбластьОграничителиУмещаетсяНаСтраницу = ИтоговыйТаблДок.ПроверитьВывод(ВыводимыеОбласти);
		
		// Поиск "Правого присоединения" - секции с ИНН, КПП, номером страницы, находящейся справа
		ТаблПоле = ТабличноеПоле.ПолучитьОбласть(Верх, , Низ, );
		ПравоеПрисоединение = Неопределено;
		Для НомерПравогоПрисоединения = 0 По 10 Цикл
			ПравоеПрисоединение = ТаблПоле.Области.Найти("ПравоеПрисоединение" + Формат(НомерПравогоПрисоединения, ""));
			Если ПравоеПрисоединение <> Неопределено Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если флОбластьОграничителиУмещаетсяНаСтраницу Тогда
			
			ВыводимыеОбласти.Добавить(ОбластьПустаяСтрока);
			
			Пока флОбластьОграничителиУмещаетсяНаСтраницу Цикл
				
				// Проверяем вывод областей "ПустаяСтрока" и "Ограничители".
				флВыводимыеОбластиУмещаютсяНаСтраницу = ИтоговыйТаблДок.ПроверитьВывод(ВыводимыеОбласти);
				
				Если флВыводимыеОбластиУмещаютсяНаСтраницу Тогда
					ИтоговыйТаблДок.Вывести(ОбластьПустаяСтрока);
				Иначе
					ИтоговыйТаблДок.Вывести(ОбластьОграничители);
					Если ПравоеПрисоединение <> Неопределено Тогда
						ИтоговыйТаблДок.ВставитьОбласть(ПравоеПрисоединение, ИтоговыйТаблДок.Область(ПравоеПрисоединение.Верх, ПравоеПрисоединение.Лево, ПравоеПрисоединение.Низ, ПравоеПрисоединение.Право));
						//ИтоговыйТаблДок.ВставитьОбласть(ПравоеПрисоединение, ИтоговыйТаблДок.Область(ПравоеПрисоединение.Верх, ПравоеПрисоединение.Лево, ПравоеПрисоединение.Низ, ПравоеПрисоединение.Право));
					КонецЕсли;
					ИтоговыйТаблДок.ВывестиГоризонтальныйРазделительСтраниц();
					
					Если МаксимальноеКоличествоОбластейМногострочнойЧасти(МногострочныеЧасти) > 0 Тогда
						ОбнулитьИтоговыеПоказателиНаТекущемЛисте(ИтоговыйТаблДок);
					КонецЕсли;
					
					Если ВидПечати = "ПоказатьБланк" Тогда
						ИтоговыйТаблДок.Показать(СокрП(Форма.Заголовок) + " (" + СокрП(ИмяЛиста) + ")");
					ИначеЕсли ВидПечати = "ПечататьСразу" Тогда
						ИтоговыйТаблДок.Напечатать();
					Иначе
						СписокПечатныхФорм.Добавить(ИтоговыйТаблДок);
					КонецЕсли;
					
					//ИтоговыйТаблДок.Показать(СокрП(Заголовок) + " (" + СокрП(ИмяЛиста) + ")");
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			ИтоговыйТаблДок.Вывести(ОбластьОграничители);
			Если ПравоеПрисоединение <> Неопределено Тогда
				ИтоговыйТаблДок.ВставитьОбласть(ПравоеПрисоединение, ИтоговыйТаблДок.Область(ПравоеПрисоединение.Верх, ПравоеПрисоединение.Лево, ПравоеПрисоединение.Низ, ПравоеПрисоединение.Право));
			КонецЕсли;
			ИтоговыйТаблДок.ВывестиГоризонтальныйРазделительСтраниц();
			
			Если МаксимальноеКоличествоОбластейМногострочнойЧасти(МногострочныеЧасти) > 0 Тогда
				ОбнулитьИтоговыеПоказателиНаТекущемЛисте(ИтоговыйТаблДок);
			КонецЕсли;
					
			Если ВидПечати = "ПоказатьБланк" Тогда
				ИтоговыйТаблДок.Показать(СокрП(Форма.Заголовок) + " (" + СокрП(ИмяЛиста) + ")");
			ИначеЕсли ВидПечати = "ПечататьСразу" Тогда
				ИтоговыйТаблДок.Напечатать();
			Иначе
				СписокПечатныхФорм.Добавить(ИтоговыйТаблДок);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат СписокПечатныхФорм;
	
КонецФункции // ВывестиНаПечатьЛистРаздела()

// Возвращает количество строк в одной "строке многострочной части" макета.
//
// Параметры:
//	ТабличноеПоле - ТабличныйДокумент или ПолеТабличногоДокумента для которого следует определить высоту
//					"строк многострочной части".
//
Функция ПолучитьШагСтрокиДляТабличногоПоля(ТабличноеПоле)
	
	Для Инд = 0 по 9 Цикл
		ОблОпределениеВысоты = ТабличноеПоле.Области.Найти("ОпределениеВысотыСтрокиМногострочнойЧасти" + Формат(Инд, ""));
		Если ОблОпределениеВысоты <> Неопределено Тогда
			Возврат ТабличноеПоле.ПолучитьОбласть("ОпределениеВысотыСтрокиМногострочнойЧасти" + Формат(Инд, "")).ВысотаТаблицы;
		КонецЕсли;
	КонецЦикла;
	Возврат 1;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// записывает в рег-р сведений новые фамилию, имя и отчество
Процедура ЗаписатьДанныеФИОВРегистр(Ссылка, Фамилия, Имя, Отчество) Экспорт
	
	ФИОСрез = РегистрыСведений.ФИОФизЛиц.ПолучитьПоследнее(,Новый Структура("ФизЛицо",Ссылка));
	
	СтрокаСреза = ФИОСрез.Фамилия + ФИОСрез.Имя + ФИОСрез.Отчество;
	
	Если СтрокаСреза <> (Фамилия + Имя + Отчество) Тогда
		
		МенеджерЗаписи = РегистрыСведений.ФИОФизЛиц.СоздатьМенеджерЗаписи();
		
		МенеджерЗаписи.ФизЛицо = Ссылка;
		Если ПустаяСтрока(СтрокаСреза) Тогда
			МенеджерЗаписи.Период = '19000101';
		Иначе
			МенеджерЗаписи.Период = РабочаяДата;
		КонецЕсли;
		
		МенеджерЗаписи.Фамилия = Фамилия;
		МенеджерЗаписи.Имя = Имя;
		МенеджерЗаписи.Отчество = Отчество;
		
		МенеджерЗаписи.Записать(Истина);
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ И ФУНКЦИИ, ИСПОЛЬЗУЕМЫЕ В ДРУГИХ ДЕКЛАРАЦИЯХ
//

// роВставитьДополнительнуюСтраницу
// Создает дополнительную страницу многостраничного раздела формы.
//
// Параметры:
//  ИмяТекущейСтраницыПанели - строка - имя страницы,
//            в табличное поле которой вставляется дополнительная страница.
//  Если ИмяТекущейСтраницыПанели - неопределено, тогда берется
//  из активной ОсновнойПанели на форме.
//
Процедура роВставитьДополнительнуюСтраницу(Форма, ИмяТекущейСтраницыПанели = Неопределено ) Экспорт

	Перем ТаблицаСтраницРаздела;
	Перем СтруктураДанныхДопСтрокРаздела;

	Если ИмяТекущейСтраницыПанели = Неопределено Тогда
		ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
		ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;
	КонецЕсли;

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	ИмяТекТабличногоПоля     = "ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели;
	ТекТабличноеПоле         = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	// Сначала сохраним данные текущей страницы.
	// Если на листе есть многострочность, то удалим ее.
	роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Истина);

	// Часть для подстраховки, от старой системы хранения многостраничности
	Если ТаблицаСтраницРаздела.Количество() = 0 Тогда
		// создаем исходную таблицу значений многостраничных разделов
		СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Добавить();
		СтрТаблицаСтраницы.АктивнаяСтраница = Истина;
	КонецЕсли;

	// Найдем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");

	Если СтрТаблицаСтраницы <> Неопределено Тогда

		// Убираем активность у текущей страницы
		СтрТаблицаСтраницы.АктивнаяСтраница = Ложь;

		// Добавляем новую страницу
		СтрНоваяСтраница = ТаблицаСтраницРаздела.Добавить();

		// Присваиваем представление по умолчанию
		СтрНоваяСтраница.Представление      = "Новая страница";
		СтрНоваяСтраница.АвтоматическоеПредставление      = Истина;

		// Ставим признак активной страницы
		СтрНоваяСтраница.АктивнаяСтраница   = Истина;

		КолМногострочныхЧастей = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");
		Если ТипЗнч(КолМногострочныхЧастей) = Тип("ТаблицаЗначений") Тогда
			КолМногострочныхЧастей = КолМногострочныхЧастей.Количество();
		КонецЕсли;

		// Если есть многострочность, то она очищена в проц роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице
		// Если многострочность есть, то она удалится и запустится Расчет на стадии роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице
		Если КолМногострочныхЧастей = 0 Тогда
				// Очищаем текущее поле
			Форма.ОчиститьТабличноеПоле(ТекТабличноеПоле);
		КонецЕсли;

		Если КолМногострочныхЧастей = 0 Тогда
			// Выполняем расчет показателей добавленной страницы
			Форма.Расчет(ИмяТекущейСтраницыПанели);
		КонецЕсли;

		//ТекущийЭлемент     = ТекТабличноеПоле;
		Форма.Модифицированность = Истина;

	КонецЕсли;

	роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);

КонецПроцедуры // роВставитьДополнительнуюСтраницу()

// роДоступностьКнопокЛистания
// Процедура управляет доступностью кнопок "<" и ">" листания страниц
// многостраничных разделов формы
//
// Параметры:
//  НомерТекущейСтраницы - число, порядковый номер текущей страницы;
//  КоличествоСтраниц    - число, количество страниц многостраничного раздела;
//  ИмяТекСтраницы       - строка, имя текущей страницы основной панели формы.
//
Процедура роДоступностьКнопокЛистания(Форма, НомерТекущейСтраницы, КоличествоСтраниц, ИмяТекущейСтраницыПанели) Экспорт

	ДоступностьКнопкаПредыдущаяСтраница = Ложь;
	ДоступностьКнопкаСледующаяСтраница  = Ложь;

	Если НомерТекущейСтраницы > 1 Тогда
		ДоступностьКнопкаПредыдущаяСтраница = Истина;
	КонецЕсли;

	Если НомерТекущейСтраницы < КоличествоСтраниц Тогда
		ДоступностьКнопкаСледующаяСтраница = Истина;
	КонецЕсли;

	Форма.ЭлементыФормы["КнопкаПредыдущаяСтраница" + ИмяТекущейСтраницыПанели].Доступность = ДоступностьКнопкаПредыдущаяСтраница;
	Форма.ЭлементыФормы["КнопкаСледующаяСтраница"  + ИмяТекущейСтраницыПанели].Доступность = ДоступностьКнопкаСледующаяСтраница;
	
КонецПроцедуры // роДоступностьКнопокЛистания()

// роОбновитьСтруктуруМногостраничныхРазделов
// Вариант версия 12.05.2005
// Обновляет структуру многостраничных разделов формы.
// После обновления структуры выводит в табличный документ
// данные первой страницы из набора страниц.
// Используется в следующих процедурах и функциях:
// Процедура Очистить()
// Процедура Сохранить()
// Процедура ЗаполнитьСведенияОбФЛ()
// Функция ВычислитьПоказателиТитульногоЛистаИСведенияОФизЛицах
// Процедура УниверсальнаяВыгрузкаПредписанныхПоказателей
// Функция ПроверитьПредписанныеПоказатели
//
Процедура роОбновитьСтруктуруМногостраничныхРазделов(Форма, ИмяСтраницы = Неопределено) Экспорт

	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекущейСтраницыПанели = Страница.Ключ;
		ТаблицаТекущейСтраницы   = Страница.Значение;

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяСтраницы <> ИмяТекущейСтраницыПанели Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Для декларации по прибыли, специальные два раздела сохраняются особым образом
		// пришлось внести изменения в общий модуль и процедуру для всех отчетов

		Если (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ1") Или (ИмяТекущейСтраницыПанели = "Лист03_РазделыБВ2") Тогда
			Форма.СохранитьДанныеМногостраничногоРазделаВактивнойСтраницеРешения(ИмяТекущейСтраницыПанели);
		Иначе

		// Обновляя представления сохранения активного листа декларации
		// Параметр Ложь - не позволяет удалять многострочные части, если они есть на листе
			роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Ложь);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // роОбновитьСтруктуруМногостраничныхРазделов()

// роОбнулитьПеременныеМодуляХранящиеЗначенияКвадратногоПредставления
// Процедура входит в группу стандартных функций
// Вариант версия 17.05.2005
// Всегда используется в обработчике "ПриОткрытии" основной формы декларации
//
Процедура роОбнулитьПеременныеМодуляХранящиеЗначенияКвадратногоПредставления(Форма) Экспорт

	Если ТипЗнч(Форма.мСвойстваРазделовДекларации) <> Тип("ДеревоЗначений") Тогда
		Возврат;
	КонецЕсли;

	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл
		Если СтрокаУровня1.ПредставлениеДанных Тогда
			Форма.ОбнулитьПеременныеМодуляХранящиеЗначенияКвадратногоПредставленияПоРазделу(СтрокаУровня1.ИмяСтраницы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // роОбнулитьПеременныеМодуляХранящиеЗначенияКвадратногоПредставления

// роОпределитьПредставлениеДопСтраниц
// Процедура присваивает дополнительным листам многостраничных разделов
// уникальные имена (представление).
// Если ИмяСтраницы - неопределено, тогда по всем страницам
// ТолькоУАктивнойСтраницы - Если Истина то только у активной страницы меняется представление
// ТолькоУАктивнойСтраницы = Ложь или Неопределено - тогда у всех в структуре
//
Процедура роОпределитьПредставлениеДопСтраниц(Форма, ИмяСтраницы = Неопределено, ТолькоУАктивнойСтраницы = Неопределено) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ТекущееПредставлениеСтраницы;

	ТолькоАктивная = ?(ТолькоУАктивнойСтраницы = Неопределено, Ложь, ТолькоУАктивнойСтраницы);

	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекСтраницы        = Страница.Ключ;
		ТаблицаСтраницРаздела = Страница.Значение;

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяТекСтраницы <> ИмяСтраницы Тогда
				Продолжить; // Пропускаем не нужные страницы
			КонецЕсли;
		КонецЕсли;

		// Если есть хоть одна страница - определим её представление
		Если ТаблицаСтраницРаздела.Количество() > 0 Тогда

			НомерСтраницы = 0;

			Для Каждого СтрокаТаблицы Из ТаблицаСтраницРаздела Цикл

				НомерСтраницы = НомерСтраницы + 1;

				СохрПредставлениеСтраницы = СтрокаТаблицы.Представление;

				// Если колонки нет, тогда автоматическое представление включено по умолчанию.
				Если ТаблицаСтраницРаздела.Колонки.Найти("АвтоматическоеПредставление") = Неопределено Тогда
					АвтоматическоеПредставление = Истина;
				Иначе
					АвтоматическоеПредставление = СтрокаТаблицы.АвтоматическоеПредставление;
				КонецЕсли;

				Если НЕ АвтоматическоеПредставление Тогда
					Продолжить;
				КонецЕсли;

				// Определяем представление дополнительной страницы
				СтруктураДанныхСтраницы = СтрокаТаблицы.Данные;

				ИмяПредставления = роПолучитьСвойствоРаздела(Форма, ИмяТекСтраницы, "ИмяПредставления");

				Если НЕ ЗначениеЗаполнено(ИмяПредставления) Тогда
					ТекущееПредставлениеСтраницы = Неопределено;
				Иначе
					СтруктураДанныхСтраницы.Свойство(ИмяПредставления, ТекущееПредставлениеСтраницы);
				КонецЕсли;

				Если (НЕ ТолькоАктивная) Или ((ТолькоАктивная) И (СтрокаТаблицы.АктивнаяСтраница))Тогда

					ТекущееПредставлениеСтраницы = ?(ПустоеЗначение(ТекущееПредставлениеСтраницы), "Лист N " + Строка(НомерСтраницы), ТекущееПредставлениеСтраницы + ". Лист N " + Строка(НомерСтраницы));
					Если Не ПустаяСтрока(ТекущееПредставлениеСтраницы) Тогда
						СтрокаТаблицы.Представление = ТекущееПредставлениеСтраницы;
					Иначе
						СтрокаТаблицы.Представление = "Новая страница";
					КонецЕсли;

				КонецЕсли; // ТолькоАктивная

			КонецЦикла;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // роОпределитьПредставлениеДопСтраниц

// роОткрытьФормуСпискаДопСтраниц
// Версия-вариант 12.05.2005
// Открывает форму документа ФормаСпискаДопСтраниц для выбора из списка и
// последующего отображения дополнительной страницы многостраничного раздела.
//
Процедура роОткрытьФормуСпискаДопСтраниц(Форма, ИмяСтраницы = Неопределено) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ВыбрТаблицаСтраницРаздела;
	Перем ФлМодифицированностьСписка;

	// В процедуру внесены изменения, если на основной панели, есть ещё панель
	// то вторым параметром следует передавать имя листа
	// по умолчанию берется из основной панели, текущий лист

	Если ИмяСтраницы = Неопределено Тогда

		ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
		ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;

	Иначе

		ИмяТекущейСтраницыПанели = ИмяСтраницы;

	КонецЕсли;

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	Если ТаблицаСтраницРаздела.Количество() <= 1 Тогда
		Возврат;
	КонецЕсли;

	ИмяТекТабличногоПоля     = "ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели;
	ТекТабличноеПоле         = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	// Сначала сохраним данные текущей страницы.
	//
	// СтруктураДанныхТекущейТаблицы = СобратьДанныеТекущегоТаблПоля(ТекТабличноеПоле);
	роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Ложь);

	//ФормаВыбораДопСтраницы = Обработки.ОперацииРегламентированнойОтчетности.ПолучитьФорму("ФормаСпискаДопСтраниц", Форма, "дляПереходаНаСтраницу");
	ФормаВыбораДопСтраницы = роПолучитьОбщуюФорму("ФормаСпискаДопСтраниц", Форма, "дляПереходаНаСтраницу");

	// ФормаВыбораДопСтраницы = Форма.ЭтотОбъект.ПолучитьФорму("ФормаСпискаДопСтраниц", Форма, "дляПереходаНаСтраницу");
	Если ФормаВыбораДопСтраницы.Открыта() Тогда
		ФормаВыбораДопСтраницы.Активизировать();
		Если Вопрос("Предыдущая операция показа списка страниц не завершена.
			|Завершить?",РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да)=КодВозвратаДиалога.Да Тогда
			ФормаВыбораДопСтраницы.Закрыть();
		КонецЕсли;
	КонецЕсли;

	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("ТаблицаРаздела", ТаблицаСтраницРаздела);
	СтруктураДанных.Вставить("ИмяТекущейСтраницы", ИмяТекущейСтраницыПанели);
	СтруктураДанных.Вставить("ПерестановкаСтраницЗапрещена", роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "ПерестановкаСтраницЗапрещена", Ложь));

	ФормаВыбораДопСтраницы.НачальноеЗначениеВыбора = СтруктураДанных;

	ВыбранноеЗначение = ФормаВыбораДопСтраницы.ОткрытьМодально();
	Если ВыбранноеЗначение <> Неопределено Тогда

		// Так как признак активной страницы не зависит от Модифицированнойсти формы, то не анализируя этот показатель всегда вставляем
		// в структуру многостраничных разделов полученную таблицу.

		ВыбранноеЗначение.Свойство("ТаблицаСтраницРаздела",  ВыбрТаблицаСтраницРаздела);

		// Найдем активную страницу, если что-то менялось на форме
		ВыбраннаяСтраница = ВыбрТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");
		ИндексВыбСтраницы = ВыбрТаблицаСтраницРаздела.Индекс(ВыбраннаяСтраница);

		Форма.мСтруктураМногостраничныхРазделов.Вставить(ИмяТекущейСтраницыПанели, ВыбрТаблицаСтраницРаздела.Скопировать());

		// Переопределим представления доп. страниц.
		роОпределитьПредставлениеДопСтраниц(Форма, ИмяТекущейСтраницыПанели, Ложь);

		// Если в табличном поле есть многострочность, то её очистим, а в процедуре
		// роПоказатьСтраницу... перерисуем область в табличном поле.
		КолМногострочныхЧастей = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");
		Если ТипЗнч(КолМногострочныхЧастей) = Тип("ТаблицаЗначений") Тогда
			КолМногострочныхЧастей = КолМногострочныхЧастей.Количество();
		КонецЕсли;

		Если КолМногострочныхЧастей > 0 Тогда
			Форма.ОчиститьТабличноеПоле(ТекТабличноеПоле);
		КонецЕсли;

		роПоказатьСтраницуМногостраничногоРазделаПриВосстановлении(Форма, ИндексВыбСтраницы, ИмяТекущейСтраницыПанели, Истина, КолМногострочныхЧастей);

		// Если на форме доп. страниц изменился порядок страниц или представления, тогда возведем признак модифицированности и в родительском отчете
		Если ВыбранноеЗначение.ФлагМодифицированности Тогда
			Форма.Модифицированность = Истина;
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // роОткрытьФормуСпискаДопСтраниц()

// роВывестиЭлементыВариантаЗаполнения
//
// Процедура отображает параметры автозаполнения ячейки в соответствующих элементах
// текущей страницы формы и, в зависимости от параметров, управляет доступностью 
// элементов .формы.
//
// Параметры:
//  Текущая ячейка - область ячеек табличного документа, по которой необходимо
//                   отобразить параметры автозаполнения.
//
Процедура роВывестиЭлементыВариантаЗаполнения(Форма, ТекущаяЯчейка) Экспорт
	Перем Комментарий;

	ИмяПоказателя = ТекущаяЯчейка.Имя;

	Если Найти(ИмяПоказателя, ":") > 0 Тогда
		// Неименованная область ячеек таблицы
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	Если ТипЗнч(ТекущаяЯчейка) = Тип("РисунокТабличногоДокумента") Тогда
		// Пропускаем рисунки табличного документа
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	Если Не ТекущаяЯчейка.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	Если ТекущаяЯчейка.СодержитЗначение <> Истина Тогда
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	Если ТекущаяЯчейка.Защита Тогда
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
	ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;

	ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяТекущейСтраницыПанели);
	Если ТаблицаВариантыЗаполнения = Неопределено Тогда
		Возврат;
	КонецЕсли;

	НайденнаяСтрока = ТаблицаВариантыЗаполнения.Найти(ИмяПоказателя, "КодПоказателя");
	Если НайденнаяСтрока = Неопределено Тогда
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
		Возврат;
	КонецЕсли;

	ВариантЗаполнения = НайденнаяСтрока.ВариантЗаполнения;
	Дельта            = НайденнаяСтрока.Дельта;
	Комментарий       = НайденнаяСтрока.Комментарий;

	Если ВариантЗаполнения = 1 ИЛИ 
		ВариантЗаполнения = 2 ИЛИ
		ВариантЗаполнения = 3 Тогда

		ВариантЗаполнения = НайденнаяСтрока.ВариантЗаполнения;
		Дельта            = НайденнаяСтрока.Дельта;
		Комментарий       = НайденнаяСтрока.Комментарий;

		Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения"    + ИмяТекущейСтраницыПанели].Значение = ВариантЗаполнения;
		Форма.ЭлементыФормы["ПолеВводаЗначениеКорректировки" + ИмяТекущейСтраницыПанели].Значение = Дельта;
		Форма.ЭлементыФормы["ПолеВводаКомментарий"           + ИмяТекущейСтраницыПанели].Значение = Комментарий;	
		роДоступностьЭлементовВариантаЗаполнения(Форма, ВариантЗаполнения);

	ИначеЕсли ВариантЗаполнения = 0 Тогда
		роДоступностьЭлементовВариантаЗаполнения(Форма,, ТекущаяЯчейка);
	КонецЕсли;

КонецПроцедуры // роВывестиЭлементыВариантаЗаполнения()

// роДоступностьЭлементовВариантаЗаполнения
//
// Процедура управляет доступностью полей указания параметров заполнения ячеек,
// которые могут быть заполнены при автозаполнении отчета.
//
// Параметры:
//  Вариант         - число, вариант заполнения ячейки;
//  Текущая область - область ячеек табличного документа, ссылка на ячейку.
//
Процедура роДоступностьЭлементовВариантаЗаполнения(Форма, Вариант = Неопределено, ТекущаяОбласть = Неопределено) Экспорт
	
	ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
	ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;

	Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяТекущейСтраницыПанели) Тогда
		Возврат;
	КонецЕсли;

	ДоступностьПолеВыбораВариантЗаполнения    = Ложь;
	ДоступностьПолеВводаЗначениеКорректировки = Ложь;
	ДоступностьПолеВводаКомментарий           = Ложь;

	Если Вариант <> Неопределено Тогда
		ДоступностьПолеВыбораВариантЗаполнения            = Истина;
		Если Вариант <> 3 Тогда
			ДоступностьПолеВводаКомментарий               = Истина;
			Если Вариант = 2 Тогда
				ДоступностьПолеВводаЗначениеКорректировки = Истина;
			КонецЕсли;
		КонецЕсли;

	Иначе
		ОписаниеЯчейки = "";
	
		Если ТекущаяОбласть.ЦветФона = Новый Цвет(192, 220, 192) Тогда
			ОписаниеЯчейки    = "Значение вычисляется автоматически";
		ИначеЕсли ТекущаяОбласть.ЦветФона = Новый Цвет(255, 255, 192) Тогда
			ОписаниеЯчейки    = "Значение вводится вручную";
		ИначеЕсли ТекущаяОбласть.ЦветФона = Новый Цвет(255, 240, 200) Тогда
			ОписаниеЯчейки    = "Либо вручную, либо автоматически";

		КонецЕсли;
	Попытка
	// попытки сделаны для того, чтобы если автозапол только 4
	// на всем листе, то не пытаться выводить в комбобоксы
	// т.к. их может в этом случае не быть просто на форме
	// сделано для универсальности, пример есть в Имуществе
		Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения"    + ИмяТекущейСтраницыПанели].Значение = "";
		Форма.ЭлементыФормы["ПолеВводаЗначениеКорректировки" + ИмяТекущейСтраницыПанели].Значение = 0;
		Форма.ЭлементыФормы["ПолеВводаКомментарий"           + ИмяТекущейСтраницыПанели].Значение = ОписаниеЯчейки;
	Исключение
		// в случае, если на листе не предусмотре автоматическое заполнение, кроме признака 4
	КонецПопытки;

	КонецЕсли;

	
	Попытка
	// попытки сделаны для того, чтобы если автозапол только 4
	// на всем листе, то не пытаться выводить в комбобоксы
	// т.к. их может в этом случае не быть просто на форме
	// сделано для универсальности, пример есть в Имуществе
	Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения"    + ИмяТекущейСтраницыПанели].Доступность = ДоступностьПолеВыбораВариантЗаполнения;
	Форма.ЭлементыФормы["ПолеВводаЗначениеКорректировки" + ИмяТекущейСтраницыПанели].Доступность = ДоступностьПолеВводаЗначениеКорректировки;
	Форма.ЭлементыФормы["ПолеВводаКомментарий"           + ИмяТекущейСтраницыПанели].Доступность = ДоступностьПолеВводаКомментарий;
	Исключение
		// в случае, если на листе не предусмотре автоматическое заполнение, кроме признака 4
	КонецПопытки;

КонецПроцедуры // роДоступностьЭлементовВариантаЗаполнения

// роОчистить
// Функция входит в состав стандартных процедур/функций
// Вариант-версия 14.05.2005
// Процедура очищает содержимое редактируемых и вычисляемых
// ячеек табличного документа.
//
// Возврат:
// Истина                  - если очистка произошла
// Ложь                    - в случае отказа от очистки
//
Функция роОчистить(Форма, ЗадаватьВопросПередОчисткой = Истина) Экспорт

	// Ранее, очистка происходила по панели, перебирая каждую страницу
	// Теперь переделано, и очистка проходит по свойствам декларации, перебирая
	// мСвойстваРазделовДекларации, т.к. на одной странице могутб быть несколько
	// табличных полей, например Прибыль, раздел Лист03_РазделыБВ

	// Переделано из процедуру в функцию
	// возвращает истина - если прошла очистка и ложь - если откзались от очистки
	ОчисткаПроизведена = Ложь;
	Если ЗадаватьВопросПередОчисткой Тогда

		Ответ = Вопрос("Внимание! Будут очищены все разделы (листы) документа." + Символы.ПС
		      + "Продолжить операцию?", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Нет);

		Если Ответ = КодВозвратаДиалога.Нет Тогда

			Возврат ОчисткаПроизведена;

		Иначе

			ОчисткаПроизведена = Истина;

		КонецЕсли;

	КонецЕсли;

	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл

		НазваниеСтраницы = СтрокаУровня1.ИмяСтраницы;
		Если (НазваниеСтраницы <> "Титульный") И (НазваниеСтраницы <> "ФизЛица") Тогда
			ИмяТекТабличногоПоля = "ПолеТабличногоДокумента" + НазваниеСтраницы;
			ТекТабличноеПоле = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];
			Форма.ОчиститьТабличноеПоле(ТекТабличноеПоле);
		КонецЕсли;

	КонецЦикла;

	Попытка
		МногостраничностьЕсть = ?(Форма.мСтруктураМногостраничныхРазделов = Неопределено, Ложь, Истина);
	Исключение
		МногостраничностьЕсть = Ложь;
	КонецПопытки;

	Если МногостраничностьЕсть Тогда
		// Далее выясним, есть ли добавленные в многостраничный раздел дополнительные страницы.
		// При наличии таких страниц удаляем их.
		// Удалим все страницы кроме активных, таким образом в структуре будет всегда оставаться одна страница
		Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл

			ИмяТекущейСтраницыПанели = Страница.Ключ;
			ТаблицаТекущейСтраницы   = Страница.Значение;

			Если (ТаблицаТекущейСтраницы.Количество() > 1)
			   И (ИмяТекущейСтраницыПанели <> "ФизЛица")
			   И (ИмяТекущейСтраницыПанели <> "Титульный") // Для деклараций по алкогольной продукции, титульный многостраничный.
			   // Учесть ситуация в прибыли, два спец-листа, удалим по особой технологии
			   // из модуля объекта
			   И (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ1")
			   И (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ2") Тогда

				ИндексСтраницы = 0;
				Пока Не (ИндексСтраницы > (ТаблицаТекущейСтраницы.Количество()-1)) Цикл
					// Пропускаем активную страницу по той причине,
					// что данные активной страницы былы очищены ранее.
					СтрокаТаблицы = ТаблицаТекущейСтраницы[ИндексСтраницы];
					Если НЕ СтрокаТаблицы.АктивнаяСтраница Тогда
						// удаляем дополнительную страницу
						ТаблицаТекущейСтраницы.Удалить(СтрокаТаблицы);

						Продолжить;
					КонецЕсли;

					ИндексСтраницы = ИндексСтраницы + 1;
				КонецЦикла;

			КонецЕсли;

			Если (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ1")
			   И (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ2") Тогда

				// Здесь ИмяТекущейСтраницыПанели - это имя из многостраничной структуры, а не панели
				ПанельРаздела = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "НазваниеПанелиТабличногоПоляРаздела");
				Если Форма.ЭлементыФормы[ПанельРаздела].ТекущаяСтраница.Имя = ИмяТекущейСтраницыПанели Тогда
					// Покажем статик активной страницы, если она не многостраничная, то процедура ничего не сделает
					роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);

				КонецЕсли;

			КонецЕсли;

		КонецЦикла;

		// Обновляем структуру многостраничных разделов
		роОбновитьСтруктуруМногостраничныхРазделов(Форма);

	КонецЕсли;

	// очищаем ячейки, в которых отображается дата подписи
	// должностных лиц организации
	Форма.ЗаполнитьДатуВЯчейках();

	// выполняем расчет вычисляемых показателей отчета
	// чтобы очистить соответствующие ячейки
	Форма.Расчет("");

	// устанавливаем флаг модифицированности формы
	Форма.Модифицированность = Истина;

	Возврат ОчисткаПроизведена;

КонецФункции // роОчистить()

// роПоказатьСтатикСтраницРаздела
// Отображает на странице основной панели формы, содержащей многостраничный раздел,
// порядковый номер текущей страницы из набора страниц.
//
// Параметры:
//  ИмяТекущейСтраницыПанели - строка, имя страницы основной панели формы, содержащей многостраничный раздел.
//
Процедура роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели) Экспорт
	Перем ТаблицаСтраницРаздела;

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	НомерТекущейСтраницы = 1;
	КоличествоСтраниц    = Макс(ТаблицаСтраницРаздела.Количество(), 1);

	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");
	Если СтрТаблицаСтраницы <> Неопределено Тогда
		НомерТекущейСтраницы = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы) + 1;
	КонецЕсли;

	СтатикСтраницРаздела = Строка(НомерТекущейСтраницы) + " из " + КоличествоСтраниц;
	Форма.ЭлементыФормы["НадписьСтатикСтраниц" + ИмяТекущейСтраницыПанели].Заголовок = СтатикСтраницРаздела;

	роДоступностьКнопокЛистания(Форма, НомерТекущейСтраницы, КоличествоСтраниц, ИмяТекущейСтраницыПанели);

	Форма.УстановитьЦветФонаЯчейки(,, ИмяТекущейСтраницыПанели);

КонецПроцедуры // роПоказатьСтатикСтраницРаздела

// роПоказатьСтраницуМногостраничногоРаздела
//
// Вариант версия 10.05.2005
// Выводит в табличный документ данные страницы многостраничного раздела формы.
// Одновременно убирая признак у активной страницы и сохраняя в неё данные текущего табличного поля
// Параметры:
//  Шаг                      - число,  количество перелистываемых страниц;
//  ИмяТекущейСтраницыПанели - строка, имя страницы основной панели формы, содержащий многостраничный раздел;
//  ПоказатьПоИндексу        - булево, управляет выводом страницы по заданному индексу в коллекции страниц.
//
Процедура роПоказатьСтраницуМногостраничногоРаздела(Форма, Шаг, ИмяТекущейСтраницыПанели, ПоказатьПоИндексу = Ложь) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ТаблицаВариантыЗаполнения;
	Перем СтруктураДанныхДопСтрокРаздела;

	ИмяТекТабличногоПоля = "ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели;
	ТекТабличноеПоле     = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");

	Если СтрТаблицаСтраницы = Неопределено Тогда
		роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);
		Возврат;
	КонецЕсли;

	НомерТекущейСтраницы   = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);

	Если Не ПоказатьПоИндексу Тогда
		НомерСледующейСтраницы = НомерТекущейСтраницы + Шаг;
	Иначе
		НомерСледующейСтраницы = Шаг;
	КонецЕсли;

	Если ((НомерСледующейСтраницы + 1) > ТаблицаСтраницРаздела.Количество()) ИЛИ (НомерСледующейСтраницы < 0) Тогда
		Возврат;
	КонецЕсли;

	// Сохраним данные активной страницы, с присвоением Представления страницы и с очистной многострочных частей (Истина)
	роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Истина);

	СтрТаблицаСтраницы.АктивнаяСтраница = Ложь;

	СтрСледующаяСтраница = ТаблицаСтраницРаздела[НомерСледующейСтраницы];

	СтрСледующаяСтраница.АктивнаяСтраница = Истина;

	ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяТекущейСтраницыПанели);

	КолМногострочныхЧастей = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");

	Если ТипЗнч(КолМногострочныхЧастей) = Тип("ТаблицаЗначений") Тогда
		КолМногострочныхЧастей = КолМногострочныхЧастей.Количество();
	КонецЕсли;

	Если КолМногострочныхЧастей > 0 Тогда

		НовДанныеДопСтрокРаздела = СтрСледующаяСтраница.ДанныеДопСтрок;

		// Способ хранения многострочных частей
		СохранятьМногострКакТЗ = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

	Иначе

		НовТаблицаДопСтрокРаздела = Неопределено; // Многострочности нет
		ИмяГруппыДопСтрок = Неопределено; // Имя группы строк неопределено

	КонецЕсли;

	Если НовДанныеДопСтрокРаздела <> Неопределено Тогда

		// В случае, если многострочных частей больше 1, то хранится структура, иначе, таблица значений с данными
		Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда
			Для Каждого ГруппаСтрок Из НовДанныеДопСтрокРаздела Цикл
				ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
				ДанныеГруппыСтрок = ГруппаСтрок.Значение;

				ПромТаблицаГруппыСтрок = ДанныеГруппыСтрок.Скопировать();

				// Заменяем таблицу значений с данными текущей страницы.
				Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
				// Выводим в табличный документ данные группы дополнительных строк
				Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
				// обновляем структуру многострочного раздела
				Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппыДопСтрок);
			КонецЦикла;

		ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтранице(ИмяТекущейСтраницыПанели);

			ПромТаблицаДопСтрокРаздела = НовДанныеДопСтрокРаздела.Скопировать();
			// Заменяем таблицу значений с данными текущей страницы.
			Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
			// Выводим в табличный документ данные группы дополнительных строк
			Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
			// обновляем структуру многострочного раздела
			Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппыДопСтрок);

		КонецЕсли;

	КонецЕсли;

	// отображаем данные следующей страницы
	СтруктураДанныхСледующаяСтраница = СтрСледующаяСтраница.Данные;
	ПредставлениеДанных = роПолучитьСвойствоРаздела(Форма, ИмяТекТабличногоПоля, "ПредставлениеДанных");

	Для Каждого Элемент Из СтруктураДанныхСледующаяСтраница Цикл
		ИмяПоказателя      = Элемент.Ключ;
		ЗначениеПоказателя = Элемент.Значение;

		Если ПредставлениеДанных Тогда

			Если Форма.ОбновитьПеременныеМодуля(ИмяПоказателя, ЗначениеПоказателя) Тогда
				Продолжить; // Пропустим цикл
			КонецЕсли;

		КонецЕсли;

			//Если Форма.мСтараяВерсияФормы <> Форма.мВерсияФормы Тогда
			// Старая версия формы, нужно по позможности собрать данные

				Попытка
					ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
				Исключение
				КонецПопытки;

			//Иначе
			//	ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
			//КонецЕсли;

			Если Не ТаблицаВариантыЗаполнения = Неопределено Тогда
				// обновляем примечания к ячейкам табличного документа
				НайденнаяСтрока = ТаблицаВариантыЗаполнения.Найти(ИмяПоказателя, "КодПоказателя");
				Если НайденнаяСтрока <> Неопределено Тогда
					ТекущийКомментарий = ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст;
					НовыйКомментарий   = НайденнаяСтрока.Комментарий;

					// примечание к ячейке устанавливаем тогда, когда изменился текст комментария
					Если Не (ПустаяСтрока(ТекущийКомментарий) И ПустаяСтрока(НовыйКомментарий)) Тогда
						ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст = НовыйКомментарий;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;

	КонецЦикла;

	Если ПредставлениеДанных Тогда
		Форма.ЗаполнениеЗначенийВКвадратиках(ИмяТекущейСтраницыПанели);
	КонецЕсли;

	//ТекущийЭлемент = ТекТабличноеПоле;

	роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);

КонецПроцедуры // роПоказатьСтраницуМногостраничногоРаздела()

// роПоказатьСтраницуМногостраничногоРазделаПриВосстановлении
//
// Вывод необходимого номера страницы
// Входит в блок стандартизированных процедур/функций
// Вариант-версия 14.05.2005
// Выводит особым способом в табличный документ данные страницы многостраничного раздела формы.
//
// Параметры:
// Шаг                      - число,  номер страницы, на которую необходимо перейти;
// ИмяТекущейСтраницыПанели - строка, имя страницы основной панели формы, содержащий многостраничный раздел;
// УчестьАктивнуюСтраницу - Если истина, то учитывается страница, которая была ранее активной, иначе нет
// КолМногострочныхЧастей - по умолчанию -1. Определяет, работать -ли при показате с многострочными частями
// как в процедуре ПоказатьСтраницуМногостраничногоРаздела, т.е. перерисовывать табличную часть.
// Данная операция не требуется при восстановлении документа, т.к. там отдельной процедурой рисуется области.
// -1 всегда, в процедуре по кнопке Перейти в многостраничных разделах, там будет анализироваться этот параметр.
//
Процедура роПоказатьСтраницуМногостраничногоРазделаПриВосстановлении(Форма, Шаг, ИмяТекущейСтраницыПанели, УчестьАктивнуюСтраницу = Ложь, КолМногострочныхЧастей = -1) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ТаблицаДопСтрокРаздела;
	Перем ТаблицаВариантыЗаполнения;

	ИмяТекТабличногоПоля = "ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели;
	ТекТабличноеПоле     = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	НомерСледующейСтраницы = Шаг;

	Если ((НомерСледующейСтраницы + 1) > ТаблицаСтраницРаздела.Количество()) ИЛИ (НомерСледующейСтраницы < 0) Тогда
		Возврат;
	КонецЕсли;

	// Для страниц многостраничного раздела, содержащих многострочную часть,
	// дополнительно сохраняем данные многострочной части.

	СтрСледующаяСтраница = ТаблицаСтраницРаздела[НомерСледующейСтраницы];
	Если УчестьАктивнуюСтраницу Тогда
		// найдем активную страницу
		АктивнаяСтраницаВ = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");
		АктивнаяСтраницаВИнд = ТаблицаСтраницРаздела.Индекс(АктивнаяСтраницаВ);
		ТекущиеАктивныеДанные = ТаблицаСтраницРаздела[АктивнаяСтраницаВИнд];
		ТекущиеАктивныеДанные.АктивнаяСтраница = Ложь; // убираем активность
		СтрСледующаяСтраница.АктивнаяСтраница = Истина; // ставим новую активность
	КонецЕсли;

	ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяТекущейСтраницыПанели);

	// отображаем данные
	СтруктураДанныхСледующаяСтраница = СтрСледующаяСтраница.Данные;

	ПредставлениеДанных = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "ПредставлениеДанных");

	// Вариант -1 означает, что процедура запущена из режима восстановить сохраненные данные.
	// В этом случае операции по расчерчиванию табличного поля для многострочных разделов не требуются.

	Если (КолМногострочныхЧастей > 0) И (КолМногострочныхЧастей <> -1) Тогда
		Если КолМногострочныхЧастей > 0 Тогда

			НовДанныеДопСтрокРаздела = СтрСледующаяСтраница.ДанныеДопСтрок;

			// Способ хранения многострочных частей
			СохранятьМногострКакТЗ = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

		Иначе

			ИмяГруппыДопСтрок = Неопределено; // Имя группы строк неопределено
			НовДанныеДопСтрокРаздела = Неопределено;

		КонецЕсли;

		Если НовДанныеДопСтрокРаздела <> Неопределено Тогда

			// В случае, если многострочных частей больше 1, то хранится структура, иначе, таблица значений с данными
			Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда
				Для Каждого ГруппаСтрок Из НовДанныеДопСтрокРаздела Цикл
					ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
					ДанныеГруппыСтрок = ГруппаСтрок.Значение;

					ПромТаблицаГруппыСтрок = ДанныеГруппыСтрок.Скопировать();

					// Заменяем таблицу значений с данными текущей страницы.
					Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					// Выводим в табличный документ данные группы дополнительных строк
					Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					// обновляем структуру многострочного раздела
					Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппыДопСтрок);
				КонецЦикла;

			ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

				ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтранице(ИмяТекущейСтраницыПанели);

				ПромТаблицаДопСтрокРаздела = НовДанныеДопСтрокРаздела.Скопировать();
				// Заменяем таблицу значений с данными текущей страницы.
				Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				// Выводим в табличный документ данные группы дополнительных строк
				Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				// обновляем структуру многострочного раздела
				Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппыДопСтрок);

			КонецЕсли;

		КонецЕсли;
	КонецЕсли;

	Для Каждого Элемент Из СтруктураДанныхСледующаяСтраница Цикл
		ИмяПоказателя      = Элемент.Ключ;
		ЗначениеПоказателя = Элемент.Значение;

		Если ПредставлениеДанных Тогда
			Если Форма.ОбновитьПеременныеМодуля(ИмяПоказателя, ЗначениеПоказателя) Тогда
				Продолжить; // Пропустим цикл
			КонецЕсли;
		КонецЕсли;

		//Если Форма.мСтараяВерсияФормы <> Форма.мВерсияФормы Тогда
		// Старая версия формы, нужно по позможности собрать данные

			Попытка
				ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
			Исключение
			КонецПопытки;

		//Иначе
		//	ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
		//КонецЕсли;

		Если Не ТаблицаВариантыЗаполнения = Неопределено Тогда
			// обновляем примечания к ячейкам табличного документа
			НайденнаяСтрока = ТаблицаВариантыЗаполнения.Найти(ИмяПоказателя, "КодПоказателя");
			Если НайденнаяСтрока <> Неопределено Тогда
				ТекущийКомментарий = ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст;
				НовыйКомментарий   = НайденнаяСтрока.Комментарий;

				// примечание к ячейке устанавливаем тогда, когда изменился текст комментария
				Если Не (ПустаяСтрока(ТекущийКомментарий) И ПустаяСтрока(НовыйКомментарий)) Тогда
					ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст = НовыйКомментарий;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	// Специально для декл. по прибыли, не отображать статит общими средствами
	// в листах Лист03_РазделыБВ1 и Лист03_РазделыБВ2
	Если (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ1")И (ИмяТекущейСтраницыПанели <> "Лист03_РазделыБВ2") Тогда
		роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);
	КонецЕсли;

КонецПроцедуры // роПоказатьСтраницуМногостраничногоРазделаПриВосстановлении()

// роПолучитьСвойствоРаздела
//
// Получает из дерево св-в необходимый параметр
// Параметры
// ИмяСтраница - название страницы, для которой необходимо получить св-во
// ИмяСвойства - имя настройки
// ВозвращаемоеЗначение - в случае, если св-во отсутствует, то можно через данный параметр передать значение
//  которое будет возвращено, в случае отсутствия параметра в свойствах.
//
Функция роПолучитьСвойствоРаздела(Форма, Знач ИмяСтраницы, Знач ИмяСвойства, ВозвращаемоеЗначение = Неопределено) Экспорт

	Результат = Неопределено;

	Если ТипЗнч(Форма.мСвойстваРазделовДекларации) <> Тип("ДеревоЗначений") Тогда
		Возврат Результат;
	КонецЕсли;

	Если Найти(ИмяСтраницы, "ПолеТабличногоДокумента") > 0 Тогда
		ИмяСтраницыП = СтрЗаменить(ИмяСтраницы, "ПолеТабличногоДокумента", "");
	Иначе
		ИмяСтраницыП = ИмяСтраницы;
	КонецЕсли;

	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл
		Если ИмяСтраницыП = СтрокаУровня1.ИмяСтраницы Тогда
			Попытка
				Результат = СтрокаУровня1[ИмяСвойства];
			Исключение
				Результат = ВозвращаемоеЗначение;
			КонецПопытки;

			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСвойствоРаздела

// роПолучитьТаблицуВариантовЗаполнения
// Функция определяет варианты заполнения ячеек табличного документа
// по имени страницы основной панели формы.
//
// Параметры:
//   ИмяСтраницыПанели - строка, имя страницы основной панели формы.
//   ПолучитьЭталонную - булево, если истина, получаем эталонную
//                               (исходную) таблицу вариантов заполнения.
//  ТипЗнчСуммы        - тип колонки сумма, при эталонной отдаче результата. По умолчанию и для
//  деклаций старого периода всегда равно 15.2 и параметр Неопределено.
// Возвращаемое значение:
//   таблица значений, содержащая информацию о вариантах автозаполнения ячеек.
//
Функция роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяСтраницыПанели, ПолучитьЭталонную = Ложь, ТипЗнчСуммы = Неопределено) Экспорт
	Перем МассивВариантовЗаполненияСтраниц;
	Перем ТаблицаВариантыЗаполнения;
	Перем ТаблицаСтраницРаздела;

	Если Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницыПанели, МассивВариантовЗаполненияСтраниц) Тогда

		Если НЕ ПолучитьЭталонную Тогда
			// получим варианты заполнения ячеек, заданные для активной страницы
			НомерТекущейСтраницы = 1;

			// Определим, присутствует ли многостраничность в декларации или нет.
			Попытка
				МногостраничностьЕсть = ?(Форма.мСтруктураМногостраничныхРазделов = Неопределено, Ложь, Истина);
			Исключение
				МногостраничностьЕсть = Ложь;
			КонецПопытки;

			Если МногостраничностьЕсть Тогда
				Если Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяСтраницыПанели, ТаблицаСтраницРаздела) Тогда
					// Раздел является многостраничным. Определим активную страницу раздела:
					СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");

					Если СтрТаблицаСтраницы <> Неопределено Тогда
						НомерТекущейСтраницы = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы) + 1;
					КонецЕсли;
				КонецЕсли;

				Если МассивВариантовЗаполненияСтраниц.Количество() < НомерТекущейСтраницы Тогда
					Для Сч = МассивВариантовЗаполненияСтраниц.Количество() По НомерТекущейСтраницы Цикл
						МассивВариантовЗаполненияСтраниц.Добавить(МассивВариантовЗаполненияСтраниц[0].Скопировать());	
					КонецЦикла;
				КонецЕсли;

			КонецЕсли;

			ТаблицаВариантыЗаполнения = МассивВариантовЗаполненияСтраниц[НомерТекущейСтраницы - 1];
		Иначе
			// Получим предустановленные (эталонные) варианты заполнения ячеек поля табличного
			// документа на заданной странице

			ОписаниеТиповСтрока15  = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(15));
			ОписаниеТиповСтрока50  = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(50));

			ОписаниеТиповСтрока100 = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(100));

			ОписаниеТиповЧисло1    = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(1));

			Если ТипЗнчСуммы = Неопределено Тогда
				ОписаниеТиповЧисло15   = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,2));
			Иначе
				ОписаниеТиповЧисло15 = ТипЗнчСуммы;
			КонецЕсли;

			ТаблВариантыЗаполнения = Новый ТаблицаЗначений;
			ТаблВариантыЗаполнения.Колонки.Добавить( "КодПоказателя",     ОписаниеТиповСтрока50  );
			ТаблВариантыЗаполнения.Колонки.Добавить( "ВариантЗаполнения", ОписаниеТиповЧисло1    );
			ТаблВариантыЗаполнения.Колонки.Добавить( "ЗначениеАвто",      ОписаниеТиповЧисло15   );
			ТаблВариантыЗаполнения.Колонки.Добавить( "Дельта",            ОписаниеТиповЧисло15   );
			ТаблВариантыЗаполнения.Колонки.Добавить( "Комментарий",       ОписаниеТиповСтрока100 );
			ТаблВариантыЗаполнения.Колонки.Добавить( "КодПоказателяПоСтруктуре",       ОписаниеТиповСтрока50 );

			// варианты заполнения определяем по макету СоставПоказателей
			МакетСоставаПоказателей = Форма.ЭтотОбъект.ПолучитьМакет(Форма.мСоставПоказателей);

			ТекОбласть = МакетСоставаПоказателей.Области.Найти(ИмяСтраницыПанели);
			Если ТекОбласть <> Неопределено Тогда
			
				Для Ном = ТекОбласть.Верх По ТекОбласть.Низ Цикл
					// Перебираем строки макета.
					// Код показателя (по составу показателей) определяется по первой колонке макета
					КодПоказателя = СокрП(МакетСоставаПоказателей.Область(Ном, 1).Текст);
					ИмяПоказателя = КодПоказателя;

					Если КодПоказателя = "===" Тогда         // признак конечной строки
						Прервать;
					КонецЕсли;

					Если Лев(КодПоказателя, 2) = "//" Тогда  // пропускаем комментарии
						Продолжить;
					КонецЕсли;

					// код показателя по форме отчете (имя ячейки в полях табличного документа формы)
					КодПоказателяПоФорме = СокрЛП(МакетСоставаПоказателей.Область(Ном, 2).Текст);
					// вариант заполнения ячейки определяется по колонке 6 макета
					стрВариантЗаполнения = СокрЛП(МакетСоставаПоказателей.Область(Ном, 6).Текст);
					чВариантЗаполнения   = ? (ПустаяСтрока(стрВариантЗаполнения), 0, Число(стрВариантЗаполнения));

					КодПоказателяПоСтруктуре = СокрЛП(МакетСоставаПоказателей.Область(Ном, 9).Текст);

					Если чВариантЗаполнения <> 0 Тогда
						// Если в колонке 6 задан варианет заполнения показателя, 
						// то его значение может определяться по данным ИБ.
						// Дополняем таблицу значений вариантов заполнения
						НоваяСтрока = ТаблВариантыЗаполнения.Добавить();
						НоваяСтрока.КодПоказателя      = ? (Не ПустаяСтрока(КодПоказателяПоФорме), КодПоказателяПоФорме, КодПоказателя);
						НоваяСтрока.ВариантЗаполнения  = чВариантЗаполнения;
						НоваяСтрока.КодПоказателяПоСтруктуре = КодПоказателяПоСтруктуре;
					КонецЕсли;
				КонецЦикла;

				// Здесь описываются добавляемые в табл. вариантов заполнений параметры, которых
				// нет в эталонном составе показателей.
				// Для каждой формы могут быть свои показатели.
				// Пример ПФР, форма 2005, раздел 1.

				Если Форма.ЭтотОбъект.Метаданные().Имя = "РегламентированныйОтчетПФР"
				   И Форма.мВыбраннаяФорма = "ФормаОтчета2005Кв1" Тогда

					Если ИмяСтраницыПанели = "Раздел1" Тогда

						НоваяСтрока = ТаблВариантыЗаполнения.Добавить();
						НоваяСтрока.КодПоказателя      = "";
						НоваяСтрока.ВариантЗаполнения  = 4;
						НоваяСтрока.КодПоказателяПоСтруктуре  = "Сумма0Раздел1";

					КонецЕсли;

				КонецЕсли;

			КонецЕсли;

			Если ТаблВариантыЗаполнения.Количество() > 0 Тогда
				ТаблицаВариантыЗаполнения = ТаблВариантыЗаполнения.Скопировать();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат ТаблицаВариантыЗаполнения;

КонецФункции // роПолучитьТаблицуВариантовЗаполнения()

// роПроставитьНаВсехЛистах()
// Процедура проставляет значения в многостраничных документах
// может использоваться для простановки значений на одном листе, в нескольких позициях
//
// Параметры:
// Значение          - Значение, которое будет проставлено на лист
// ПрефиксНаЛисте    - Смысловая часть ячейки, без индекса в конце, например "ДатаПодписи"
// ЛистИсключение    - Лист, в котором не нужно проставлять данные, лист исключение
// ТолькоДляЛиста    - Название листа, если указано, то только этот лист будет обрабатываться
// ТолькоАктивныйЛистМногостраничнойчасти - Только активный лист, по умолчанию выключен режим
// ИспользоватьНомер - В случае, если параметр повторяется на листе несколько раз, например ИНН или КПП, по умолчанию включен
// ЛистыМногостраничные - если лист многостраничных, то проставлять во всех экземплярах листа, иначе, только в активном
//
Процедура роПроставитьНаВсехЛистах(Форма, Знач Значение, Знач ПрефиксНаЛисте, ЛистИсключение = Неопределено, ТолькоДляЛиста = Неопределено, ТолькоАктивныйЛистМногостраничнойчасти = Ложь, ИспользоватьНомер = Истина, ЛистыМногостраничные = Истина) Экспорт

	Перем ТаблицаСтраницРаздела;

	ПереборЗнач = Форма.мДеревоВыбранныхСтраниц.Строки.Количество();

	Пока ПереборЗнач > 0 Цикл

		ИмяДляРасчета = Форма.мДеревоВыбранныхСтраниц.Строки[ПереборЗнач-1].ИмяСтраницы;

		Если ЗначениеЗаполнено(ТолькоДляЛиста) Тогда
			ЛистыТолько = Новый Структура(ТолькоДляЛиста);
			Если НЕ ЛистыТолько.Свойство(ИмяДляРасчета) Тогда
			//ТолькоДляЛиста <> ИмяДляРасчета Тогда
				ПереборЗнач = ПереборЗнач-1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если ЗначениеЗаполнено(ЛистИсключение) Тогда
			ЛистыИскл = Новый Структура(ЛистИсключение);
			// Если ЛистИсключение = ИмяДляРасчета Тогда
			Если ЛистыИскл.Свойство(ИмяДляРасчета) Тогда
				ПереборЗнач = ПереборЗнач-1;
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		
		РезВыбор = (Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяДляРасчета, ТаблицаСтраницРаздела));
		Если (НЕ ЛистыМногостраничные) Или (РезВыбор) Тогда
			
			Колво = роКолвоЛистоВРазделе(Форма, ИмяДляРасчета);

			Для Инд = 1 По Колво Цикл
				// В случае, если в декларации нет своей специализированной процедуры простановки
				// тогда вызовем стандатную из этого модуля.
				// Пример: Прибыль иностранной орг., там отличная ПроставитьВКвадратыЗначения от других
				Попытка
					Форма.ПроставитьВКвадратыЗначения(ИмяДляРасчета, ПрефиксНаЛисте + ?(ИспользоватьНомер, Строка(Инд) + "_", ""), СтрДлина(Значение), Значение);
				Исключение
					роПроставитьВКвадратыЗначения(Форма, ИмяДляРасчета, ПрефиксНаЛисте + ?(ИспользоватьНомер, Строка(Инд) + "_", ""), СтрДлина(Значение), Значение);
				КонецПопытки;
			КонецЦикла;

		ИначеЕсли ЛистыМногостраничные И (НЕ РезВыбор) Тогда

			роОбновитьСтруктуруМногостраничныхРазделов(Форма, ИмяДляРасчета);

			ИндА = 0;
			АктивныйНомерСтр = 0;
			Для Каждого Страница Из ТаблицаСтраницРаздела Цикл

				ИндА = ИндА + 1;

				Колво = роКолвоЛистоВРазделе(Форма, ИмяДляРасчета);

				Для Инд77 = 1 По Колво Цикл

					Если Страница.АктивнаяСтраница Тогда
						// В случае, если в декларации нет своей специализированной процедуры простановки
						// тогда вызовем стандатную из этого модуля.
						// Пример: Прибыль иностранной орг., там отличная ПроставитьВКвадратыЗначения от других
						Попытка
							Форма.ПроставитьВКвадратыЗначения(ИмяДляРасчета, ПрефиксНаЛисте + ?(ИспользоватьНомер, Строка(Инд77) + "_", ""), СтрДлина(Значение), Значение);
						Исключение
							роПроставитьВКвадратыЗначения(Форма, ИмяДляРасчета, ПрефиксНаЛисте + ?(ИспользоватьНомер, Строка(Инд77) + "_", ""), СтрДлина(Значение), Значение);
						КонецПопытки;

					Иначе

						Если НЕ ТолькоАктивныйЛистМногостраничнойчасти Тогда
							Для Инд = 1 По СтрДлина(Значение) Цикл
									Страница.Данные.Вставить(ПрефиксНаЛисте + ?(ИспользоватьНомер, Строка(Инд77) + "_", "") + Строка(Инд), Сред(Значение, Инд, 1));
							КонецЦикла;
						КонецЕсли;

					КонецЕсли;

				КонецЦикла;

			КонецЦикла;

			//ПоказатьСтраницуМногостраничногоРаздела(АктивныйНомерСтр, ИмяДляРасчета, Истина);

		КонецЕсли;

		ПереборЗнач = ПереборЗнач - 1;

	КонецЦикла;

КонецПроцедуры // роПроставитьНаВсехЛистах()

// роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице
//
// Процедура СохранитьДанныеМногостраничногоРазделаВактивнойСтранице
// сохраняет данные в актвном листе
// Особенность:
// Процедура только сохраняет данные, не передвигая страница на начальную
// или какую либу другую часть многостраничного раздела
// Используется в следующих частях:
// 1. ОбновитьСтруктуруМногостраничныхРазделов
// 2. ПоказатьСтраницуМногостраничногоРаздела
// 3. ВставитьДополнительнуюСтраницу
// 4. ОткрытьФормуСпискаДопСтраниц
//
Процедура роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницы, ОчищатьРазделЕслиЕстьМногострочность) Экспорт
	Перем ТаблицаСтраницРаздела;

	ИмяТекТабличногоПоля = "ПолеТабличногоДокумента" + ИмяТекущейСтраницы;
	ТекТабличноеПоле     = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницы, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	// Возьмем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");

	// Если нет активной страницы - то выход
	Если СтрТаблицаСтраницы = Неопределено Тогда
		роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницы);
		Возврат;
	КонецЕсли;

	// Берем индекс активной страницы
	НомерТекущейСтраницы   = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);

	// Сохраним данные текущей страницы.
	// В каждой декларации функция СобратьДанныеТекущегоТаблПоля - разные !
	СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоля(ТекТабличноеПоле);

	КолМногострочныхЧастей = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "МногострочностьВРазделе");
	Если ТипЗнч(КолМногострочныхЧастей) = Тип("ТаблицаЗначений") Тогда
		КолМногострочныхЧастей = КолМногострочныхЧастей.Количество();
	КонецЕсли;

	// Определяет, как работать с многострочностью в документе, либо как с ТаблЗначений или со структурой

	СохранятьМногострКакТЗ = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "СохранятьМногострКакТЗ");

	// Если лист является многострочным и многостраничным, то необходимо добавить в поле данные доп. строк
	// в этой декларации не используется, т.к. многострочность одна на листе
	Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Определим ИмяГруппы дополнительных строк, по необходимой страницы
		// Если на листе больше одной многострочной части, то алгорит сбора будет другим

		СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницы(ИмяТекущейСтраницы);
		ТаблицаДопСтрокРаздела = СтруктураДанныхДопСтрокРаздела;

	ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Блок для разделов, где хранится только одна многострочная часть
		ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтранице(ИмяТекущейСтраницы);
		Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппыДопСтрок);


		// Получим таблицу значений, содержащую данные дополнительных строк.
		ПромТаблицаДопСтрокРаздела = Новый ТаблицаЗначений;
		Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
		ТаблицаДопСтрокРаздела = ПромТаблицаДопСтрокРаздела.Скопировать();

	ИначеЕсли КолМногострочныхЧастей = 0 Тогда

		ВРазделеДекларацииЕстьМногострочность = Ложь;

	КонецЕсли;

	// Сохраним данные
	СтрТаблицаСтраницы.Данные           = СтруктураДанныхТекущейТаблицы;

	Если ВРазделеДекларацииЕстьМногострочность Тогда

		// Если процедура используется в ПоказатьСтраницуМногостраничногоРаздела, то необходимо
		// при показе след. страницы, убирать многострочность с листа, путем очистки
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			Форма.ОчиститьТабличноеПоле(ТекТабличноеПоле);
		КонецЕсли;

		// Запишем данные доп. строк
		СтрТаблицаСтраницы.ДанныеДопСтрок   = ТаблицаДопСтрокРаздела;
	КонецЕсли;

	// Попытаемся определить представление, только по текущей странице (по активной), последний параметр Истина
	роОпределитьПредставлениеДопСтраниц(Форма, ИмяТекущейСтраницы, Истина);

КонецПроцедуры // роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице

// роУдалитьДополнительнуюСтраницу
//
// Удаляет текущую страницу многостраничного раздела формы.
// Параметры:
//  ИмяТекущейСтраницыПанели - строка - имя страницы основной панели формы,
//              в табличном поле которой удаляется дополнительная страница.
//
Процедура роУдалитьДополнительнуюСтраницу(Форма, ИмяТекущейСтраницыПанели = Неопределено) Экспорт
	Перем ТаблицаСтраницРаздела;

	Если ИмяТекущейСтраницыПанели = Неопределено Тогда
		ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
		ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;
	КонецЕсли;

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	// Если одна страница в разделе, то её удалять нельзя
	Если ТаблицаСтраницРаздела.Количество() = 1 Тогда
		Возврат;
	КонецЕсли;

	ИмяТекТабличногоПоля     = "ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели;
	ТекТабличноеПоле         = Форма.ЭлементыФормы[ИмяТекТабличногоПоля];

	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.Найти(Истина, "АктивнаяСтраница");

	Если СтрТаблицаСтраницы <> Неопределено Тогда
		ИндексТекСтрока = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);
		ТаблицаСтраницРаздела.Удалить(СтрТаблицаСтраницы);

		// очищаем редактируемые ячейки удаляемой страницы
		Форма.ОчиститьТабличноеПоле(ТекТабличноеПоле);

		КолвоДопСтраниц = ТаблицаСтраницРаздела.Количество();

		Если КолвоДопСтраниц > 0 Тогда
			СтрТаблицаСтраницыЗамена = ТаблицаСтраницРаздела[Мин(ИндексТекСтрока, КолвоДопСтраниц - 1)];

			// Для страниц многостраничного раздела, содержащих многострочную часть,
			// восстанавливаем структуру дополнительных строк.
			//
			// Предварительно проверим, содержит ли страница многострочные части

			КолвоМногострочныхБлоков = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");
			Если ТипЗнч(КолвоМногострочныхБлоков) = Тип("ТаблицаЗначений") Тогда
				КолвоМногострочныхБлоков = КолвоМногострочныхБлоков.Количество();
			КонецЕсли;
			СохранятьМногострКакТЗ = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

			Если КолвоМногострочныхБлоков > 0 Тогда
				ДанныеДопСтрокРаздела = СтрТаблицаСтраницыЗамена.ДанныеДопСтрок;
			Иначе
				ДанныеДопСтрокРаздела = Неопределено;
			КонецЕсли;

			Если ДанныеДопСтрокРаздела <> Неопределено Тогда

				Если (КолвоМногострочныхБлоков > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

					Для Каждого ГруппаСтрок Из ДанныеДопСтрокРаздела Цикл
						ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
						ДанныеГруппыСтрок = ГруппаСтрок.Значение;

						ПромТаблицаГруппыСтрок = ДанныеГруппыСтрок.Скопировать();

						// Заменяем таблицу значений с данными текущей страницы.
						Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
						// Выводим в табличный документ строки многострочной группы
						Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					КонецЦикла;

				ИначеЕсли (КолвоМногострочныхБлоков > 0) И (СохранятьМногострКакТЗ) Тогда

					ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтранице(ИмяТекущейСтраницыПанели);
					ПромТаблицаДопСтрокРаздела = ДанныеДопСтрокРаздела.Скопировать();

					// Заменяем таблицу значений с данными текущей страницы.
					Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
					// Выводим строки многострочной группы замещающей страницы
					ФОрма.ВывестиРазделВТабличныйДокумент(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);

				КонецЕсли;

			КонецЕсли;

			ПредставлениеДанных = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "ПредставлениеДанных");
			// Восстановим данные замещаемой страницы.
			СтруктураДанныхСтраницыЗамена = СтрТаблицаСтраницыЗамена.Данные;

			Для Каждого Элемент Из СтруктураДанныхСтраницыЗамена Цикл
				ИмяПоказателя      = Элемент.Ключ;
				ЗначениеПоказателя = Элемент.Значение;

				Если ПредставлениеДанных Тогда
					Если Форма.ОбновитьПеременныеМодуля(ИмяПоказателя, ЗначениеПоказателя) Тогда
						Продолжить; // Пропустим цикл
					КонецЕсли;
				КонецЕсли;

				//Если Форма.мСтараяВерсияФормы <> Форма.мВерсияФормы Тогда

					Попытка
						ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
					Исключение
					КонецПопытки;

				//Иначе
				//	ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
				//КонецЕсли;

			КонецЦикла;
			
			СтрТаблицаСтраницыЗамена.АктивнаяСтраница = Истина;
		КонецЕсли;

		Форма.Расчет(ИмяТекущейСтраницыПанели);
//		ТекущийЭлемент     = ТекТабличноеПоле;
		Форма.Модифицированность = Истина;
	КонецЕсли;

	// Вывод в квадратики, того, что хранилось в переменных
	Если роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "ПредставлениеДанных") Тогда
		Форма.ЗаполнениеЗначенийВКвадратиках(ИмяТекущейСтраницыПанели);
	КонецЕсли;

	роПоказатьСтатикСтраницРаздела(Форма, ИмяТекущейСтраницыПанели);

КонецПроцедуры // роУдалитьДополнительнуюСтраницу()

// роПоказательВходитВМногострочнуюЧасть
//
// Функция определяем, входит ли переданный показатель в многострочную часть
// Параметры:
// ИмяПоказателя - строка, имя показателя
//
// Возврат:
// 0 - показатель не входит в многострочный блок
// >0 кол-во строк в многострочной части
//
Функция роПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя) Экспорт

	ИмяГруппы = Лев(ИмяПоказателя, 11);

	СтруктураГруппы = Неопределено;

	Если НЕ Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
		Возврат 0;
	Иначе
		Возврат СтруктураГруппы.Количество();
	КонецЕсли;

КонецФункции // роПоказательВходитВМногострочнуюЧасть

// роЗаполнитьЭлементыФормыДляСистемыАвтоЗаполнения
//
// Процедура считывает св-ва всех разделов и если раздел является автозаполняемым, то добавляется 3 параметра в элементы форм
//
Процедура роЗаполнитьЭлементыФормыДляСистемыАвтоЗаполнения(Форма) Экспорт

	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл
		// Считываем название раздела и его свойство в системе автозаполнения
		НазваниеСтраницы = СтрокаУровня1.ИмяСтраницы;
		АвтоЗаполнение   = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если АвтоЗаполнение Тогда

			Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения" + НазваниеСтраницы].СписокВыбора.Добавить(1, "не заполнять автоматически");
			Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения" + НазваниеСтраницы].СписокВыбора.Добавить(2, "заполнять автоматически с корректировкой");
			Форма.ЭлементыФормы["ПолеВыбораВариантЗаполнения" + НазваниеСтраницы].СписокВыбора.Добавить(3, "заполнять автоматически без корректировки");

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // роЗаполнитьЭлементыФормыДляСистемыАвтоЗаполнения

// Функция роЯвляетсяЧислом(Значение)
// Если передено число - то истина, иначе ложь
//
Функция роЯвляетсяЧислом(Значение) Экспорт

	Если ТипЗнч(Значение) = Тип("Число") Тогда

		Возврат Истина

	Иначе

		Попытка
			Р = Число(Значение);
		Исключение
			Возврат Ложь;
		КонецПопытки;
			Возврат Истина;

	КонецЕсли;

КонецФункции // роЯвляетсяЧислом(Значение)

// Функция роЯвляетсяДатой(Знач Значение)
// является ли передаваемое значение датой или нет
//
Функция роЯвляетсяДатой(Знач Значение) Экспорт

	Если ТипЗнч(Значение) = Тип("Дата") Тогда
		Возврат Истина;
	КонецЕсли;

	Попытка
	Р = Дата(Значение);
	Исключение
	Возврат Ложь;
	КонецПопытки;
	Возврат Истина;
КонецФункции // функция роЯвляетсяДатой(Знач Значение)

// Функция роКолвоЛистоВРазделе(ИмяСтраницыПанели)
// Получает количество листов в табличном документе, ориентируясь на параметр НомСтр
//
// Параметры:
// ИмяСтраницыПанели                    - имя страницы
//
// Возврат:
// Количество страниц в табличном документе
//
Функция роКолвоЛистоВРазделе(Форма, ИмяСтраницыПанели) Экспорт

	ФлагИскл = 0;
	КолЛистовВОдномерномЛисте = 1;

	ТекТаблПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяСтраницыПанели];

	Пока ФлагИскл = 0 Цикл

		Если КолЛистовВОдномерномЛисте = 1 Тогда
			КолЛистовВОдномерномЛистеСтр = "";
		Иначе
			КолЛистовВОдномерномЛистеСтр = Формат(Число(КолЛистовВОдномерномЛисте)) + "_";
		КонецЕсли;

		Если ТекТаблПоле.Области.Найти("НомСтр" + КолЛистовВОдномерномЛистеСтр + "1") <> Неопределено Тогда

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте + 1;

		Иначе

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте - 1;
			ФлагИскл = 1;

		КонецЕсли;

	КонецЦикла;// пока искл = 0

	Возврат КолЛистовВОдномерномЛисте;

КонецФункции // роКолвоЛистоВРазделе(ИмяСтраницыПанели)

// ПроставитьВКвадратыЗначения
// Процедура проставляет переданное ей значение в необходимый лист
// декларации. Нельзя использовать в декларации Прибыль иностранной организации
// т.е. там своя процедура, проставляющая символ "равно" после вывода значения.
//
// Параметры:
//  Форма          - ссылка на форму отчета
//  Показатель     - показатель, смысловая его часть
//  Размерность    - кол-во символов и кол-во квадратиков на листе декларации
//  Значение       - непосредственно значение
//  ДополнитьЗначение - если переданное значение является числом, которое необходимо
//               округлять и производить другие действия, как с числом, то этому па-
//               раметру необходимо присвоить Истина, иначе во всех случаях Ложь.
//
Процедура роПроставитьВКвадратыЗначения(Форма, Знач Лист, Знач Показатель, Знач Размерность, Знач Значение, ДополнитьЗначение = Ложь) Экспорт

	Раздел = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + СтрЗаменить(Лист, "ПолеТабличногоДокумента", "")];

	ДопРазряд = ""; // дополнительный разряд в счетчике
	ТестОк = Истина;

	// Логика осталась от прошлого, в случае именования ячеек с ведущем нулем
	// например: КБК_01, КБК_02 и т.д.
	Если Раздел.Области.Найти(Показатель + ДопРазряд + "1") = Неопределено Тогда
		ТестОк = Ложь;
	КонецЕсли;

	Если НЕ ТестОк Тогда
		Если ДопРазряд = "0" Тогда
			ДопРазряд = "";
		Иначе
			ДопРазряд = "0";
		КонецЕсли;
	КонецЕсли;

	СтрокаФорматаЯчейки = СтрЗаменить(Форма.мСтрокаФормата, "; ЧН=-", "");
	// Убираем пробелы между группами разрядов числа
	СтрокаФорматаЯчейки = СтрокаФорматаЯчейки + "; ЧГ=0";

	Если (ДополнитьЗначение) Или ((роЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

		Если ((роЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

			ЗначениеДопСтрока = ДополнитьСтроку("", Размерность," ");

		Иначе

			ЗначениеДопСтрока = Формат(Значение, СтрокаФорматаЯчейки);
			ЗначениеДопСтрока = ДополнитьСтроку(ЗначениеДопСтрока, Размерность," ");

		КонецЕсли;

	Иначе

		ЗначениеДопСтрока = Значение;

	КонецЕсли; // ДополнитьЗначение

	ДопЗначение = 0;

	Для НомЯчейки = 1 По Размерность Цикл

		// Конструкция Попытка/Исключение/КонецПопытки добавлена, т.к. в декларациях по алкогольной
		// продукции 2006 не на всех листах есть ИНН/КПП, а установка этих показателей производится
		// централизовано через роЗаполнитьАвто где нет возможности обходить не нужные для заполнения
		// листы.
		Попытка
			Раздел.Области[Показатель + ?(СтрДлина(НомЯчейки) = 1, ДопРазряд + НомЯчейки, НомЯчейки)].Значение = Сред(ЗначениеДопСтрока, НомЯчейки, 1);
		Исключение
		КонецПопытки;

	КонецЦикла;

КонецПроцедуры // ПроставитьВКвадратыЗначения(Лист, Показатель, Размерность, Значение)

// Функция проверяет вхождение области ячеек табличного документа 
// в многострочный раздел.
//
// Параметры:
//  Форма          - ссылка на форму отчета.
//  ТекущаяОбласть - область ячеек табличного документа;
//
// Возвращаемое значение:
//  строка, имя раздела, содержащего искомую область ячеек.
//  В случае, когда область не входит ни в какой многострочный раздел,
//  возвращает Неопределено.
//
Функция роРазделТекущейОбласти(Форма, ТекущаяОбласть) Экспорт

	Если ТекущаяОбласть = Неопределено Тогда
		Возврат Неопределено; // отсутствует активная область табличного документа
	КонецЕсли;

	ИмяТекущейОбласти   = ТекущаяОбласть.Имя;
	ИмяАктивногоРаздела = Лев(ИмяТекущейОбласти, 13);

	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		СтруктураГруппы = ЭлементСтруктуры.Значение;

		Если СтруктураГруппы.Колонки.Найти(ИмяАктивногоРаздела) <> Неопределено Тогда
			Возврат ИмяГруппы;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции // роРазделТекущейОбласти()

// Функция ПолучитьСмысловуюЧастьИмениЯчейки
// возвращает смысловую часть ячейки
// полезно, если ячейка является квадратом значения
// если Определение = Истина - получитьСмысловуюЧасть, иначе - Получить счетчик, то что после "_"
//
// Параметры:
//  ИмяЯчейки      - название ячейки, строка.
//  Определение    - что необходимо вернуть, Истина - смысловую часть, Ложь - индекс.
//
// Возвращаемое значение:
//  Строка - смысловая часть или индекс
//
Функция роПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Определение = Истина) Экспорт

	Для Инд = 1 По СтрДлина(ИмяЯчейки) Цикл
		// последний разделитель
		// не пользуемся тут функцией Найти, т.к. разделителей может быть много в одной ячейки, пример ИНН_1_1
		Если Инд >= 4 Тогда
			// считаем, что эта ячейка не многоквадратная и выходим
			Возврат "";
		КонецЕсли;
		
		СимволСтроки = Сред(ИмяЯчейки,СтрДлина(ИмяЯчейки) - Инд + 1 ,1);

		Если СимволСтроки = "_" Тогда 
		// встретился знак "_" считаем его разделителем
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли; // Сред

		Если НЕ роЯвляетсяЧислом(СимволСтроки) Тогда
		// встретилась буква разделить
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли; // Сред
	КонецЦикла;

	СмысловаяЧасть = Сред(ИмяЯчейки, 1, АдресПоследнегоРазделителя); // возвращаем ВМЕСТЕ с разделителем
	// Получаем текущий счетчик
	ТекущийСчетчик = Сред(ИмяЯчейки, АдресПоследнегоРазделителя + 1, СтрДлина(ИмяЯчейки) - АдресПоследнегоРазделителя);

	Если Определение Тогда
		Возврат СмысловаяЧасть;
	Иначе
		Возврат ТекущийСчетчик;
	КонецЕсли;

КонецФункции // роПолучитьСмысловуюЧастьИмениЯчейки

// Процедура определяет алгоритм автозаполнения редактируемой ячейки по переданному коду
// показателя. Если у ячейки имеется признак автозаполнения, то ее значение формируется
// в соответствии с установленным алгоритмом.
//
// Параметры:
//   ИмяПоказателя      - строка, код показателя (имя ячейки);
//   ЗначениеПоказателя - устанавливаемое значение ячейки.
//
Процедура роУстановитьЗначениеПоказателя(Форма, ИмяПоказателя, Знач ЗначениеПоказателя) Экспорт

	Если (ИмяПоказателя = "П000030005003_1") Или (ИмяПоказателя = "П000030005003_2") Тогда
		// используются в ЕСН 2005г.
		ИмяСтраницыПанели = "Раздел3";
	Иначе
		ИмяСтраницыПанели = роОпределитьСтраницуПанелиПоКодуПоказателя(Форма, ИмяПоказателя);
	КонецЕсли;

	ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяСтраницыПанели);
	Если Не ТаблицаВариантыЗаполнения = Неопределено Тогда

		НайденнаяСтрока = ТаблицаВариантыЗаполнения.Найти(ИмяПоказателя, "КодПоказателя");
		Если НайденнаяСтрока <> Неопределено Тогда

			ВариантЗаполнения = НайденнаяСтрока.ВариантЗаполнения;

			// В случае, если предлагаемое значение не числовое и второй тип (с корректировкой)
			// тогда принимаем предложенное значение за 0.
			Если (НЕ роЯвляетсяЧислом(ЗначениеПоказателя)) И (ВариантЗаполнения = 2) Тогда
				ЗначениеПоказателя = 0;
			КонецЕсли;

			Если роЯвляетсяЧислом(ЗначениеПоказателя) Тогда
				НайденнаяСтрока.ЗначениеАвто = ЗначениеПоказателя;
			КонецЕсли;

			Если ВариантЗаполнения = 1 Тогда
				// заполняется только вручную
				Возврат;
			ИначеЕсли ВариантЗаполнения = 2 Тогда
				// автоматически, с возможностью ручной корректировки
				Дельта             = НайденнаяСтрока.Дельта;
				ЗначениеПоказателя = ЗначениеПоказателя + Дельта;
			КонецЕсли;

		КонецЕсли;
	КонецЕсли;

	Попытка
		Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяСтраницыПанели].Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
	Исключение
	КонецПопытки;

КонецПроцедуры // УстановитьЗначениеПоказателя()

// Функция определяет страницу основной панели формы, на которой табличный документ
// содержит показатель по переданному параметром "КодПоказателя" коду.
//
// Параметры:
//  Форма         - ссылка на форму отчета.
//  КодПоказателя - строка, код показателя.
//  РежимРаботы   - для специфических случаев, когда функция в разных отчетах была разной.
//
// Возвращаемое значение:
//  строка, имя найденной страницы основной панели формы.
//  Если страница не найдена, возвращает Неопределено.
//
Функция роОпределитьСтраницуПанелиПоКодуПоказателя(Форма, КодПоказателя) Экспорт
	Перем ИмяСтраницы;

	Попытка
		ПоляПоиска = Форма.мПоляПоискаПоказателяВТСП;
	Исключение
		ПоляПоиска = "КодПоказателяПоСоставу, КодПоказателяПоФорме";
	КонецПопытки;

	НайденнаяСтрока = Форма.мТаблицаСоставПоказателей.Найти(КодПоказателя, ПоляПоиска);
	Если НайденнаяСтрока <> Неопределено Тогда
		ИмяСтраницы = НайденнаяСтрока.ИмяПоляТаблДокумента;
	КонецЕсли;

	Возврат ИмяСтраницы;

КонецФункции // ОпределитьСтраницуПанелиПоКодуПоказателя()

// Управляет видимостью страниц основной панели формы.
// Параметры:
//  Форма          - ссылка на форму отчета.
//
Процедура роПоказатьСтраницыОтчета(Форма) Экспорт

	Если ТипЗнч(Форма.мДеревоВыбранныхСтраниц) <> Тип("ДеревоЗначений") Тогда
		Возврат;
	КонецЕсли;

	ИмеютсяСкрытые      = Ложь;
	СтруктураПараметров = Новый Структура;

	Для Каждого СтрокаУровня1 Из Форма.мДеревоВыбранныхСтраниц.Строки Цикл

		ИмяСтраницыПанели  = СтрокаУровня1.ИмяСтраницы;
		ПоказатьСтраницу   = СтрокаУровня1.ПоказатьСтраницу;

		Если ПоказатьСтраницу = 0 Тогда
			Форма.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяСтраницыПанели].Видимость = Ложь;
			ИмеютсяСкрытые = Истина;
		Иначе
			Форма.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяСтраницыПанели].Видимость = Истина;

		КонецЕсли;

	КонецЦикла;

	// обновляем исходное дерево значений 
	Форма.мДеревоСтраницОтчета = Форма.мДеревоВыбранныхСтраниц.Скопировать();

	КнопкиНастройки = Форма.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.КнопкаНастройкаСтраниц;
	ИсходныйТекст   = "Настройка";

	КнопкиНастройки.Текст = ИсходныйТекст;

	Если ИмеютсяСкрытые Тогда
		// Выводим в названии кнопки "Настройка страниц" доп. сммвол '*'.
		КнопкиНастройки.Текст = ИсходныйТекст + " (*)";
	КонецЕсли;

КонецПроцедуры // роПоказатьСтраницыОтчета()

// ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст
// Функция возвращает текст, который выводится в сообщении во всех общих формах.
// Возвращаемое значение:
//  Строка для вывода в Сообщить
//
Функция ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст() Экспорт

	Возврат "Не выбрана организация.";

КонецФункции // ОсновнаяФормаОрганизацияНеЗаполненаВывестиТекст

// роПриИзмененииВидаДокументаИКорректировки
// Процедура управляем показателями ВидДок и НомКоррект на титульных листах деклараций.
// Запускается из обработчика "ПриИзменении"
// Параметры:
//  Форма           - ссылка на форму
//  РазделДокумента - элементуправления, табличная часть отчета. Например мТитульный
//  ВидДок          - строка, название на листе, если есть ВидДок
//  НомКоррект      - строка, название на листе, если есть НомерКорректировки
//
Процедура роПриИзмененииВидаДокументаИКорректировки(Форма, РазделДокумента = Неопределено, ВидДок = Неопределено, НомКоррект = Неопределено) Экспорт

	ВыбранКорректирующийВидДок = (Форма.ВидДокумента = 1);
	Если РазделДокумента <> Неопределено Тогда

		Если ВидДок <> Неопределено Тогда
			РазделДокумента.Области[ВидДок].Значение = ?(ВыбранКорректирующийВидДок, "3", "1");
		КонецЕсли;

		Если НомКоррект <> Неопределено Тогда
			РазделДокумента.Области[НомКоррект].Значение = Форма.НомерКорректировки;

			Если НЕ ВыбранКорректирующийВидДок Тогда
				РазделДокумента.Области[НомКоррект].Значение = "";
			Иначе
				РазделДокумента.Области[НомКоррект].Значение = Форма.НомерКорректировки;
			КонецЕсли;

		КонецЕсли;
	КонецЕсли;

	Форма.ЭлементыФормы.НомерКорректировки.Доступность = ВыбранКорректирующийВидДок;

КонецПроцедуры // роПриИзмененииВидаДокументаИКорректировки

// роДоступностьКнопокДобавитьУдалить
// Процедура управляет доступностью кнопок "Добавить" и "Удалить" формы.
// 
Процедура роДоступностьКнопокДобавитьУдалить(Форма, ТекущаяОбласть = Неопределено, ИмяТекущейСтраницыПанели = Неопределено) Экспорт

	Если ИмяТекущейСтраницыПанели = Неопределено Тогда
		ТекущаяСтраницаПанели    = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница;
		ИмяТекущейСтраницыПанели = ТекущаяСтраницаПанели.Имя;
	КонецЕсли;

	Если Не ТекущаяОбласть = Неопределено Тогда
		КнопкаДобавить = Форма.ЭлементыФормы.Найти("КнопкаДобавитьДопСтроки" + ИмяТекущейСтраницыПанели);
		КнопкаУдалить = Форма.ЭлементыФормы.Найти("КнопкаУдалитьДопСтроки" + ИмяТекущейСтраницыПанели);

		Если КнопкаДобавить <> Неопределено И КнопкаУдалить <> Неопределено Тогда
			Если роРазделТекущейОбласти(Форма, ТекущаяОбласть ) = Неопределено Тогда
				КнопкаДобавить.Доступность = Ложь;
				КнопкаУдалить.Доступность = Ложь;
			Иначе
				КнопкаДобавить.Доступность = Истина;
				КнопкаУдалить.Доступность = Истина;
			КонецЕсли;
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // роДоступностьКнопокДобавитьУдалить()

// роПриАктивизацииОбластиРегламентированногоОтчета
//
Процедура роПриАктивизацииОбластиРегламентированногоОтчета(Форма, Элемент, ИмяТекущейСтраницыПанели = Неопределено) Экспорт

	// Для некоторых форм переменная мСтруктураВзаимныхПереходов не объявлена, поэтому
	// следующий блок сделаем через Попытку/Исключение
	// Не обязательно, что форма снабжена данным механизмом обхода номеров страниц.
	Попытка
		Если Найти(Элемент.ТекущаяОбласть.Имя, "НомСтр") > 0 Тогда
			Если ТипЗнч(Форма.мСтруктураВзаимныхПереходов) = Тип("Структура") Тогда
				// Перед очисткой структуры сохраним имя нужной области для переходов.
				ИмяНужнойОбластиДляПереходов = Форма.мСтруктураВзаимныхПереходов.ИмяНужнойОбластиДляПереходов;
				// Снимем флаг, присвоев Неопределено структуре взаимных переходов.
				Форма.мСтруктураВзаимныхПереходов = Неопределено;
				ТекТабличноеПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница.Имя];
				ТекТабличноеПоле.ТекущаяОбласть = ТекТабличноеПоле.Области[ИмяНужнойОбластиДляПереходов];
			КонецЕсли;
		ИначеЕсли (ТипЗнч(Форма.мСтруктураВзаимныхПереходов) = Тип("Структура"))
		   И (Элемент.ТекущаяОбласть.Имя <> Форма.мСтруктураВзаимныхПереходов.ИмяОткудаПереход) Тогда
			Форма.мСтруктураВзаимныхПереходов = Неопределено;
		КонецЕсли;
	Исключение
	КонецПопытки;

	Если ИмяТекущейСтраницыПанели = Неопределено Тогда
		ИмяТекущейСтраницыПанели = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница.Имя;
	КонецЕсли;

	КолвоМногострочныхБлоков = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");
	Если ТипЗнч(КолвоМногострочныхБлоков) = Тип("ТаблицаЗначений") Тогда
		КолвоМногострочныхБлоков = КолвоМногострочныхБлоков.Количество();
	КонецЕсли;
	Если КолвоМногострочныхБлоков > 0 Тогда

		ТекущаяОбласть = Элемент.ТекущаяОбласть;
		роДоступностьКнопокДобавитьУдалить(Форма, ТекущаяОбласть, ИмяТекущейСтраницыПанели);

	КонецЕсли;

	Если роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "РазделЯвляетсяАвтозаполняемым") Тогда

		роВывестиЭлементыВариантаЗаполнения(Форма, Элемент.ТекущаяОбласть);

	КонецЕсли;

КонецПроцедуры // роПриАктивизацииОбластиРегламентированногоОтчета

// роПриВыбореОбластиРегламентированногоОтчета
//
Функция ВыбраннаяОбластьРегламентированногоОтчетаНеВерна(Область, СтандартнаяОбработка) Экспорт
	// Попытка сделана для того, чтобы в случае выделения нескольких ячеек (даже случайно)
	// не возникала ошибка
	Попытка
		Если (Область.Защита)
		 Или (Найти(Область.Имя, "R") >0)
		 Или (Найти(Область.Имя, "C") >0) Тогда
			СтандартнаяОбработка = Ложь;
			Возврат Истина;
		КонецЕсли;
	Исключение
		СтандартнаяОбработка = Ложь;
		Возврат Истина;
	КонецПопытки;

	Возврат Ложь; // Выбранная область не выделение.

КонецФункции // роПриВыбореОбластиРегламентированногоОтчета

// Функция роОбластьЯвляетсяЯчейкойСоставногоПоля
// проверяет, является ли переданное имя ячейки частью многоКвадратной
// группы ячеек на листе
// если да - то истина, иначе - Ложь
//
Функция роОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки, БыстраяПроверка = Истина) Экспорт

		СмысловаяЧасть = роПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
		Если СмысловаяЧасть = "" Тогда
			// не квадратичная ячейка
			Возврат Ложь;
		КонецЕсли;

		Если БыстраяПроверка Тогда
			Возврат Истина;
		КонецЕсли;

		ИмяСтраницыПанели = роОпределитьСтраницуПанелиПоКодуПоказателя(Форма, ИмяЯчейки);
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ПолеТабличногоДокумента" + ИмяСтраницыПанели;

		// Получаем текущий счетчик
		//ТекущийСчетчик = Сред(ИмяЯчейки,АдресПоследнегоРазделителя+1,СтрДлина(ИмяЯчейки)-АдресПоследнегоРазделителя);
		ТекущийСчетчик = роПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки,Ложь);
		Если СтрДлина(ТекущийСчетчик) >= 2 Тогда

			Если Сред(ТекущийСчетчик, 1, 1) = "0" Тогда
				ПризнакСчетчикаСнулемВпереди = Истина;
			Иначе
				ПризнакСчетчикаСнулемВпереди = Ложь;
			КонецЕсли;
		Иначе
			ПризнакСчетчикаСнулемВпереди = Ложь; // перед счетчиком нет нуля
		КонецЕсли;

		Если роЯвляетсяЧислом(ТекущийСчетчик) Тогда
			ТекущийСчетчикЦел = ТекущийСчетчик;
		Иначе
			Возврат Ложь;
		КонецЕсли;

		Координата = СмысловаяЧасть + ?(ПризнакСчетчикаСнулемВпереди = Истина,"0" + Строка(ТекущийСчетчикЦел + 1),ТекущийСчетчикЦел + 1);

		Если Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области.Найти(Координата) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		// значение получено
		Возврат Истина;

КонецФункции // роОбластьЯвляетсяЯчейкойСоставногоПоля

// роСвойстваГрупповыхЗначений
// Процедура управляет показателями на форме оформленные как в квадратных значениях
// Имя Ячейки всегда должно быть первой в квадратичном представлении
// Параметры:
//  Форма          - ссылка на форму
//  ИмяЯчейки      - имя ячейки
//  Операция       - название производимой операции
//  ЦветФона       - цвет фона
//  ИмяСтраницы    - имя страницы
//
Процедура роСвойстваГрупповыхЗначений (Форма, ИмяЯчейки, Операция, ЦветФона = Неопределено, ИмяСтраницы = Неопределено) Экспорт

	Если ИмяСтраницы = Неопределено Тогда
		ИмяСтраницыПанели = роОпределитьСтраницуПанелиПоКодуПоказателя(Форма, ИмяЯчейки);
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;
	Иначе
		ИмяСтраницыПанели = ИмяСтраницы;
	КонецЕсли;

	ИмяПоляТаблДокумента = "ПолеТабличногоДокумента" + ИмяСтраницыПанели;

	СмысловаяЧасть = роПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
	Если СмысловаяЧасть = "" Тогда
	// не групповая ячейка
		Возврат;
	КонецЕсли;
	ТекущийСчетчик = роПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Ложь);
	ТекущийСчетчикЦел = Число(ТекущийСчетчик);
	МожноРаботать = Истина;
	Пока МожноРаботать Цикл
		Координата = СмысловаяЧасть + Строка(ТекущийСчетчикЦел);

		Если Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области.Найти(Координата) <> Неопределено Тогда
			Попытка
				Если Операция = "УстановитьЗащиту" Тогда
					Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[Координата].Защита = Истина;
				КонецЕсли;

				Если Операция = "СнятьЗащиту" Тогда
					Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[Координата].Защита = Ложь;
				КонецЕсли;

				Если Операция = "ПроставитьЦветРаскраски" Тогда
					Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[Координата].ЦветФона = ЦветФона;
				КонецЕсли;

				Если Операция = "Очистить" Тогда
					Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[Координата].Значение = "";
				КонецЕсли;

				ТекущийСчетчикЦел = ТекущийСчетчикЦел + 1; // работаем со следующей ячейкой

			Исключение
				МожноРаботать = Ложь; // далее нет ячеек многоквадратного значения
				Прервать;
			КонецПопытки;

		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла; // Пока

КонецПроцедуры // роСвойстваГрупповыхЗначений

//Процедура роИзменитьТаблицуВариантовЗаполнения
// Изменяет всем признак корректировки ячеей на 1
// если 1 - то вернем всё к ЭТАЛОНу
// если 0 - то вернем все ячейки к желтому цвету, доступных для редактирования
//
// Логика процедуры изменена: процедура работает только с показателями, с признаком
// автозаполнения равным 4.
// Для использования в декларациях необходимо соблюсти следующие требования:
// 1. Процедуры получения таблицы вариантов заполнения либо не должно быть либо она должна использовать
// только вызов роФУНКЦИИ получения таблицы, не более.
// 2. УстановитьЦветФона - должна быть объявленной как Экспортная.
// 3. Не должно быть процедуры ПолучитьКоличествоСтраницРаздела
//
Процедура роИзменитьТаблицуВариантовЗаполнения(Форма, ПолныйРучнойВвод = Ложь) Экспорт

	Перем МассивВариантовЗаполненияСтраниц;
	мДеревоСтраницОтчета = Форма.мДеревоСтраницОтчета;
	ПереборЗнач = мДеревоСтраницОтчета.Строки.Количество();

	Пока ПереборЗнач > 0 цикл
		ИмяСтраницы = мДеревоСтраницОтчета.Строки[ПереборЗнач-1].ИмяСтраницы;
		ПереборЗнач = ПереборЗнач-1;
		// а если это многостраничный раздел?
		КолСтрВРазделе = роПолучитьКоличествоСтраницРаздела(Форма, ИмяСтраницы); // кол-во страниц в разделе
		// ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяСтраницы, ПолныйРучнойВвод);
		// Всегда получим актуальную таблицу заполнения. Не эталонную.
		ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяСтраницы);

		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ПолныйРучнойВвод Тогда
			// Если раздел многостраничный, то нужно насквозь все обнулять !!!

			Если КолСтрВРазделе = 1 Тогда

				Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
					Если Строка.ВариантЗаполнения = 4 Тогда
						Строка.ВариантЗаполнения = 0; // полный ручной ввод
					КонецЕсли;
				КонецЦикла; // Для Каждого Строка Из

				//МассивВариантовЗаполненияСтраниц = Новый Массив;
				//МассивВариантовЗаполненияСтраниц.Добавить(ТаблицаВариантыЗаполнения);
				//Форма.мСтруктураВариантыЗаполнения.Вставить(ИмяСтраницы, МассивВариантовЗаполненияСтраниц);

				Форма.УстановитьЦветФонаЯчейки(,,ИмяСтраницы);
			КонецЕсли; // КолСтрВРазделе = 1 Иначе // если многостраничный раздел
			
			Если КолСтрВРазделе >= 2 Тогда

				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				Для Инд = 0 по МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд] Цикл
						Если Строка.ВариантЗаполнения = 4 Тогда
							Строка.ВариантЗаполнения = 0; // полный ручной ввод
						КонецЕсли; // ВариантЗаполнения <> 0 
					КонецЦикла; // Для каждого
				КонецЦикла; // Для
				Форма.УстановитьЦветФонаЯчейки(,,ИмяСтраницы); // текущую обновим
			КонецЕсли; // КолСтрВРазделе >= 2

		ИначеЕсли ПолныйРучнойВвод Тогда

			// Всё в эталонном виде
			Если КолСтрВРазделе = 1 Тогда
				Для Каждого Стр Из ТаблицаВариантыЗаполнения Цикл
					Если Стр.ВариантЗаполнения = 0 Тогда
						Стр.ВариантЗаполнения = 4
					КонецЕсли;
				КонецЦикла;

				//МассивВариантовЗаполненияСтраниц = Новый Массив;
				//МассивВариантовЗаполненияСтраниц.Добавить(ТаблицаВариантыЗаполнения);
				//Форма.мСтруктураВариантыЗаполнения.Вставить(ИмяСтраницы, МассивВариантовЗаполненияСтраниц);

				Форма.УстановитьЦветФонаЯчейки(,,ИмяСтраницы);

			КонецЕсли; // если одна страница в разделе

			Если КолСтрВРазделе >= 2 Тогда
				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				Для Инд = 0 по МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					// МассивВариантовЗаполненияСтраниц1[Инд].Добавить(ТаблицаВариантыЗаполнения);
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд] Цикл
						Если Строка.ВариантЗаполнения = 0 Тогда
							//НайденнаяСтрокаК = ТаблицаВариантыЗаполнения.Найти(Строка.КодПоказателя, "КодПоказателя");
							Строка.ВариантЗаполнения = 4; // полный автоматический ввод
						КонецЕсли; // ВариантЗаполнения <> 0 
					КонецЦикла; // Для каждого

				КонецЦикла; // Для

				// мСтруктураВариантыЗаполнения.Вставить(ИмяСтраницы, МассивВариантовЗаполненияСтраниц1);
				Форма.УстановитьЦветФонаЯчейки(,,ИмяСтраницы); // текущую обновим

			КонецЕсли; // если более 1 страница в разделе

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // Процедура роИзменитьТаблицуВариантовЗаполнения(ПолныйРучнойВвод = 0)

//ПолучитьКоличествоСтраницРаздела(ИмяТекущейСтраницыПанели)
// Возвращает кол-во страниц для любых многостраничных разделов
// если лист без доп. страниц, Тогда 1
//
Функция роПолучитьКоличествоСтраницРаздела(Форма, ИмяТекущейСтраницыПанели) Экспорт
Перем ТаблицаСтраницРаздела;

	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат 1;
	КонецЕсли;

	КоличествоСтраниц    = Макс(ТаблицаСтраницРаздела.Количество(), 1);
	Возврат КоличествоСтраниц;
КонецФункции // ПолучитьКоличествоСтраницРаздела(ИмяТекущейСтраницыПанели)

// роОчиститьВариантыЗаполнения
// Процедура выполняет очистку структуры мСтруктураВариантовЗаполнения.
// Создается новый массив с ЭТАЛОННЫМ вариантом заполнения показателей, затем
// этот массив записывается в структуру.
// Параметры:
//  Форма          - ссылка на форму декларации (ЭтаФорма)
//  Раздел         - по умолчанию Неопределено - для всех разделов, можно указать конкретный.
//
Процедура роОчиститьВариантыЗаполнения(Форма, Знач Раздел = Неопределено) Экспорт

	Перем МассивВариантовЗаполненияСтраниц;

	// Данная процедура используется только в новых декларациях, где установлены показатели Е как 14.2
	// Через процеудру УстановитьФормат

	мОписаниеТиповЧислоЕ = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(14, 2));
	ИзмененияЕсть = Ложь;
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл
		// Считываем название раздела и его свойство в системе автозаполнения
		НазваниеСтраницы = СтрокаУровня1.ИмяСтраницы;
		Если Раздел <> Неопределено Тогда
			Если Раздел <> НазваниеСтраницы Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		//АвтоЗаполнение   = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если Форма.мСтруктураВариантыЗаполнения.Свойство(НазваниеСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
			// Получим ЭТАЛОННЫЙ макет вариантов показателей.
			ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, НазваниеСтраницы, Истина, мОписаниеТиповЧислоЕ);

			// Суда подпадают Титульные, ФизЛица и др.
			Если ТаблицаВариантыЗаполнения <> Неопределено Тогда

				// Объявим новый массив
				МассивВариантовЗаполненияСтраниц = Новый Массив;

				ТаблВариантов = ТаблицаВариантыЗаполнения.Скопировать();
				// Вставим в массив эталонный вариант.
				МассивВариантовЗаполненияСтраниц.Добавить(ТаблВариантов);
				Форма.мСтруктураВариантыЗаполнения.Вставить(НазваниеСтраницы, МассивВариантовЗаполненияСтраниц);
				ИзмененияЕсть = Истина;

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если ИзмененияЕсть И Форма.ФлажокОтклАвтоРасчет Тогда
			роИзменитьТаблицуВариантовЗаполнения(Форма, НЕ Форма.ФлажокОтклАвтоРасчет);
	КонецЕсли;

КонецПроцедуры // роОчиститьВариантыЗаполнения

// ВернутьЗначениеСЛиста
// Функция возвращает значения с табличного поля
// Параметры:
//  Форма          - ссылка на форму
//  СтраницаПанели - название страницы панели или раздела декларации
//  ОсновнаяЧасть  - основная часть показателя
// Возвращаемое значение:
//  Текстовое значение, считанное с указанного параметра на листе декларации
//
Функция роВернутьЗначениеПараметраСЛиста(Форма, СтраницаПанели, ОсновнаяЧасть) Экспорт

	ТекОбласть = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + СтраницаПанели];
	ТекИндекс = 1;

	Результат = "";
	Пока ТекОбласть.Области.Найти(ОсновнаяЧасть + Строка(ТекИндекс)) <> Неопределено Цикл
		Результат = Результат + ТекОбласть.Области[ОсновнаяЧасть + Строка(ТекИндекс)].Значение;
		ТекИндекс = ТекИндекс + 1;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ВернутьЗначениеСЛиста

// ВернутьЛогическийЗнакВСтроке
// Функция анализирует формулу и находит знак сравнения.
// Параметры:
//  Формула              - Формула разбора.
// Возвращаемое значение:
//   Структура, содержащая ключи ПеречислениеВидСравнения и СтрокаСравнения
//  ВернутьПеречисление  - Булево, если Истина, то возвращаемое значение перечисление, иначе строка знака.
//
Функция ВернутьЛогическийЗнакВСтроке(Знач Формула) Экспорт

	Пока Найти(Формула, "[") > 0 Цикл
		СкобкаОтк = Найти(Формула, "[");
		СкобкаЗак = Найти(Формула, "]");
		Скобка = Сред(Формула, СкобкаОтк, СкобкаЗак - СкобкаОтк + 1);
		Формула = СтрЗаменить(Формула, Скобка, "");
	КонецЦикла;

	Если Найти(Формула, ">=") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.БольшеИлиРавно, ">=");
	ИначеЕсли Найти(Формула, "<=") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.МеньшеИлиРавно, "<=");
	ИначеЕсли Найти(Формула, "<>") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.НеРавно, "<>");
	ИначеЕсли Найти(Формула, "=") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.Равно, "=");
	ИначеЕсли Найти(Формула, ">") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.Больше, ">");
	ИначеЕсли Найти(Формула, "<") > 0 Тогда
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", ВидСравнения.Меньше, "<");
	Иначе
		Возврат Новый Структура("ПеречислениеВидСравнения, СтрокаСравнения", Неопределено, Неопределено);
	КонецЕсли;

КонецФункции // ВернутьЛогическийЗнакВСтроке

// СтандратныеОперацииПоУстановкамМасок
//
Процедура СтандратныеОперацииПоУстановкамМасок(Форма) Экспорт

	мТитульный = Форма.ЭлементыФормы.ПолеТабличногоДокументаТитульный;

	Счетчик = 1;
	// Установим маски для титульного листа отчета, где есть области СоставленаНа
	Пока мТитульный.Области.Найти("СоставленаНа" + Формат(Счетчик, "ЧГ=0")) <> Неопределено Цикл
		мТитульный.Области["СоставленаНа" + Формат(Счетчик, "ЧГ=0")].ЭлементУправления.Маска = "9";
		Счетчик = Счетчик + 1;
	КонецЦикла;

	Счетчик = 1;
	// Установим маски для титульного листа отчета, где есть области Прил
	Пока мТитульный.Области.Найти("Прил" + Формат(Счетчик, "ЧГ=0")) <> Неопределено Цикл
		мТитульный.Области["Прил" + Формат(Счетчик, "ЧГ=0")].ЭлементУправления.Маска = "9";
		Счетчик = Счетчик + 1;
	КонецЦикла;

	// Установим маски для кода ИМНС.
	Счетчик = 1;
	// Установим маски для титульного листа отчета, где есть области Прил
	Пока мТитульный.Области.Найти("КодИМНС" + Формат(Счетчик, "ЧГ=0")) <> Неопределено Цикл
		мТитульный.Области["КодИМНС" + Формат(Счетчик, "ЧГ=0")].ЭлементУправления.Маска = "9";
		Счетчик = Счетчик + 1;
	КонецЦикла;

	// Для деклараций по животному миру и водным биоресурсам.
	Счетчик = 1;
	Пока мТитульный.Области.Найти("ПорядковыйНом" + Формат(Счетчик, "ЧГ=0")) <> Неопределено Цикл
		мТитульный.Области["ПорядковыйНом" + Формат(Счетчик, "ЧГ=0")].ЭлементУправления.Маска = "9";
		Счетчик = Счетчик + 1;
	КонецЦикла;

	// Установим маску для НомСтр
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.Строки Цикл
		ИмяСтраницы = СтрокаУровня1.ИмяСтраницы;
		КоличествоЛистов = роКолвоЛистоВРазделе(Форма, ИмяСтраницы);

		Для Инд = 1 По КоличествоЛистов Цикл

			Счетчик = 1;
			ПрефиксЛист = ?(Инд = 1, "", Формат(Инд, "ЧГ=0") + "_");
			ОбластьОбращения = "НомСтр" + ПрефиксЛист + Формат(Счетчик, "ЧГ=0");

			Пока Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяСтраницы].Области.Найти(ОбластьОбращения) <> Неопределено Цикл
				Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяСтраницы].Области[ОбластьОбращения].ЭлементУправления.Маска = "9";
				Счетчик = Счетчик + 1;
				ОбластьОбращения = "НомСтр" + ПрефиксЛист + Формат(Счетчик, "ЧГ=0");
			КонецЦикла;

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // СтандратныеОперацииПоУстановкамМасок

// ИмпортДанныхРегламентированнойОтчетностиИзКонтейнераXML
// Функция осуществляет разбор файла XML, учитываются все данные отчета, разделы, доп. листы и т.д.
// Параметры:
//  ИмяФайла       - имя файла XML. Не проверяется на наличие!
// Возвращаемое значение:
//  Структура, содержащая данные отчета по каждому разделу. В случае, если файл не правильного формата
//  или произошла какая-либо ошибка - возвращаемое значение Неопределено.
//
Функция ИмпортДанныхРегламентированнойОтчетностиИзКонтейнераXML(ИмяФайла) Экспорт

	// Объявим структуру узла СведенияОтчета
	СведенияОтчета = Новый Структура;
	СведенияОтчета.Вставить("НаименованиеОтчета", Неопределено);
	СведенияОтчета.Вставить("КНД", Неопределено);
	СведенияОтчета.Вставить("Периодичность", Неопределено);
	СведенияОтчета.Вставить("Период", Неопределено);
	СведенияОтчета.Вставить("ИНН", Неопределено);
	СведенияОтчета.Вставить("КПП", Неопределено);
	// СведенияОтчета.Вставить("ЕдИзм", Неопределено);
	// СведенияОтчета.Вставить("Точность", Неопределено);
	СведенияОтчета.Вставить("НомерКорректировки", Неопределено);
	СведенияОтчета.Вставить("ДатаПодписания", Неопределено);

	ТаблицаРаздела = Новый ТаблицаЗначений;
	ТаблицаРаздела.Колонки.Добавить("Данные");
	ТаблицаРаздела.Колонки.Добавить("Раздел", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(100)));

	ЧтениеXML = Новый ЧтениеXML;
	Попытка
		ЧтениеXML.ОткрытьФайл(ИмяФайла);
	Исключение
		Возврат Неопределено; // Ошибка
	КонецПопытки;

	Счетчик = 0;
	СчитаныПоказатели = Ложь;

	ДанныеИмпорта = Новый Структура;

	Пока ЧтениеXML.Прочитать() Цикл
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Узел = ЧтениеXML.Имя;
			Если Узел = "ДанныеРегламентированнойОтчетности" Тогда
				
			ИначеЕсли Узел = "РегламентированныйОтчет" Тогда
				Счетчик = Счетчик + 1;
				НачатыйУзел = "РегламентированныйОтчет" + Формат(Счетчик, "ЧГ=0");

			ИначеЕсли Узел = "СведенияОтчета" Тогда
				СведенияОтчетаРузультат = Новый Структура;
				Для каждого Элемент Из СведенияОтчета Цикл
					СведенияОтчетаРузультат.Вставить(Элемент.Ключ, ЧтениеXML.ПолучитьАтрибут(Элемент.Ключ));
				КонецЦикла;
			Иначе

				НайденнаяСтрока = ТаблицаРаздела.Найти(Узел, "Раздел");
				Если НайденнаяСтрока <> Неопределено Тогда
				// Уже есть экземпляр раздела
					НовСтр = НайденнаяСтрока.Данные.Добавить();
					НовСтр.СтруктураДанных = СобратьДанныеИзXMLУзла(ЧтениеXML);
				Иначе
					// Запишем результат в таблицу
					ТаблицаДанных = Новый ТаблицаЗначений;
					ТаблицаДанных.Колонки.Добавить("СтруктураДанных");
					НовСтрТаблицаДанных = ТаблицаДанных.Добавить();
					НовСтрТаблицаДанных.СтруктураДанных = СобратьДанныеИзXMLУзла(ЧтениеXML);

					НовСтр = ТаблицаРаздела.Добавить();
					НовСтр.Раздел = Узел;
					НовСтр.Данные = ТаблицаДанных.Скопировать();
				КонецЕсли;

			КонецЕсли;
		ИначеЕсли (ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента) И (ЧтениеXML.Имя = "РегламентированныйОтчет") Тогда

			Результат = Новый Структура;
			Результат.Вставить("ДанныеРазделовОтчета", ТаблицаРаздела.Скопировать());
			Результат.Вставить("СведенияОтчета", ПолучитьКопиюСтруктуры(СведенияОтчетаРузультат));
			ДанныеИмпорта.Вставить(НачатыйУзел, Результат);
			ТаблицаРаздела.Очистить();

		КонецЕсли;
	КонецЦикла;

	ЧтениеXML.Закрыть();
	Возврат ДанныеИмпорта;

КонецФункции // ИмпортДанныхРегламентированнойОтчетностиИзКонтейнераXML

// ПолучитьКопиюСтруктуры
//
Функция ПолучитьКопиюСтруктуры(Знач СтруктураРезультата)
	Результат = Новый Структура;
	Для Каждого Стр Из СтруктураРезультата Цикл
		Результат.Вставить(Стр.Ключ, Стр.Значение);
	КонецЦикла;
	Возврат Результат;
КонецФункции // ПолучитьКопиюСтруктуры

// СобратьДанныеИзXMLУзла
//
Функция СобратьДанныеИзXMLУзла(ЧтениеXML)

	Результат = Новый Структура;
	Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
		Показатель = ЧтениеXML.Имя;
		Значение = ЧтениеXML.Значение;
		Результат.Вставить(Показатель, Значение);
	КонецЦикла;

	Возврат Результат;

КонецФункции // СобратьДанныеИзXMLУзла

// ПолучитьДанныеРегламентированнойОтчетностиЭтогоОтчета
//
Функция ПолучитьДанныеРегламентированнойОтчетностиЭтогоОтчета(ДанныеКонтейнера, СтруктураИдентификацииДанных, УчитыватьПериодичность = Истина) Экспорт

	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("НазваниеОтчета");
	Результат.Колонки.Добавить("ДанныеОтчета");

	Для каждого Отчет Из ДанныеКонтейнера Цикл

		// Проверка на заполненность данных.
		Если Отчет.Значение.СведенияОтчета.КНД = Неопределено
		Или Отчет.Значение.СведенияОтчета.Период = Неопределено
		Или Отчет.Значение.СведенияОтчета.Периодичность = Неопределено
		Или Отчет.Значение.СведенияОтчета.ИНН = Неопределено
		Или Отчет.Значение.СведенияОтчета.КПП = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		// Проверка на подходящие данные.
		Если СокрЛП(Отчет.Значение.СведенияОтчета.ИНН) <> СокрЛП(СтруктураИдентификацииДанных.ИНН)
		 Или СокрЛП(Отчет.Значение.СведенияОтчета.КПП) <> СокрЛП(СтруктураИдентификацииДанных.КПП) Тогда
			Продолжить;
		КонецЕсли;

		Если СокрЛП(Отчет.Значение.СведенияОтчета.КНД) <> СокрЛП(СтруктураИдентификацииДанных.КНД) Тогда
			Продолжить;
		КонецЕсли;

		Если УчитыватьПериодичность Тогда
			Если СокрЛП(Отчет.Значение.СведенияОтчета.Периодичность) <> СокрЛП(СтруктураИдентификацииДанных.Периодичность) Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если СокрЛП(Отчет.Значение.СведенияОтчета.Период) <> СокрЛП(СтруктураИдентификацииДанных.Период) Тогда
			Продолжить;
		КонецЕсли;

		НовСтр = Результат.Добавить();
		НовСтр.НазваниеОтчета = Отчет.Значение.СведенияОтчета.НаименованиеОтчета;
		НовСтр.ДанныеОтчета = ПолучитьКопиюСтруктуры(Отчет.Значение);

	КонецЦикла;

	Если Результат.Количество() = 0 Тогда
		// Нет необходимого отчета.
		Возврат Неопределено;
	КонецЕсли;

	Если Результат.Количество() = 1 Тогда
		Возврат Результат[0].ДанныеОтчета;
	КонецЕсли;

	// Если в контейнере более 1 однотипного отчета, полностью одинаковых, то предоставим выбор пользователю.
	ВспомогательнаяТабл = Результат.Скопировать();
	ВспомогательнаяТабл.Колонки.Удалить("ДанныеОтчета");
	ВыбранныйОтчет = ВспомогательнаяТабл.ВыбратьСтроку("Выбор необходимого отчета");
	Если ВыбранныйОтчет = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	Инд = ВспомогательнаяТабл.Индекс(ВыбранныйОтчет);
	Возврат Результат[Инд];

КонецФункции // ПолучитьДанныеРегламентированнойОтчетностиЭтогоОтчета

// ВернутьСтруктуруТочногоОтбораДанныхИзКонтейнераXML
//
Функция ВернутьСтруктуруТочногоОтбораДанныхИзКонтейнераXML(Форма) Экспорт

	Результат = Новый Структура("Периодичность, ЕдИзм", "0", "383");
	Результат.Вставить("КНД", Форма.мКодОтчета);
	Результат.Вставить("ИНН", Форма.Организация.ИНН);
	Результат.Вставить("КПП", Форма.Организация.КПП);
	Результат.Вставить("Период", Формат(Форма.мДатаНачалаПериодаОтчета, "ДФ=дд.ММ.гггг") + "," + Формат(Форма.мДатаКонцаПериодаОтчета, "ДФ=дд.ММ.гггг"));

	ИдКонф = ИдКонфигурации();
	Если Форма.мПериодичность = Перечисления.Периодичность.Месяц Тогда
		Результат.Периодичность = "1";
	ИначеЕсли Форма.мПериодичность = Перечисления.Периодичность.Квартал Тогда
		Результат.Периодичность = "2";
	// Для БП и ЗУП - полугодие отсутствует. Обработаем.
	ИначеЕсли (НЕ ((ИдКонф = "БП") Или (ИдКонф = "ЗУП"))) И (Форма.мПериодичность = Перечисления.Периодичность.Полугодие) Тогда
		Результат.Периодичность = "3";
	ИначеЕсли Форма.мПериодичность = Перечисления.Периодичность.Год Тогда
		Результат.Периодичность = "4";
	КонецЕсли;

	Возврат Результат;

КонецФункции // ВернутьСтруктуруТочногоОтбораДанныхИзКонтейнераXML

// ПроверитьКонтрольныеСоотношенияВОтчете
//
//  Форма             - Ссылка на форму отчета
//  СохраненныйДок    - объект документа рег. отчетность
//  ВызовИзЦУО        - признак вызова процедуры проверки из ЦУО - Истина, Ложь из декларации
//  ВыводитьСообщение - в случае запуска процедуры из-под отчета, если ошибок не обнаружено, то этот флаг позволяет задавать вопрос
//                 и предложение о просмотре формы контрольных соотношений.
//
Процедура ПроверитьКонтрольныеСоотношенияВОтчете(Форма, СохраненныйДок, ВызовИзЦУО, ВыводитьСообщение = Ложь) Экспорт

	// Проверим, открыта ли уже форма.
	Если НЕ ВызовИзЦУО Тогда
		Если Обработки.РегламентированнаяОтчетностьСоотношенияПоказателей.ПолучитьФорму().Открыта() Тогда
			Обработки.РегламентированнаяОтчетностьСоотношенияПоказателей.ПолучитьФорму().Закрыть();
		КонецЕсли;

		Если Форма.Модифицированность и Вопрос("Перед проверкой отчета требуется сохранить введеную информацию." + Символы.ПС + "Продолжить?",РежимДиалогаВопрос.ДаНет)<>КодВозвратаДиалога.Да Тогда
			Возврат;
		КонецЕсли;

		Если Форма.Модифицированность И (НЕ Форма.Сохранить()) Тогда
			Возврат;
		КонецЕсли;

		ОбработкаКС = ПолучитьОбработкуОшибокКонтрольныхСоотношений(Форма, СохраненныйДок);

		Если ОбработкаКС.мТаблицаОшибокКС.Количество() > 0 Тогда
			// Если есть ошибки - отобразим список.
			ОбработкаКС.ПолучитьФорму().Показать();
		Иначе

			Если ВыводитьСообщение Тогда
				Если Вопрос("В отчете не обнаружены ошибки по соотношениям показателей.
					| Вывести форму для просмотра соотношений?",РежимДиалогаВопрос.ДаНет,,КодВозвратаДиалога.Да) = КодВозвратаДиалога.Да Тогда

					// Отобразим ошибки. Осуществим пересбор данных, отобразим все записи, при снятом флаге "Только ошибки".
					ОбработкаКС.ПолучитьФорму().Показать(Истина);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

	Иначе
		// Если вызывается при печати из ЦУО
		ОбработкаКС = ПолучитьОбработкуОшибокКонтрольныхСоотношений(Форма, СохраненныйДок);
		Если ОбработкаКС.мТаблицаОшибокКС.Количество() > 0 Тогда
			Сообщить("В отчете " + ПредставлениеДокументаРеглОтч(СохраненныйДОк.Ссылка) + Символы.ПС + 
			         "обнаружены ошибки при проверки соотношений показателей. Откройте отчет и проверьте его на наличие ошибок.", СтатусСообщения.ОченьВажное);
		КонецЕсли;

	КонецЕсли;

КонецПроцедуры // ПроверитьКонтрольныеСоотношенияВОтчете

// ПолучитьОбработкуОшибокКонтрольныхСоотношений
//
Функция ПолучитьОбработкуОшибокКонтрольныхСоотношений(Форма, СохраненныйДок)
	// Создадим обработчик контрольных соотношений
	Обраб = Обработки.РегламентированнаяОтчетностьСоотношенияПоказателей.Создать();
	Обраб.СохраненныйДокумент = СохраненныйДок;
	Обраб.Форма = Форма;

	// Сформируем ошибки не выводя их на экран.
	Обраб.ПолучитьФорму().Сформировать(Ложь);
	Возврат Обраб;

КонецФункции // ПолучитьОбработкуОшибокКонтрольныхСоотношений


// ВыбратьИУстановитьТерриториальныйОрганФНС
// Процедура позволяет организовать выбор из справочника РегистрацияВИФНС
// и установит КПП, наименование ИФНС в декларации.
//
// Параметры:
//  Форма          - ссылка на форму отчета
//  СтандартнаяОбработка - параметр из обработчика ввода
//  ИмяТитульногоЛиста - имя титульного листа
//
Процедура ВыбратьИУстановитьТерриториальныйОрганФНС(Форма, СтандартнаяОбработка, ИмяТитульногоЛиста) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Владелец", Форма.Организация);
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	СправочникИФНС.КПП,
	               |	СправочникИФНС.Код КАК КодНО,
	               |	СправочникИФНС.НаименованиеИФНС КАК Наименование
	               |ИЗ
	               |Справочник.РегистрацияВИФНС КАК СправочникИФНС
	               |ГДЕ
	               |СправочникИФНС.Владелец = &Владелец";

	ТаблИнспекций = Новый ТаблицаЗначений();
	ТаблИнспекций.Колонки.Добавить("КПП",,, 10);
	ТаблИнспекций.Колонки.Добавить("КодНО",,, 5);
	ТаблИнспекций.Колонки.Добавить("Наименование",,, 55);

	НовСтр = ТаблИнспекций.Добавить();
	НовСтр.КодНО = "";
	НовСтр.Наименование = "Пустое значение";
	НовСтр.КПП = "";

	СправочникИФНС = Запрос.Выполнить().Выгрузить();
	ОбщегоНазначения.ЗагрузитьВТаблицуЗначений(СправочникИФНС, ТаблИнспекций);

	мТитульный = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТитульногоЛиста];
	ПервоначЗначение = роВернутьЗначениеПараметраСЛиста(Форма, ИмяТитульногоЛиста, "КодИМНС");

	Если ТаблИнспекций.Количество() > 1 Тогда

		СтандартнаяОбработка = Ложь;

		НайденнаяСтрока = ТаблИнспекций.Найти(ПервоначЗначение, "КодНО");
		Если НайденнаяСтрока = Неопределено Тогда
			Результат = ТаблИнспекций.ВыбратьСтроку("Выбор ИФНС");
		Иначе
			Результат = ТаблИнспекций.ВыбратьСтроку("Выбор ИФНС", НайденнаяСтрока);
		КонецЕсли;

		СтандартнаяОбработка = Ложь;
		Если Результат <> Неопределено Тогда

			Форма.Модифицированность = Истина;
			Если Результат.Получить(2) <> "Пустое значение" Тогда

				роПроставитьВКвадратыЗначения(Форма, ИмяТитульногоЛиста, "КодИМНС", 4, Результат.Получить(1));
				мТитульный.Области.ОргИМНС.Значение = Результат.Получить(2);
				// Если есть в декларации лист ФизЛиц, тогда считаем ФИО на листе, если оно пустое, то КПП на листе Ф.Л. не проставляем.
				ЛистФЛЕсть = роПолучитьСвойствоРаздела(Форма, "ФизЛица", "МногострочностьВРазделе") <> Неопределено;
				ЛистФЛ = "";
				Если ЛистФЛЕсть Тогда
					Попытка
						ФИОФЛ = Форма.ЭлементыФормы.ПолеТабличногоДокументаФизЛица.Области.ФизЛицФИО.Значение;
						Если ПустаяСтрока(ФИОФЛ) Тогда
							// Если на листе нет ФИО, значит лист не заполняем, пропускае простановку КПП.
							ЛистФЛ = "ФизЛица";
						КонецЕсли;
					Исключение
					КонецПопытки;
				КонецЕсли;

				роПроставитьНаВсехЛистах(Форма, Результат.Получить(0), "КПП", ЛистФЛ);

			Иначе
				роПроставитьВКвадратыЗначения(Форма, ИмяТитульногоЛиста, "КодИМНС", 4, "");
				мТитульный.Области.ОргИМНС.Значение = "";
				роПроставитьНаВсехЛистах(Форма, "         ", "КПП");

			КонецЕсли;
		КонецЕсли;
	Иначе
		СтандартнаяОбработка = Ложь;
		Если ПустаяСтрока(ПервоначЗначение) Тогда
			Сообщить("Код налогового органа необходимо указать в справочнике ""Организации"".", СтатусСообщения.Информация);
		Иначе
			Сообщить("Для выбора инспекции, необходимо завести соответствующую запись в справочнике ""Регистрация в ИФНС"".", СтатусСообщения.Информация);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ВыбратьИУстановитьТерриториальныйОрганФНС

// УстановитьПримечаниеНаТитульныхЛистахГруппыАлкогольныхДеклараций
// Процедура устанавливает необходимые примечания в ячейках ТипОрг1 и ТипОрг2
// в алкогольных декларациях 2006кв3.
//
Процедура УстановитьПримечаниеНаТитульныхЛистахГруппыАлкогольныхДеклараций(Форма) Экспорт
	// Сохраним текущий активный экземпляр листа.
	роСохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, "Титульный", Ложь);

	НомерАктивнойСтраницы = Форма.мСтруктураМногостраничныхРазделов.Титульный.Найти(Истина, "АктивнаяСтраница");
	Ном = Форма.мСтруктураМногостраничныхРазделов.Титульный.Индекс(НомерАктивнойСтраницы);

	мТитульный = Форма.ЭлементыФормы["ПолеТабличногоДокументаТитульный"];

	Если Форма.ДокПредстРО Тогда
		ТекстПрим = "с учетом обособленных подразделений";
	Иначе
		ТекстПрим = "без учета обособленных подразделений";
	КонецЕсли;

	Если Форма.мСтруктураМногостраничныхРазделов.Титульный[0].Данные.ТипОрг1 = "V" Тогда
		мТитульный.Области.ДопИнфо1.Значение = ТекстПрим;
		Форма.ЭлементыФормы.ДокПредстРО.Видимость = Истина;

	ИначеЕсли (Форма.мСтруктураМногостраничныхРазделов.Титульный[0].Данные.ТипОрг2 = "V")
	      Или (Форма.мСтруктураМногостраничныхРазделов.Титульный[0].Данные.ТипОрг2 <> "V") Тогда

		// Если декларация открыта не организацией и не обособленным подразделением(или обособленным), то скроем флаг и очистим все примечания.
		мТитульный.Области.ДопИнфо1.Значение = "";

		Форма.ЭлементыФормы.ДокПредстРО.Видимость = Ложь;
		Форма.ДокПредстРО = Ложь; // Снимем флаг

	КонецЕсли;

	Если Ном > 0 Тогда
		ТекстПризнак = мТитульный.Области.ДопИнфо1.Значение;
		Форма.мСтруктураМногостраничныхРазделов.Титульный[0].Данные.Вставить("ДопИнфо1", ТекстПризнак);
		мТитульный.Области.ДопИнфо1.Значение = "";
	КонецЕсли;

КонецПроцедуры // УстановитьПримечаниеНаТитульныхЛистахГруппыАлкогольныхДеклараций

// ПолучитьСтруктуруТаблицыРО
// Функция получает таблицу значений со структурой ТаблицаИсточник.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, на основе которой нужно сделать новую таблицу
//
// Возвращаемое значение:
//  Пустая таблица значений, со структурой из таблицы источника.
//
Функция ПолучитьСтруктуруТаблицыРО(ТаблицаИсточник) Экспорт

	Результат = Новый ТаблицаЗначений;
	Для каждого Стр Из ТаблицаИсточник.Колонки Цикл
		Результат.Колонки.Добавить(Стр.Имя, Стр.ТипЗначения);
	КонецЦикла;
	Возврат Результат;

КонецФункции // ПолучитьСтруктуруТаблицыРО

// ПолучитьКварталРО
// Получает номер квартала
//
// Параметры:
// ЗаданнаяДата - дата или номер месяца.
//
// Возврат - номер квартала
//
Функция ПолучитьКварталРО(ЗаданнаяДата) Экспорт
	Если ТипЗнч(ЗаданнаяДата) = Тип("Дата") Тогда
		Возврат Месяц(КонецКвартала(ЗаданнаяДата)) / 3;
	ИначеЕсли ТипЗнч(ЗаданнаяДата) = Тип("Число") Тогда
		Возврат Цел((ЗаданнаяДата - 1) / 3) + 1;
	КонецЕсли;
КонецФункции // ПолучитьКварталРО

// ПолучитьНазваниеРегОтчетаПоДатамДействия
//
Функция ПолучитьНазваниеРегОтчетаПоДатамДействия(Форма) Экспорт

	ИтоговоеКоличество = 0;

	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ОбщегоНазначения.ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			// В случае, если две формы действуют в один период, то название должно быть одинаковое и берется первое из таблицы настроек.
			Возврат ЭлФорма.НаименованиеОтчета;

		КонецЕсли;

	КонецЦикла;

	Возврат Форма.Представление();

КонецФункции // ПолучитьНазваниеРегОтчетаПоДатамДействия

// ПолучитьТаблицуМногостраничногоРаздела
// Параметров нет.
// Возвращаемое значение:
//  ТаблицаЗначений, эталонная таблица многостраничного раздела, с одним экземпляром и активной страницей.
//
Функция ПолучитьТаблицуМногостраничногоРаздела() Экспорт
	ОписаниеТиповСтрока254 = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(254));

	МассивБулево = Новый Массив;
	МассивБулево.Добавить(Тип("Булево"));
	мОписаниеТиповБулево    = Новый ОписаниеТипов(МассивБулево);

	ТаблицаСтраницыРаздела            = Новый ТаблицаЗначений;
	ТаблицаСтраницыРаздела.Колонки.Добавить("Представление",    ОписаниеТиповСтрока254, "Наименование");
	ТаблицаСтраницыРаздела.Колонки.Добавить("АктивнаяСтраница", мОписаниеТиповБулево);
	ТаблицаСтраницыРаздела.Колонки.Добавить("Данные");
	ТаблицаСтраницыРаздела.Колонки.Добавить("АвтоматическоеПредставление", мОписаниеТиповБулево);

	СтрПерваяСтраница = ТаблицаСтраницыРаздела.Добавить();
	СтрПерваяСтраница.Представление      = "Новая страница";
	СтрПерваяСтраница.АктивнаяСтраница   = Истина;
	СтрПерваяСтраница.АвтоматическоеПредставление = Истина;
	Возврат ТаблицаСтраницыРаздела;

КонецФункции // ПолучитьТаблицуМногостраничногоРаздела

// ВвестиЗначениеПоказателяРеглОтчета
//
// Параметры:
//  Форма
//  Раздел
//  ИмяЯчейкиВывода - имя ячейки, куда необходимо выводить результат
//  ПервоначальноеЗначение - первоначальное значение выбора
//  РазмерностьЦ - размерность целой части, если строка, то размерность для строки кол-во символов
//  РазмерностьД - размерность дробной части, если строка - то не имеет значения
//  ЭтоСумма - Булево, определяет, что работать со значением следует как с суммой (округлять и т.д.)
//
//  ТекстВвода
//  ТекстВыбора
//
//  ТаблицаВыбора - таблица значений, список для выбора. Если Неопределено, значит выбор не обрабатывается.
//  СтрокаВводаИзТаблицы - Строка. Если "" (пусто), тогда стандартный текст, если Неопределено, тогда не позволять, иначе - текст.
//  КолонкаПоиска - По умолчанию "Код". Строка имя колонки для поиска в таблице значений (список возможных значений).
//  КолВоКвадратиков - кол-во предусмотренных квадратиков на форме, для показателя
//  СтруктураТребованийРучногоВвода - структура с ключами: СтрокаТолькоИзЧисел, КонтролируемаяДлинаСтроки, проверка ручного ввода.
//
// Возвращаемое значение:
//  Структура, ключи:
//      ЗначениеВведено - булево, введено Истина, отказ Ложь
//      ЗначениеВведеноЧерезВыбор - Истина, если осуществлен выбор, Ложь если введено руками
//      Значение - результат ввода
//
Функция ВвестиЗначениеПоказателяРеглОтчета(Форма, Знач Раздел, Знач ИмяЯчейкиВывода, Знач ПервоначальноеЗначение, Знач РазмерностьЦ, Знач РазмерностьД, Знач ЭтоСумма, Знач ТекстВвода, Знач ТекстВыбора, ТаблицаВыбора, Знач СтрокаВводаИзТаблицы, СтандартнаяОбработка, Знач КолвоКвадратиков = Неопределено, КолонкаПоиска = "Код", СтруктураТребованийРучногоВвода = Неопределено) Экспорт

	Перем НачальноеЗнач;
	СтандартнаяОбработка = Ложь;
	Результат = Новый Структура();
	Результат.Вставить("ЗначениеВведено", Ложь);
	Результат.Вставить("ЗначениеВведеноЧерезВыбор", Неопределено);
	Результат.Вставить("Значение", Неопределено);
	НачальноеЗнач = ПервоначальноеЗначение;

	РучнойВвод = Ложь;
	Значение = Неопределено; // Вводимое значение.

	Если (НЕ Форма.мАвтоВыборКодов) И (ТаблицаВыбора <> Неопределено) Тогда
	// Если ТаблицаВыбора <> Неопределено Тогда

		НайденнаяСтрока = ТаблицаВыбора.Найти(ПервоначальноеЗначение, КолонкаПоиска);

		// Обеспечим ввод из таблицы значений.
		Если СтрокаВводаИзТаблицы <> Неопределено Тогда
			НовСтр = ТаблицаВыбора.Добавить();
			// НовСтр.Код = ?(ПустаяСтрока(ПервоначальноеЗначение), "", ПервоначальноеЗначение);
			НовСтр.Код = "";
			НовСтр.Название = СтрокаВводаИзТаблицы;
			ТаблицаВыбора.Сдвинуть(ТаблицаВыбора.Количество() - 1, (-1) * (ТаблицаВыбора.Количество() - 2));
		КонецЕсли;

		Если НайденнаяСтрока = Неопределено Тогда
			Выб = ТаблицаВыбора.ВыбратьСтроку(ТекстВыбора);
		Иначе
			Выб = ТаблицаВыбора.ВыбратьСтроку(ТекстВыбора, НайденнаяСтрока);
		КонецЕсли;

		Если Выб = Неопределено Тогда
			Возврат Результат;
		КонецЕсли;

		Если (ТаблицаВыбора.Индекс(Выб) = 1) И (СтрокаВводаИзТаблицы <> Неопределено) Тогда
			РучнойВвод = Истина;
		Иначе
			// Получим значение по колонке поиска.
			Значение = Выб.Получить(ТаблицаВыбора.Колонки.Индекс(ТаблицаВыбора.Колонки.Найти(КолонкаПоиска)));
			Результат.ЗначениеВведеноЧерезВыбор = Истина;
		КонецЕсли;

	Иначе
		РучнойВвод = Истина;
	КонецЕсли;

	Если РучнойВвод Тогда
		Если ТипЗнч(ПервоначальноеЗначение) = Тип("Строка") Тогда
			Вводить = Истина;

			МеханизмВводаИНН = Ложь;
			МеханизмВводаКПП = Ложь;
			Пока Вводить Цикл

				Если НЕ ВвестиСтроку(ПервоначальноеЗначение, ТекстВвода, РазмерностьЦ) Тогда
					Возврат Результат;
				КонецЕсли;

				Если Найти(ТекстВвода, "ОКАТО") > 0 Тогда
					ПроверкаВвода = Истина;
					КритичнаяДлина = РазмерностьЦ;
					ТекстКонтроля = "Код ОКАТО должен состоять из 11 цифр.";
				ИначеЕсли (Найти(ТекстВвода, " КБК") > 0) Тогда
					ПроверкаВвода = Истина;
					КритичнаяДлина = РазмерностьЦ;
					ТекстКонтроля = "КБК должен состоять из 20-ти цифр.";
				ИначеЕсли МеханизмВводаИНН Тогда
				ИначеЕсли МеханизмВводаКПП Тогда
				Иначе
					ПроверкаВвода = Ложь;
				КонецЕсли;

				Если ПроверкаВвода Тогда
					Если (ПервоначальноеЗначение = "") Или (ОбщегоНазначения.ТолькоЦифрыВСтроке(ПервоначальноеЗначение)) И (СтрДлина(ПервоначальноеЗначение) = КритичнаяДлина) Тогда
						Вводить = Ложь;
					Иначе
						Сообщить(ТекстКонтроля, СтатусСообщения.Важное);
					КонецЕсли;
				Иначе
					Вводить = Ложь;
					Если СтруктураТребованийРучногоВвода <> Неопределено Тогда
						// Задан режим проверки ручного ввода.
						Если (СтруктураТребованийРучногоВвода.СтрокаТолькоИзЧисел) И (НЕ ОбщегоНазначения.ТолькоЦифрыВСтроке(ПервоначальноеЗначение)) Тогда
							Сообщить("Введенное значение должно состоять только из цифр.", СтатусСообщения.Важное);
							Вводить = Истина;
						ИначеЕсли (СтруктураТребованийРучногоВвода.Свойство("КонтролируемаяДлинаСтроки")) И 
						          (СтруктураТребованийРучногоВвода.КонтролируемаяДлинаСтроки <> СтрДлина(ПервоначальноеЗначение)) И
						          (НЕ ПустаяСтрока(ПервоначальноеЗначение)) Тогда
							Сообщить("Введенное значение должно состоять из " + Строка(СтруктураТребованийРучногоВвода.КонтролируемаяДлинаСтроки) + " символов.", СтатусСообщения.Важное);
							Вводить = Истина;

						КонецЕсли;
					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

		ИначеЕсли ТипЗнч(ПервоначальноеЗначение) = Тип("Число") Тогда
			Вводить = Истина;
			Пока Вводить Цикл

				Если НЕ ВвестиЧисло(ПервоначальноеЗначение, ТекстВвода, РазмерностьЦ, РазмерностьД) Тогда
					Возврат Результат;
				КонецЕсли;

				ПервоначальноеЗначениеСтр = Формат(ПервоначальноеЗначение, "ЧГ=0");
				Если СтрДлина(ПервоначальноеЗначениеСтр) > КолВоКвадратиков Тогда
					Сообщить("Введенное значение нельзя отобразить в отчете.", СтатусСообщения.Важное);
				Иначе
					Вводить = Ложь;
				КонецЕсли;

			КонецЦикла;

		ИначеЕсли ТипЗнч(ПервоначальноеЗначение) = Тип("Дата") Тогда
			Если НЕ ВвестиДату(ПервоначальноеЗначение, ТекстВвода, ЧастиДаты.Дата) Тогда
				Возврат Результат;
			КонецЕсли;
			ПервоначальноеЗначение = Формат(ПервоначальноеЗначение, "ДФ='ддММгггг'");
		КонецЕсли;

		Значение = ПервоначальноеЗначение;
		Результат.Вставить("ЗначениеВведеноЧерезВыбор", Ложь);
	КонецЕсли;

	Результат.Вставить("ЗначениеВведено", Истина);

	Если НачальноеЗнач <> Значение Тогда
		Форма.Модифицированность = Истина;
	КонецЕсли;

	// Запись на лист.
	Результат.Значение = Значение;

	Если МеханизмВводаИНН = Истина Тогда
		// Удалим лидирующие нули, если есть.
		Если (СтрДлина(Значение) = КолВоКвадратиков) И (Сред(Значение, 1, 2) = "00") Тогда
			Результат.Значение = Сред(Значение, 3);
		КонецЕсли;
	КонецЕсли;

	Если КолВоКвадратиков = Неопределено Тогда
		Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Раздел].Области[ИмяЯчейкиВывода].Значение = Значение;
	Иначе
		роПроставитьВКвадратыЗначения(Форма, Раздел, ИмяЯчейкиВывода, ?(ЭтоСумма, КолВоКвадратиков, РазмерностьЦ), Значение, ЭтоСумма);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ВвестиЗначениеПоказателяРеглОтчета

// Процедура управляет цветом фона автозаполняемых ячеек при:
//  а) автозаполнении;
//  б) ручном выборе другого варианта заполнения;
//  в) добавлении/удалении и листании дополнительных страниц.
//
// Цвет фона устанавливается в зависимости от варианта заполнения ячейки.
//
// Параметры:
//  ИмяЯчейки                - строка, имя ячейки, для которой устанавливаем цвет фона;
//  ВариантЗаполнения        - число,  вариант заполнения ячейки;
//  ИмяТекущейСтраницыПанели - строка, имя страницы основной панели, на которой для всех автозаполняемых
//                             ячеек табличного документа следует установить цвет фона.
//
Процедура роУстановитьЦветФонаЯчейки(Форма, ИмяЯчейки = Неопределено, ВариантЗаполнения = Неопределено, ИмяТекущейСтраницыПанели = "") Экспорт
	Перем ЦветФона;
	Перем Комментарий;

	// Не нужно разукрашивать табличные поля, если открывается без открытия формы (например печать или просмотр)
	Если Форма.мБезОткрытияФормы Или Форма.мРежимПечати Тогда
		Возврат;
	КонецЕсли;

	Если Не ИмяЯчейки = Неопределено Тогда
		// устанавливаем цвет фона конкретной ячейки
		ИмяСтраницыПанели = роОпределитьСтраницуПанелиПоКодуПоказателя(Форма, ИмяЯчейки);
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ПолеТабличногоДокумента" + ИмяСтраницыПанели;

		Ключ = "_" + ВариантЗаполнения;
		Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

		// КодПоказателяПоСтруктуре
		ЗначениеВКвадратах = роОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки);

		Если ВариантЗаполнения = 4 Тогда

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				роСвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"УстановитьЗащиту");
			Иначе
				Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Истина;
			КонецЕсли;

		Иначе

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				роСвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"СнятьЗащиту");
			Иначе
				Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Ложь;
			КонецЕсли;
			
		КонецЕсли;

		// установим цвет ячейки
		Если ЗначениеВКвадратах Тогда
			роСвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"ПроставитьЦветРаскраски", ЦветФона);
		Иначе
			Форма.ЭлементыФормы[ИмяПоляТаблДокумента].Области[ИмяЯчейки].ЦветФона = ЦветФона;
		КонецЕсли;

	Иначе
		// устанавливаем цвет фона всех автозаполняемых ячеек активной страницы

		ТаблицаВариантыЗаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, ИмяТекущейСтраницыПанели);
		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Возврат;
		КонецЕсли;

		Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
			ИмяПоказателя            =  Строка.КодПоказателя;
			ВариантЗаполнения        =  Строка.ВариантЗаполнения;
			Комментарий              =  Строка.Комментарий;
			КодПоказателяПоСтруктуре =  Строка.КодПоказателяПоСтруктуре;

			КолвоСтрокВМногострочнойЧасти = роПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя);

			Если КолвоСтрокВМногострочнойЧасти > 0 Тогда
				Многострочность = Истина;
				БазоваяЧасть = ИмяПоказателя;
				ОписанияБлоков = роПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");

				Если ТипЗнч(ОписанияБлоков) = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ТипЗнч(ОписанияБлоков) = Тип("ТаблицаЗначений") Тогда
					ИмяГруппы = Сред(ИмяПоказателя, 1, 11);
					ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.Найти(ИмяГруппы, "ИдГруппы").НезаполняемыеПоказателиЕсть;
				КонецЕсли;

			Иначе
				Многострочность = Ложь;
				ВБлокеВсеПоказателиЗаполняются = Истина;
				КолвоСтрокВМногострочнойЧасти = 1;
			КонецЕсли;

			Для Инд = 1 по КолвоСтрокВМногострочнойЧасти Цикл

				Если Многострочность Тогда
					ИмяПоказателя = БазоваяЧасть + "_" + Формат(Инд, "ЧГ=0");
					// Декларация по НДС. В многострочном блоке встречаются строки, которые не должны быть закрашены в стандартный зеленый цвет.
					
				КонецЕсли;

				Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
					Если Форма.ЭтотПоказательНеЗаполняется(ИмяПоказателя) Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;

				ТекОбластьЯчеек = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели].Области[ИмяПоказателя];
				Если (Не ПустаяСтрока(Комментарий)) ИЛИ (Не ПустаяСтрока(ТекОбластьЯчеек.Примечание.Текст)) Тогда
					ТекОбластьЯчеек.Примечание.Текст = Комментарий;
				КонецЕсли;

				Ключ = "_" + ВариантЗаполнения;
				Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

				//ЗначениеВКвадратах = роОбластьЯвляетсяЯчейкойСоставногоПоля(ЭтаФорма, ИмяПоказателя);
				ЗначениеВКвадратах = ?(ПустаяСтрока(КодПоказателяПоСтруктуре), Ложь, Истина);

				Если ВариантЗаполнения = 4 Тогда
					//ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели].Области[ИмяПоказателя].Защита = Истина;

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						роСвойстваГрупповыхЗначений(Форма, ИмяПоказателя, "УстановитьЗащиту");
					Иначе
						Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели].Области[ИмяПоказателя].Защита = Истина;
					КонецЕсли;

				Иначе

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						роСвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"СнятьЗащиту");
					Иначе
						Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели].Области[ИмяПоказателя].Защита = Ложь;
					КонецЕсли;
				КонецЕсли;

				Если ЗначениеВКвадратах Тогда
					роСвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"ПроставитьЦветРаскраски", ЦветФона);
				Иначе
					Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяТекущейСтраницыПанели].Области[ИмяПоказателя].ЦветФона = ЦветФона;
				КонецЕсли;
			КонецЦикла;

		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // роУстановитьЦветФонаЯчейки()

// Процедура управляет представлением суммовых (денежных) показателей
// табличного документа при изменении размерности.
//
Процедура роУстановитьФорматВывода(Форма) Экспорт
	Перем СтруктураГруппы;
	Перем РазмерностьПрописьюТекст;

	ЕдиницаИзмерения = Форма.ЕдиницаИзмерения;
	ТочностьЕдиницыИзмерения = Форма.ТочностьЕдиницыИзмерения;
	Если ЕдиницаИзмерения = Перечисления.ПорядкиОкругленияОтчетности.Окр1 Тогда
		Форма.мДелитель = 1;
		РазмерностьПрописьюТекст = "в рублях";
		Форма.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 0";

	ИначеЕсли ЕдиницаИзмерения = Перечисления.ПорядкиОкругленияОтчетности.Окр1000 Тогда
		Форма.мДелитель = 1000;
		РазмерностьПрописьюТекст = "в тыс. рублей";
		Форма.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 3";
		
	ИначеЕсли ЕдиницаИзмерения = Перечисления.ПорядкиОкругленияОтчетности.Окр1000000 Тогда
		Форма.мДелитель = 1000000;
		РазмерностьПрописьюТекст = "в млн. рублей";
		Форма.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 6";
		
	КонецЕсли;

	ДанныеВСтруктуреПоРазделуОтражены = Ложь;

	ИмяПоляТаблДокументаСтароеЗначение = "";
	Для Каждого СтрПоказатели Из Форма.мТаблицаСоставПоказателей Цикл

		ИмяПоляТаблДокумента = СокрП(СтрПоказатели.ИмяПоляТаблДокумента);
		КодПоказателя        = СокрП(СтрПоказатели.КодПоказателяПоСоставу);
		ПризнМногострочность = СокрП(СтрПоказатели.ПризнМногострочности);
		КодПоказателяПоСтруктуре = СокрП(СтрПоказатели.КодПоказателяПоСтруктуре);
		КодПоказателяПоФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);

		Если ИмяПоляТаблДокументаСтароеЗначение <> ИмяПоляТаблДокумента Тогда
			// Обновим признак показа переменных из структуры.
			ДанныеВСтруктуреПоРазделуОтражены = Ложь;
		КонецЕсли;

		Если КодПоказателя = "===" Тогда
			Прервать;
		КонецЕсли;

		Если (Лев(КодПоказателя, 2) = "//") ИЛИ (КодПоказателя = "###") Тогда
			Продолжить;
		КонецЕсли;

		КодПоказателяВФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);

		ИмяПоказателя = КодПоказателя;
		Если Не ПустаяСтрока(КодПоказателяВФорме) Тогда
			ИмяПоказателя = КодПоказателяВФорме;
		КонецЕсли;

		ТипДанныхПоказателя = СокрП(СтрПоказатели.ТипДанныхПоказателя);

		Если (ТипДанныхПоказателя = "Е") И (НЕ ПустаяСтрока(КодПоказателяПоСтруктуре)) Тогда

			Если НЕ ДанныеВСтруктуреПоРазделуОтражены Тогда
				// Отобразим переменные структур.
				Форма.ЗаполнениеЗначенийВКвадратиках(СтрЗаменить(ИмяПоляТаблДокумента, "ПолеТабличногоДокумента", ""));

				// Возведем признак, что переменные отображены, для неотображения при проходе по следующей записи и показателя.
				ДанныеВСтруктуреПоРазделуОтражены = Истина;

			КонецЕсли;

			//Если ПризнМногострочность <> "/" Тогда
			//	Показатель = роПолучитьСмысловуюЧастьИмениЯчейки(КодПоказателяПоФорме);
			//	Раздел = ИмяПоляТаблДокумента;
			//	Значение = Форма.ПолучитьЗначениеКвадратногоЗначенияПоИмени(КодПоказателяПоСтруктуре);

			//	роПроставитьВКвадратыЗначения(Форма, Раздел, Показатель, 15, Значение, Истина);
			//Иначе
			//	// Случай для отчетов по акцизам, многострочность из квадратиков.
			//	
			//КонецЕсли;

		КонецЕсли;

		Если (ТипДанныхПоказателя = "Е") И (ПустаяСтрока(КодПоказателяПоСтруктуре)) Тогда

			ТекТабличноеПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ИмяПоляТаблДокумента];

			Если ПризнМногострочность <> "/" Тогда
				ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя];
				// Получим установленный в ячейки признак допустимого знака.
				ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

				ЧислоЕЗнак = Форма.мОписаниеТиповЧислоЕ;
				Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
					// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
					Массив = Новый Массив;
					Массив.Добавить(Тип("Число"));
					КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
					ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
				КонецЕсли;
				ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
				ФорматируемаяОбласть.Формат = Форма.мСтрокаФормата;
			Иначе
				// определяем кол-во строк многострочного раздела
				// и применяем процедуру форматирования к данной графе
				// по всем строкам
				ИмяГруппы = Лев(ИмяПоказателя, 11);
				Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
				ОписанияБлоков = роПолучитьСвойствоРаздела(Форма, ИмяПоляТаблДокумента, "МногострочностьВРазделе");
				ОписанияБлоковТип = ТипЗнч(ОписанияБлоков);
				Если ОписанияБлоковТип = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ОписанияБлоковТип = Тип("ТаблицаЗначений") Тогда
					ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.Найти(ИмяГруппы, "ИдГруппы").НезаполняемыеПоказателиЕсть;
				КонецЕсли;

				Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
					Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
						Если Форма.ЭтотПоказательНеЗаполняется(ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0")) Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;

					ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0")];
					// Получим установленный в ячейки признак допустимого знака.
					ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

					ЧислоЕЗнак = Форма.мОписаниеТиповЧислоЕ;
					Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
						// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
						Массив = Новый Массив;
						Массив.Добавить(Тип("Число"));
						КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
						ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
					КонецЕсли;

					ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
					ФорматируемаяОбласть.Формат = Форма.мСтрокаФормата;

				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		ИмяПоляТаблДокументаСтароеЗначение = ИмяПоляТаблДокумента;
	КонецЦикла;

КонецПроцедуры // роУстановитьФорматВывода()

// Создает новую строку многострочного раздела.
// Процедура вставляет строку в многострочный блок.
//
// Параметры:
//  Форма          - ссылка на форму отчета
//  ИмяГруппыБлока - имя группы, в том случае, если необходимо вставить строки в процедурах автозаполнения, без фокусировок.
//  СпециальноеДобавление - режим добавления строк по нестандартному алгоритму, когда в правой части распологаются данные.
//  ИмяКолонкиНомера - имя колонки, в которой необходимо проставлять номер при вставки строки.
//
Процедура роВставитьДополнительнуюСтроку(Форма, ИмяГруппыБлока = Неопределено, СпециальноеДобавление = Ложь, ИмяКолонкиНомера = Неопределено) Экспорт
	Перем СтруктураГруппы;
	Перем МаксимальноеКоличествоСтрокГруппы;

	Если ИмяГруппыБлока = Неопределено Тогда
		// Сначала выполним проверку на активную страницу панели формы,
		// которая содержит многострочный раздел
		ИмяГруппы = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтранице();
		Если ИмяГруппы = Неопределено Тогда
			Сообщить("Не выбран многострочный раздел, в который необходимо добавить строку.", СтатусСообщения.Внимание);
			Возврат;
		КонецЕсли;
	Иначе
		ИмяГруппы = ИмяГруппыБлока;
	КонецЕсли;

	// Исходное количество строк группы
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИмяГруппы, МаксимальноеКоличествоСтрокГруппы);

	ТекТабличноеПоле = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРаздела(ИмяГруппы);
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);

	// определяем последнюю строку многострочной группы
	КолСтрок = СтруктураГруппы.Количество();
	КолСтрокСтр = Формат(КолСтрок, "ЧГ=0");
	ИмяПервойЯчейкиПоследнейСтроки = СтруктураГруппы.Колонки[0].Имя + "_" + КолСтрокСтр;

	// область первой ячейки последней строки многострочного раздела
	ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПоследнейСтроки];

	// номера строк исходной области
	НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
	НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ;

	СдвигСтрок = НомерНижнЯчейкиОбласти - НомерВерхЯчейкиОбласти + 1;

	// номера строк вставляемой области
	НомерВерхЯчейкиНовойОбласти = НомерВерхЯчейкиОбласти + СдвигСтрок;
	НомерНижнЯчейкиНовойОбласти = НомерНижнЯчейкиОбласти + СдвигСтрок;

	Если СпециальноеДобавление Тогда
		Форма.СпециальногоДобавленияСтроки(ТекТабличноеПоле, ИмяГруппы, НомерВерхЯчейкиОбласти, НомерНижнЯчейкиОбласти);
	Иначе
		// определяем вставляемую область
		ВставляемаяОбласть = ТекТабличноеПоле.Область(НомерВерхЯчейкиОбласти, , НомерНижнЯчейкиОбласти, );
		// добавляем в таблицу новую строку
		ТекТабличноеПоле.ВставитьОбласть( ВставляемаяОбласть,,ТипСмещенияТабличногоДокумента.ПоВертикали );
	КонецЕсли;

	КолСтрокСтр1 = Формат(КолСтрок + 1, "ЧГ=0");
	// переопределяем имена вставленной области
	Для Каждого Колонка Из СтруктураГруппы.Колонки Цикл

		ИмяКолонки          = Колонка.Имя;
		ИмяОбластиЯчейки    = ИмяКолонки + "_" + КолСтрокСтр;
		ИмяНовОбластиЯчейки = ИмяКолонки + "_" + КолСтрокСтр1;

		ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
		ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;

		// определяем границы ячейки исходной области
		НомерВерхСтрокиЯчейки  = ОбластьЯчейки.Верх - СдвигСтрок;
		НомерНижнСтрокиЯчейки  = ОбластьЯчейки.Низ  - СдвигСтрок;
		НомерЛевоКолонкиЯчейки = ОбластьЯчейки.Лево;
		НомерПравКолонкиЯчейки = ОбластьЯчейки.Право;

		// Назначаем имя ячейки исходной области,
		// (т.к. в результате вставки новой области оно было очищено)
		ОбластьЯчейкиИсходнойОбласти = ТекТабличноеПоле.Область(НомерВерхСтрокиЯчейки, НомерЛевоКолонкиЯчейки, НомерНижнСтрокиЯчейки, НомерПравКолонкиЯчейки);
		ОбластьЯчейкиИсходнойОбласти.Имя = ИмяОбластиЯчейки;

		// очищаем значения ячеек вставленной области
		Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
			ОбластьЯчейки.Очистить();
		КонецЕсли;

		Если ИмяКолонкиНомера <> Неопределено Тогда
			Если ИмяКолонкиНомера = ИмяКолонки Тогда
				Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
					ОбластьЯчейки.Значение = КолСтрокСтр1;
				Иначе
					ОбластьЯчейки.Текст = КолСтрокСтр1;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Если ИмяГруппыБлока = Неопределено Тогда

		// Назначим текущей областью таблицы первую редактируемую ячейку добавленной строки.
		// Определяем текущую область таблицы
		ИмяТекущейОбласти = СтруктураГруппы.Колонки[0].Имя + "_" + КолСтрокСтр1;

		ТекТабличноеПоле.ТекущаяОбласть = ТекТабличноеПоле.Области[ИмяТекущейОбласти];
		// установим фокус на поле табличн. документа
		Форма.ТекущийЭлемент = ТекТабличноеПоле;
	КонецЕсли;

	// добавляем в структуру многострочной группы новую строку
	СтруктураГруппы.Добавить();
	Форма.Модифицированность = Истина;
КонецПроцедуры // роВставитьДополнительнуюСтроку()

// Удаляет строку многострочного раздела формы.
//
Процедура роУдалитьДополнительнуюСтроку(Форма, СпециальноеДобавление = Ложь, ИмяКолонкиНомера = Неопределено) Экспорт
	Перем ИсходноеКоличествоСтрокГруппы;
	Перем СтруктураГруппы;

	ТекущаяСтраница = Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница.Имя;
	ТекТабличноеПоле = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + ТекущаяСтраница];

	ТекущаяОбласть = ТекТабличноеПоле.ТекущаяОбласть;
	ИмяГруппы      = роРазделТекущейОбласти(Форма, ТекущаяОбласть);

	Если ИмяГруппы = Неопределено Тогда
		Сообщить("Не выбрана удаляемая строка многострочного раздела.", СтатусСообщения.Внимание);
		Возврат;
	КонецЕсли;

	Ответ = Вопрос("Удалить выбранную строку?" + Символы.ПС
	      + "(Внимание! данная операция необратима)", РежимДиалогаВопрос.ДаНет, , КодВозвратаДиалога.Да);

	Если Ответ <> КодВозвратаДиалога.Да Тогда
		Возврат;
	КонецЕсли;

	// исходное количество строк группы
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИмяГруппы, ИсходноеКоличествоСтрокГруппы);

	ТекТабличноеПоле = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРаздела(ИмяГруппы);
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);

	// Выполним также проверку вхождения текущей (выделенной) ячейки в многострочный раздел
	ТекущаяОбласть = ТекТабличноеПоле.ТекущаяОбласть;
	ИмяЯчейки      = ТекущаяОбласть.Имя;

	// номер строки многострочного раздела определим
	// по имени выделенной ячейки
	НомУдаляемойСтроки = Число( Сред( ИмяЯчейки, Найти( ИмяЯчейки, "_") + 1));
	НомерСтрокиТаблицы = НомУдаляемойСтроки - 1; // нумерация строк в таблице значений начинается с нуля

	Если СтруктураГруппы.Количество() > ИсходноеКоличествоСтрокГруппы Тогда
		// удаляется добавленная строка
		ИмяПервойЯчейкиУдаляемойСтроки = СтруктураГруппы.Колонки[0].Имя + "_" + Формат(НомУдаляемойСтроки, "ЧГ=0");

		// область первой ячейки удаляемой строки многострочного раздела
		ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиУдаляемойСтроки];

		// номера строк удаляемой области
		НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
		НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ;

		МногострочностьВРазделе = роПолучитьСвойствоРаздела(Форма, ТекущаяСтраница, "МногострочностьВРазделе");
		МногострочностьВРазделеТип = ТипЗнч(МногострочностьВРазделе);
		Если МногострочностьВРазделеТип = Тип("Число") Тогда
			ИмяОбластиМнгЧ = "МногострочнаяЧасть";
		ИначеЕсли МногострочностьВРазделеТип = Тип("ТаблицаЗначений") Тогда
			ИмяОбластиМнгЧ = МногострочностьВРазделе.Найти(ИмяГруппы, "ИдГруппы").Область;
		КонецЕсли;
		// Найдем координаты области, для последующего восстановления.

		Если ТекТабличноеПоле.Области.Найти(ИмяОбластиМнгЧ) <> Неопределено Тогда
			ОбластьВерх = ТекТабличноеПоле.Области[ИмяОбластиМнгЧ].Верх;
			ОбластьНиз = ТекТабличноеПоле.Области[ИмяОбластиМнгЧ].Низ;
		КонецЕсли;

		Если СпециальноеДобавление Тогда
			// Запустим единую процедуру удаляющая строку по специальному алгоритму
			// Используется в: ОчиститьТабличноеПоле(), ЗаполнитьРаздел2()
			Форма.СпециальногоУдаленияСтроки(ТекТабличноеПоле, ИмяГруппы, НомерВерхЯчейкиОбласти, НомерНижнЯчейкиОбласти);
		Иначе
			// Определим область удаляемой строки
			УдаляемаяОбласть = ТекТабличноеПоле.Область(НомерВерхЯчейкиОбласти, , НомерНижнЯчейкиОбласти, );
			// непосредственно удаляем область строки табличного документа
			ТекТабличноеПоле.УдалитьОбласть( УдаляемаяОбласть,ТипСмещенияТабличногоДокумента.ПоВертикали );
		КонецЕсли;
		// Восстановим область.
		Если ТекТабличноеПоле.Области.Найти(ИмяОбластиМнгЧ) <> Неопределено Тогда
			ТекТабличноеПоле.Области[ИмяОбластиМнгЧ].Имя = "";
			ТекТабличноеПоле.Область(ОбластьВерх, 0, ОбластьНиз, 0).Имя = ИмяОбластиМнгЧ;
		КонецЕсли;

		КолвоСдвигаемыхСтрок = СтруктураГруппы.Количество() - НомУдаляемойСтроки;

		// обновим имена ячеек сдвинутых строк
		Если КолвоСдвигаемыхСтрок > 0 Тогда

			Для НСтр = НомУдаляемойСтроки + 1 По СтруктураГруппы.Количество() Цикл

				ТекСтрока = СтруктураГруппы[НСтр-1];

				НСтрСтр = Формат(НСтр, "ЧГ=0");
				НСтрСтр1 = Формат(НСтр - 1, "ЧГ=0");
				Для Каждого Колонка Из СтруктураГруппы.Колонки Цикл
					КолонкаИмя = Колонка.Имя;
					ИмяСдвинутойЯчейки = КолонкаИмя + "_" + НСтрСтр;
					НовоеИмяСдвинутойЯчейки = КолонкаИмя + "_" + НСтрСтр1;

					ОбластьСдвинутойЯчейки     = ТекТабличноеПоле.Области[ИмяСдвинутойЯчейки];
					ОбластьСдвинутойЯчейки.Имя = НовоеИмяСдвинутойЯчейки;

					Если ИмяКолонкиНомера <> Неопределено Тогда
						Если ИмяКолонкиНомера = КолонкаИмя Тогда
							// обновляем порядковый номер строки

							СтарыйНомер = Число(ТекСтрока[КолонкаИмя]);
							НовыйПорядковыйНомер = Строка(Макс(СтарыйНомер - 1, 0));
							ОбластьСдвинутойЯчейки.Текст = НовыйПорядковыйНомер;

							// обновляем значение элемента таблицы значений
							ТекСтрока[КолонкаИмя] = НовыйПорядковыйНомер;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;

			КонецЦикла;
		КонецЕсли;

		// обновляем структуру многострочного раздела
		СтруктураГруппы.Удалить(НомерСтрокиТаблицы);

	Иначе
		// строка не удаляется в форме табличного документа,
		// а должна осуществляться сдвиг строк

		// обновляем структуру многострочного раздела
		// методом удаления выбранной строки и добавления пустой строки
		СтруктураГруппы.Удалить(НомерСтрокиТаблицы);

		ДобавляемаяСтрока = СтруктураГруппы.Добавить();

		// обновляем порядковые номера строк, выводимых в табличный документ
		Для Каждого СтрокаТаблицы Из СтруктураГруппы Цикл
			НомерСтрокиВТаблице      = СтруктураГруппы.Индекс(СтрокаТаблицы);
			НомерСтрокиВФормеТаблицы = Формат(НомерСтрокиВТаблице + 1, "ЧГ=0");
			Для Каждого КолонкаТаблицы Из СтруктураГруппы.Колонки Цикл
				КолонкаТаблицыИмя = КолонкаТаблицы.Имя;

				Если ИмяКолонкиНомера <> Неопределено Тогда
					Если ИмяКолонкиНомера = КолонкаТаблицыИмя Тогда
						// обновляем порядковый номер строки
						СтрокаТаблицы[КолонкаТаблицыИмя] = НомерСтрокиВФормеТаблицы;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;

		// Данные в многострочном блоке обновляются в декларациях!
		// Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппы);
		// Обновляем экранную форму табличного документа
		Форма.ВывестиРазделВТабличныйДокумент(ИмяГруппы, СтруктураГруппы);

	КонецЕсли;

	// назначим текущей областью таблицы первую редактируемую ячейку
	// удаленной строки, если ее порядковый номер меньше кол-ва строк
	// многострочного раздела, или последней строки раздела в противном случае

	// определяем текущую область таблицы
	НомТекущейСтроки  = Мин(НомУдаляемойСтроки, СтруктураГруппы.Количество());
	ИмяТекущейОбласти = СтруктураГруппы.Колонки[0].Имя + "_" + Формат(НомТекущейСтроки, "ЧГ=0");

	ТекТабличноеПоле.ТекущаяОбласть = ТекТабличноеПоле.Области[ИмяТекущейОбласти];

	// установим фокус на поле табличн. документа
	Форма.ТекущийЭлемент = ТекТабличноеПоле;

	Форма.Модифицированность = Истина;

КонецПроцедуры // роУдалитьДополнительнуюСтроку()

// СохранитьЗначениеВМногостраничномБлоке
// Процедура сохраняет значение в таблице многострочного блока, в соответствующей строке и колонке.
//
Процедура СохранитьЗначениеВМногостраничномБлоке(Форма, Знач ИмяГруппы, Знач НомерСтрокиНаФорме, Знач ИмяКолонки, Знач ЗначениеПоказателя) Экспорт
	Перем СтруктураГруппы;
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
	СтруктураГруппы[Число(НомерСтрокиНаФорме) - 1][ИмяКолонки] = ЗначениеПоказателя;

КонецПроцедуры // СохранитьЗначениеВМногостраничномБлоке

// ОчиститьПоказателиОтчетаПредназначенныеДляЗаполненияИзИБ
//
// Параметры:
//  Форма          - ссылка на форму отчета.
//  УдалятьЭкзМногостраничности - в случае, если многостраничный экземпляр раздела, является
//                 автозаполняемым, тогда Истина - удалит все экземпляры раздела
//
Процедура ОчиститьПоказателиОтчетаЗаполняемыеИзИБ(Форма, НазванияМногостраничныхРазделовДляУдаления = "") Экспорт

	Если НЕ ПустаяСтрока(НазванияМногостраничныхРазделовДляУдаления) Тогда
		НазванияМнгостраничныхРазделов = Новый Структура(НазванияМногостраничныхРазделовДляУдаления);
	Иначе
		НазванияМнгостраничныхРазделов = Новый Структура;
	КонецЕсли;

	Для каждого СтрокаУровня1 из Форма.мСвойстваРазделовДекларации.Строки Цикл
		НазваниеСтраницы           = СтрокаУровня1.ИмяСтраницы;
		МногостраничностьВРазделе  = СтрокаУровня1.МногостраничностьВРазделе;
		РазделАвтозаполняется = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если НазваниеСтраницы = "Титульный" Тогда
			Продолжить;
		КонецЕсли;

		мРаздел = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + НазваниеСтраницы];
		Если НазванияМнгостраничныхРазделов.Свойство(НазваниеСтраницы) Тогда
			// Очистим текущий лист.
			Форма.ОчиститьТабличноеПоле(мРаздел);
			ТаблицаСтраницРаздела = Неопределено;
			Форма.мСтруктураМногостраничныхРазделов.Свойство(НазваниеСтраницы, ТаблицаСтраницРаздела);
			ИндексСтраницы = 0;
			Пока Не (ИндексСтраницы > (ТаблицаСтраницРаздела.Количество()-1)) Цикл
				СтрокаТаблицы = ТаблицаСтраницРаздела[ИндексСтраницы];
				Если НЕ СтрокаТаблицы.АктивнаяСтраница Тогда
					// удаляем дополнительную страницу
					ТаблицаСтраницРаздела.Удалить(СтрокаТаблицы);
					Продолжить;
				КонецЕсли;
				ИндексСтраницы = ИндексСтраницы + 1;
			КонецЦикла;
			// Отобразим статик.
			роПоказатьСтатикСтраницРаздела(Форма, НазваниеСтраницы);
			// Варианты заполнения установим в один массив.
			роОчиститьВариантыЗаполнения(Форма, НазваниеСтраницы);
			Продолжить;

		КонецЕсли;

		ВариантыАвтозаполнения = роПолучитьТаблицуВариантовЗаполнения(Форма, НазваниеСтраницы);

		Если ВариантыАвтозаполнения <> Неопределено Тогда

			Если ВариантыАвтозаполнения.Колонки.Найти("КодПоказателяПоСтруктуре") = Неопределено Тогда
				ПоказательПоСтруктуре = Ложь;
			Иначе
				ПоказательПоСтруктуре = Истина;
			КонецЕсли;

			// Переберем все показатели, которые могут заполняться из ИБ или автозаполняемые.
			Для каждого Пок Из ВариантыАвтозаполнения Цикл

				Если ПоказательПоСтруктуре Тогда
					Если НЕ ПустаяСтрока(Пок.КодПоказателяПоСтруктуре) Тогда
						// Для показателей квадратичных, очистка произойдет через Расчет()
						Продолжить;
					КонецЕсли;
				КонецЕсли;

				КодПоказателя = Пок.КодПоказателя;
				Если (Пок.ВариантЗаполнения = 3) Или (Пок.ВариантЗаполнения = 4) Тогда
					// Если показатель в многострочной части, вернем кол-во строк блока.
					Колво = роПоказательВходитВМногострочнуюЧасть(Форма, КодПоказателя);
					Если Колво = 0 Тогда
						мРаздел.Области[КодПоказателя].Очистить();
					Иначе
						Для Инд = 1 По Колво Цикл
							мРаздел.Области[КодПоказателя + "_" + Формат(Инд, "ЧГ=0")].Очистить();
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры // ОчиститьПоказателиОтчетаПредназначенныеДляЗаполненияИзИБ

// Процедура выводит строки многострочного раздела в табличный документ.
// При отсутствии в табличном документе необходимого количества строк
// добавляет отсутствующие строки.
//
// Параметры:
//  ИмяГруппы       - строка, имя многострочного раздела;
//  СтруктураГруппы - таблица значений, содержащая значения показателей многострочного раздела.
//  ПерерисоватьСтроки - Истина из процедуры удаления доп. строк, для перерисовки областей.
//
Процедура роВывестиРазделВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы) Экспорт
	Перем ИсходноеКоличествоСтрокГруппы;

	// определим исходное колво строк многострочного раздела,
	// соответствующее бумажной форме отчета
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИмяГруппы, ИсходноеКоличествоСтрокГруппы);

	// реальное кол-во строк (колво заполненных строк)
	ТекущееКоличествоСтрокГруппы = СтруктураГруппы.Количество();

	ТекТабличноеПоле = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРаздела(ИмяГруппы);
	ТекТабличноеПолеИмя = ТекТабличноеПоле.Имя;

	ПерерисоватьСтроки = (НЕ ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы);
	СтруктураГруппыКолонки = СтруктураГруппы.Колонки;

	Раздел = Форма.ЭлементыФормы[ТекТабличноеПолеИмя];
	// При восстановлении сохраненных данных отчета сравниваем исходное кол-во
	// отображаемых в форме строк многострочного раздела с реальным количеством
	// созданных строк в сохраненном отчете.
	Если ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы Тогда

		// Режим восстановления многострочных блоков. Из процедуры ВосстановитьСохраненныеДанные.
		НастройкиМнгЧ = роПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе").Скопировать();
		НазвОбласти = НастройкиМнгЧ.Найти(ИмяГруппы, "ИдГруппы").Область;

		НастройкиМнгЧ.Колонки.Добавить("НизМногострочнойЧасти");
		НастройкиМнгЧ.Колонки.Добавить("ВерхМногострочнойЧасти");

		// Определим координаты всех многострочных блоков, для последующего восстановления.
		Для каждого Зап Из НастройкиМнгЧ Цикл
			КоординатаНиз = Раздел.Области[Зап.Область].Низ;
			КоординатаВерх = Раздел.Области[Зап.Область].Верх;
			Зап.НизМногострочнойЧасти = КоординатаНиз;
			Зап.ВерхМногострочнойЧасти = КоординатаВерх;
			// Координаты текущей области
			Если Зап.Область = НазвОбласти Тогда
				Низ = КоординатаНиз;
				Верх = КоординатаВерх;
			КонецЕсли;
		КонецЦикла;

		// ВысотаСтроки = ?(ИмяГруппы = мИдГруппы1 Или ИмяГруппы = мИдГруппы3, 4, 1);
		ВысотаСтроки = 1;
		// Скопируем верхнюю часть документа, не включая многострочную часть.
		ТаблДок = Раздел.ПолучитьОбласть(1, , Верх - 1);
		// Скопируем подвал, всё, что ниже области многострочного блока.
		Подвал = Раздел.ПолучитьОбласть(Низ + 1, , Раздел.ВысотаТаблицы);

		Строка = Раздел.ПолучитьОбласть(Верх, , Верх + ВысотаСтроки - 1);

		Если ВысотаСтроки > 1 Тогда
			Строка.Области.ОпределениеВысотыСтрокиМногострочнойЧасти.Имя = "";
		КонецЕсли;

		Если Строка.Области.Найти(НазвОбласти) <> Неопределено Тогда
			Строка.Области[НазвОбласти].Имя = "";
		КонецЕсли;

		// При превышении реального кол-ва строк над исходным кол-вом (по шаблону),
		// автоматически добавляем необходимое колво строк.

		Для НомНовойСтроки = 1 По ТекущееКоличествоСтрокГруппы Цикл
			// Переопределим именнованность.
			Строка1 = Строка.ПолучитьОбласть(1, , Строка.ВысотаТаблицы);
			НомСтр = Формат(НомНовойСтроки, "ЧГ=0");
			Для каждого Кол Из СтруктураГруппыКолонки Цикл
				КолИмя = Кол.Имя;
				Строка1.Области[КолИмя + "_1"].Имя = КолИмя + "_" + НомСтр;
			КонецЦикла;

			ЗаполнитьСтрокуДаннымиИзТаблицы(СтруктураГруппы, Строка1, СтруктураГруппы[НомНовойСтроки - 1], НомСтр);
			ТаблДок.Вывести(Строка1);

		КонецЦикла;

		ТаблДок.Вывести(Подвал);
		Раздел.Очистить();
		Раздел.Вывести(ТаблДок);

		// Восстановим области.
		Для каждого Зап Из НастройкиМнгЧ Цикл
			Раздел.Область("R" + Формат(Зап.НизМногострочнойЧасти, "ЧГ=0") + ":R" + Формат(Зап.ВерхМногострочнойЧасти, "ЧГ=0")).Имя = Зап.Область;
		КонецЦикла;

	КонецЕсли;

	// выводим значения строк
	Для Каждого СтрокаТаблицы Из СтруктураГруппы Цикл
		НомерСтрокиВТаблице      = СтруктураГруппы.Индекс(СтрокаТаблицы);
		НомерСтрокиВФормеТаблицы = НомерСтрокиВТаблице + 1;
		НомерСтрокиВФормеТаблицыСтр = Формат(НомерСтрокиВФормеТаблицы, "ЧГ=0");
		Для Каждого КолонкаТаблицы Из СтруктураГруппы.Колонки Цикл

			КолонкаТаблицыИмя        = КолонкаТаблицы.Имя;
			ЗначениеЯчейки           = СтрокаТаблицы[КолонкаТаблицыИмя];
			ИмяЯчейки                = КолонкаТаблицыИмя + "_" + НомерСтрокиВФормеТаблицыСтр;

			ОбластьЯчейкиТаблицы          = ТекТабличноеПоле.Области[ИмяЯчейки];

			Если ОбластьЯчейкиТаблицы.СодержитЗначение = Истина Тогда
				ОбластьЯчейкиТаблицы.Значение = ЗначениеЯчейки;
			Иначе
				ОбластьЯчейкиТаблицы.Текст = ЗначениеЯчейки;
			КонецЕсли;


		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // роВывестиРазделВТабличныйДокумент()

// ЗаполнитьСтрокуДаннымиИзТаблицы
//
Процедура ЗаполнитьСтрокуДаннымиИзТаблицы(ТаблицаРаздела, Строка1, СтрокаТаблицы, НомерНаФорме) Экспорт
	// Заполняем строку.
	Для каждого Колонка Из ТаблицаРаздела.Колонки Цикл
		КолонкаИмя = Колонка.Имя;
		НазвЯчейки = КолонкаИмя + "_" + НомерНаФорме;
		Если Строка1.Области[НазвЯчейки].СодержитЗначение = Истина Тогда
			Строка1.Области[НазвЯчейки].Значение = СтрокаТаблицы[КолонкаИмя];
		Иначе
			Строка1.Области[НазвЯчейки].Текст = СтрокаТаблицы[КолонкаИмя];
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры // ЗаполнитьСтрокуДаннымиИзТаблицы

// УдалитьДопСтрокиМногострочнойЧастиРегОтчета
// Процедура удаляет дополнительные строки многострочного блока.
// Удаление происходит не по строчкам, а группой строк в одну итерацию.
//
// Параметры:
//  Форма          - ссылка на форму
//  ИдГруппы       - идентификатор многострочной группы
//  ОбновлятьБлок  - по умолчания Истина, запускать ли ОбновитьСтруктуруМногострочногоРаздела.
//
Процедура УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, ИдГруппы, ОбновлятьБлок = Истина) Экспорт
	Перем ТаблицаДопСтрок;
	Перем ИсходноеКоличествоСтрокГруппы;

	Форма.мСтруктураМногострочныхРазделов.Свойство(ИдГруппы, ТаблицаДопСтрок);
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИдГруппы, ИсходноеКоличествоСтрокГруппы);
	ТекущееКоличествоСтрок = ТаблицаДопСтрок.Количество();
	ТекТабличноеПоле = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРаздела(ИдГруппы);
	ТекТабличноеПолеИмя = ТекТабличноеПоле.Имя;
	Если ТекущееКоличествоСтрок > ИсходноеКоличествоСтрокГруппы Тогда

		НастройкиМнгЧ = роПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе").Найти(ИдГруппы, "ИдГруппы");
		МнгЧастьОбластьИмя = НастройкиМнгЧ.Область;
		ВысотаСтроки = НастройкиМнгЧ.ВысотаСтроки;

		МнгЧастьОбласть = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя);
		Низ = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя).Низ + 1;
		УдаляемаяОбласть = ТекТабличноеПоле.Область(Низ, , Низ + ((ТекущееКоличествоСтрок - ИсходноеКоличествоСтрокГруппы) * ВысотаСтроки) - 1);
		ТекТабличноеПоле.УдалитьОбласть(УдаляемаяОбласть,ТипСмещенияТабличногоДокумента.ПоВертикали);
		ТаблицаДопСтрок.Очистить();
		Для Инд = 1 По ИсходноеКоличествоСтрокГруппы Цикл
			ТаблицаДопСтрок.Добавить();
		КонецЦикла;
		Если ОбновлятьБлок Тогда
			Форма.ОбновитьСтруктуруМногострочногоРаздела(ИдГруппы);
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры // УдалитьДопСтрокиМногострочнойЧастиРегОтчета

// Процедура очищает содержимое редактируемых и вычисляемых ячеек
// поля табличного документа, переданного параметром ВыбТабличноеПоле.
//
// Параметры:
//  ВыбТабличноеПоле - поле табличного документа.
//
Процедура роОчиститьТабличноеПоле(Форма, ВыбТабличноеПоле) Экспорт

	ВыбТабличноеПолеИмя = ВыбТабличноеПоле.Имя;
	// Проверяем многострочные блоки в разделе.
	НастройкиМнгЧ = роПолучитьСвойствоРаздела(Форма, ВыбТабличноеПолеИмя, "МногострочностьВРазделе");
	ЕстьМногострочныеБлоки = ТипЗнч(НастройкиМнгЧ) = Тип("ТаблицаЗначений");
	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, МногострочныйБлок, Ложь);
		КонецЦикла;
	КонецЕсли;

	// Непосредственно очищаем ячейки табличного документа.
	Для Инд = 0 По ВыбТабличноеПоле.Области.Количество() - 1 Цикл
		ТекущаяОбласть = ВыбТабличноеПоле.Области[Инд];

		Если Не ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
			Продолжить;
		КонецЕсли;

		Если ТекущаяОбласть.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;

		Если ТекущаяОбласть.Защита Тогда
			Продолжить;
		КонецЕсли;

		ТекущаяОбласть.Очистить();
	КонецЦикла;

	ИмяСтраницыПанели = СтрЗаменить(ВыбТабличноеПолеИмя, "ПолеТабличногоДокумента", "");
	ПредставлениеДанных = роПолучитьСвойствоРаздела(Форма, ВыбТабличноеПолеИмя, "ПредставлениеДанных");
	Если ПредставлениеДанных Тогда
		Форма.ОбнулитьПеременныеМодуляХранящиеЗначенияКвадратногоПредставленияПоРазделу(ИмяСтраницыПанели);
		Форма.ЗаполнениеЗначенийВКвадратиках(ИмяСтраницыПанели);
	КонецЕсли;

	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			Форма.ОбновитьСтруктуруМногострочногоРаздела(МногострочныйБлок);
		КонецЦикла;
		// Расчет всегда запускаем только в многострочных листах. В не многострочных, запускается при вставки доп. страницы, или интерактивно в коде.
		Форма.Расчет(ИмяСтраницыПанели);
	КонецЕсли;

КонецПроцедуры // роОчиститьТабличноеПоле()

// роОбновитьСтруктуруМногострочногоРаздела
// Обновляет структуру многострочнго раздела, заданного
// уникальным идентификатором. Заполняет таблицу значений
// многострочного раздела значениями соответствующих ячеек.
// Нельзя вызывать процедуру из общего модуля. Только через процедуру находящуюся в форме отчета.
//
// Параметры:
//  ИмяГруппы - строка - идентификатор многострочного раздела.
//
Процедура роОбновитьСтруктуруМногострочногоРаздела(Форма, ИмяГруппы) Экспорт
	Перем СтруктураГруппы;

	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
	ТекТабличноеПоле = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРаздела(ИмяГруппы);

	Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
		ТекСтрокаТаблицы = СтруктураГруппы[НСтр - 1];
		НСтрСтр = Формат(НСтр, "ЧГ=0");
		Для Каждого Колонка Из СтруктураГруппы.Колонки Цикл
			ИмяКолонки    = Колонка.Имя;

			ИмяЯчейки     = ИмяКолонки + "_" + НСтрСтр;
			ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяЯчейки];

			Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
				ЗначениеЯчейки = ОбластьЯчейки.Значение;
			Иначе
				ЗначениеЯчейки = ОбластьЯчейки.Текст;
			КонецЕсли;
			ТекСтрокаТаблицы[ИмяКолонки] = ЗначениеЯчейки;
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры // роОбновитьСтруктуруМногострочногоРаздела()

// Обновляет структуру многострочных разделов.
// Заполняет таблицу значений многострочного раздела
// значениями соответствующих ячеек.
//
Процедура роОбновитьСтруктуруМногострочныхРазделов(Форма) Экспорт
	// Заполняет таблицу значений многострочного раздела
	// указанными в соответствующих ячейках значениями

	// Заполнение выполняется синхронно для всех многострочных разделов
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		Форма.ОбновитьСтруктуруМногострочногоРаздела(ИмяГруппы);
	КонецЦикла;
КонецПроцедуры // роОбновитьСтруктуруМногострочныхРазделов()

// ПолучитьСведенияОПредставителе
// Функция возаращает данные о представителе из справочника РегистрацияВИФНС.
//
// Параметры:
//  Организация    - ссылка на справочник оганизации.
//  КодИФНС        - строка, код ИФНС (с титульного листа).
//  ДатаПодписиОтчета - дата подписи отчета, для работы с ФИО.
//
// Возвращаемое значение:
//  Структура с ключами: ПредставительЮр, ПредставительФЛ, ДокументПредставителя
//
Функция ПолучитьСведенияОПредставителеОрганизации(Организация, КодИФНС, ДатаПодписиОтчета) Экспорт
	Результат = Новый Структура("ПредставительЮр, ПредставительФЛ, ДокументПредставителя, Фамилия, Имя, Отчество", "", "", "", "", "", "");
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Владелец", Организация);
	Запрос.УстановитьПараметр("КодИФНС", КодИФНС);
	
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	СправочникИФНС.КПП,
	               |	СправочникИФНС.Код КАК КодНО,
	               |	СправочникИФНС.НаименованиеИФНС КАК Наименование,
	               |	СправочникИФНС.Представитель,
	               |	СправочникИФНС.ДокументПредставителя
	               |ИЗ
	               |Справочник.РегистрацияВИФНС КАК СправочникИФНС
	               |ГДЕ
	               |СправочникИФНС.Владелец = &Владелец
	               | И СправочникИФНС.Код = &КодИФНС";
	СправочникИФНС = Запрос.Выполнить().Выгрузить();
	Если СправочникИФНС.Количество() = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	// В справочнике регистрации ИФНС может быть только информация по одной ИФНС!
	Представитель = СправочникИФНС[0].Представитель;
	Если ТипЗнч(Представитель) = Тип("СправочникСсылка.Контрагенты") Тогда
		Если ЗначениеЗаполнено(Представитель) Тогда
			Результат.Вставить("ПредставительЮр", Представитель.НаименованиеПолное);
		КонецЕсли;
	ИначеЕсли ТипЗнч(Представитель) = Тип("СправочникСсылка.ФизическиеЛица") Тогда
		Если ЗначениеЗаполнено(Представитель) Тогда
			ДанныеФЛ = РегистрыСведений.ФИОФизЛиц.СрезПоследних(ДатаПодписиОтчета, Новый Структура("ФизЛицо", Представитель));
			Если ДанныеФЛ.Количество() > 0 Тогда
				ФамилияПредставителя = СокрЛП(ДанныеФЛ[0].Фамилия);
				ИмяПредставителя = СокрЛП(ДанныеФЛ[0].Имя);
				ОтчествоПредставителя = СокрЛП(ДанныеФЛ[0].Отчество);
				Значение = ФамилияПредставителя + " " + ИмяПредставителя + " " + ОтчествоПредставителя;
				Результат.Вставить("Фамилия", ФамилияПредставителя);
				Результат.Вставить("Имя", ИмяПредставителя);
				Результат.Вставить("Отчество", ОтчествоПредставителя);
			Иначе
				Значение = "";
			КонецЕсли;
			Результат.Вставить("ПредставительФЛ", Значение);
		КонецЕсли;
	КонецЕсли;
	Результат.Вставить("ДокументПредставителя", СправочникИФНС[0].ДокументПредставителя);
	Возврат Результат;
КонецФункции // ПолучитьСведенияОПредставителе

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ПОДДЕРЖКИ ВНЕШНИХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
//

// Сравнивает "версию" данных, хранящихся в экземпляре документа РегламентированныйОтчет с 
// "версией" отчета, с помощью которого эти данные пытаются открыть.
// Параметры:
// 		ВерсияФормы - "версия" данных.
//		мВерсияФормы = "версия" отчета.
// Возвращаемое значение:
//		Булево - Истина, если отчет с версией мВерсияФормы способен работать с данными версии ВерсияФормы.
//				 Ложь, если отчет с версией мВерсияФормы НЕ способен работать с данными версии ВерсияФормы.
Функция ПродолжитьПриНесоответствииВерсийФорм(Знач ВерсияФормы, Знач мВерсияФормы) Экспорт
	
	ПервыйСлеш = Найти(ВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(ВерсияФормы, ПервыйСлеш - 1) + " " + Сред(ВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодВерсияФормы = Сред(ВерсияФормы, ВторойСлеш + 1);
	МесяцВерсияФормы = Сред(ВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньВерсияФормы = Сред(ВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодВерсияФормы) = 2 Тогда
		ГодВерсияФормы = "20" + ГодВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцВерсияФормы) = 1 Тогда
		МесяцВерсияФормы = "0" + МесяцВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньВерсияФормы) = 1 Тогда
		ДеньВерсияФормы = "0" + ДеньВерсияФормы;
	КонецЕсли;
	ДатаВерсияФормы = Дата(ГодВерсияФормы + МесяцВерсияФормы + ДеньВерсияФормы);
	
	ПервыйСлеш = Найти(мВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(мВерсияФормы, ПервыйСлеш - 1) + " " + Сред(мВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодмВерсияФормы = Сред(мВерсияФормы, ВторойСлеш + 1);
	МесяцмВерсияФормы = Сред(мВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньмВерсияФормы = Сред(мВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодмВерсияФормы) = 2 Тогда
		ГодмВерсияФормы = "20" + ГодмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцмВерсияФормы) = 1 Тогда
		МесяцмВерсияФормы = "0" + МесяцмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньмВерсияФормы) = 1 Тогда
		ДеньмВерсияФормы = "0" + ДеньмВерсияФормы;
	КонецЕсли;
	ДатамВерсияФормы = Дата(ГодмВерсияФормы + МесяцмВерсияФормы + ДеньмВерсияФормы);
	
	Если ДатамВерсияФормы < ДатаВерсияФормы Тогда
		Предупреждение("Сохраненные данные не могут быть открыты текущей версией отчета!" + Символы.ПС + 
						"Версия отчета - от " + Формат(ДатамВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'") + Символы.ПС + 
						"Версия данных - от " + Формат(ДатаВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'"));
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Возвращает двоичные данные с файлом - внешней обработкой с учетом кэша (реквизит ВнешнийОтчетХранилище), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Содержимое реквизита ВнешнийОтчетХранилище элемента справочника с учетом кэша.
Функция ОбъектОтчетСУчетомКэша(РеглОтч)
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Отчет;
	Иначе
		Попытка
			ОтчетВКэш = РеглОтч.ВнешнийОтчетХранилище.Получить();
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", ОтчетВКэш, РеглОтч.ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ОтчетВКэш;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Возвращает признак использования внешнего отчета с учетом кэша (реквизит ВнешнийОтчетИспользовать), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
//		Признак использования внешнего отчета для заданного элемента справочника с учетом кэша.
Функция ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(РеглОтч)
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Признак;
	Иначе
		Попытка
			ВнешнийОтчетИспользовать = РеглОтч.ВнешнийОтчетИспользовать;
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", РеглОтч.ВнешнийОтчетХранилище.Получить(), ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ВнешнийОтчетИспользовать;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

// Показывает или скрывает (в зависимости от вида отчета) элемент формы, сигнализирующий пользователю
// о том, что текущая форма принадлежит внешнему отчету.
// Параметры:
//		Форма - объект Форма.
Процедура ДобавитьНадписьВнешнийОтчет(Форма) Экспорт
	
	СтроковоеПредставлениеТипаОбъекта = Строка(ТипЗнч(Форма.ЭтотОбъект));
	ЭтоВнешняяОбработка = (Лев(СтроковоеПредставлениеТипаОбъекта, 24) = "Внешняя обработка объект");
	Если ЭтоВнешняяОбработка Тогда
	
		Если Форма.ЭлементыФормы.Найти("_ИндикаторВнешнегоОтчета") = Неопределено Тогда
			Возврат;
		КонецЕсли;
		Форма.ЭлементыФормы._ИндикаторВнешнегоОтчета.Видимость = Истина;
		
	Иначе
		
		Если Форма.ЭлементыФормы.Найти("_ИндикаторВнешнегоОтчета") = Неопределено Тогда
			Возврат;
		КонецЕсли;
		Форма.ЭлементыФормы._ИндикаторВнешнегоОтчета.Видимость = Ложь;
		
	КонецЕсли;
		
КонецПроцедуры

// Создает и возвращает ссылку на объект - регламентированный отчет, соответствующий переданному 
// в качестве параметра наименованию. При создании объекта учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		СоздаватьИНеЗапоминать - признак того, что созданный объект не оставить след в кэше.
// Возвращаемое значение:
//		Отчет или ВнешняяОбработка - созданный объект. В случае неудачи возвращается Неопределено.
Функция РеглОтчеты(Наим, СоздаватьИНеЗапоминать = Ложь) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Документы.Найти(Наим) <> Неопределено Тогда
			Возврат Документы[Наим];
		ИначеЕсли Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим];
		Иначе
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			
			Попытка
				ВременныйФайл = ПолучитьИмяВременногоФайла();
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				Если НЕ СоздаватьИНеЗапоминать Тогда
					СтруктураРегламентированныхОтчетов.Вставить(Наим, ВременныйФайл);
					ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(СтруктураРегламентированныхОтчетов);
				КонецЕсли;
				Возврат ВнешняяОбработка;
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		Иначе
			
			Попытка
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				Возврат ВнешняяОбработка;
			Исключение
				Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

// Создает и возвращает ссылку на форму регламентированного отчета, соответствующего переданному 
// в качестве параметра наименованию. При получении формы учитывается информация в кэше.
// Параметры:
//		Наим - строка-идентификатор регламентированного отчета.
//		Выбраннаяформа - строка - имя формы.
//		Владелец - владелец формы. Форма или элемент управления.
//		КлючУникальности - ключ, значение которого будет использовано для поиска уже открытых форм.
// Возвращаемое значение:
//		Форма - созданный объект. В случае неудачи возвращается Неопределено.
Функция ФормаРеглОтчета(Наим, ВыбраннаяФорма = Неопределено, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // используется внутренний отчет
		Если Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
			Возврат Отчеты[Наим].ПолучитьФорму(ВыбраннаяФорма, Владелец, КлючУникальности);
		Иначе
			// отчет с таким именем не найден
			Сообщить("Не найден отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			Возврат Неопределено;
		КонецЕсли; 
	Иначе // используется внешний отчет
		
		Попытка
			СтруктураРегламентированныхОтчетов = ПараметрыСеанса.ПолныеИменаФайловВнешнихРегламентированныхОтчетов.Получить();
		Исключение
			СтруктураРегламентированныхОтчетов = Новый Структура;
		КонецПопытки;
		
		Если НЕ СтруктураРегламентированныхОтчетов.Свойство(Наим, ВременныйФайл) ИЛИ ВременныйФайл = Неопределено Тогда
			
			Возврат Неопределено;
			//Попытка
			//	ВременныйФайл = ПолучитьИмяВременногоФайла();
			//	НайденныйЭлемент.ВнешнийОтчетХранилище.Получить().Записать(ВременныйФайл);
			//	ВнешняяОбработка = ВнешниеОбработки.Создать(ВременныйФайл);
			//	СтруктураРегламентированныхОтчетов.Вставить(Наим, ВременныйФайл);
			//	ПараметрыСеанса.РегламентированныеОтчеты = Новый ХранилищеЗначения(СтруктураРегламентированныхОтчетов);
			//	Возврат ВнешняяОбработка;
			//Исключение
			//	Сообщить("Не удалось запустить внешний отчет " + СокрП(Наим) + ".", СтатусСообщения.ОченьВажное);
			//	Возврат Неопределено;
			//Конецпопытки;
			
		Иначе
			
			Попытка
				ОбъектОтчетСУчетомКэша(НайденныйЭлемент).Записать(ВременныйФайл);
				ВнешняяОбработка = ВнешниеОбработки.ПолучитьФорму(ВременныйФайл, ВыбраннаяФорма, Владелец, КлючУникальности);
				Попытка
					ВнешняяОбработка.мПолноеИмяФайлаВнешнейОбработки = ВременныйФайл;
				Исключение
				КонецПопытки;
				ДобавитьНадписьВнешнийОтчет(ВнешняяОбработка);
				Возврат ВнешняяОбработка;
			Исключение
				Возврат Неопределено;
			Конецпопытки;
			
		КонецЕсли;
		
	КонецЕсли;
	Возврат Неопределено;
	
КонецФункции

// Определяет, с учетом кэша, является ли отчет, заданный строкой-идентификатором Наим, внешним.
// Параметры:
//		Наим - строка-идентификатор отчета.
// ВозвращаемоеЗначение:
//		Булево - Истина, если для заданной строки-идентификатора используется внешний отчет.
//				 Ложь - в противном случае.
//				 Неопределено - информация по отчету, заданному строкой-идентификатором 
//  			 отсутствует в справочнике РегламентированныеОтчеты.
Функция ЭтоВнешнийОтчет(Наим) Экспорт
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // внутренний отчет
		Возврат Ложь;
	Иначе // внешний отчет
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Определяет кэшировалась ли информация для заданного элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - ссылка на элемент справочника РегламентированныеОтчеты.
// Возвращаемое значение:
// 		Булево - Истина - информация кэшировалась,
// 				 Ложь - в противном случае.
Функция ОтчетКэшировался(РеглОтч) Экспорт
	Перем ОтчетВКэше;
	
	Попытка
		Возврат ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить().Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Пытается заблокировать документ. В случае неудачной попытки выдает предупреждение.
// Параметры:
//		мСохраненныйДок - объект ДокументОбъект, блокировку которого следует выполнить.
// Возвращаемое значение:
// 		Булево - Истина - объект удалось заблокировать,
// 				 Ложь - объект заблокировать не удалось.
Функция ЗаблокироватьДокумент(мСохраненныйДок) Экспорт
	
	Попытка
		мСохраненныйДок.Заблокировать();
		Возврат Истина;
	Исключение
		Предупреждение("Не удается заблокировать документ!" + Символы.ПС + "Возможно, документ уже открыт другим пользователем!");
		Возврат Ложь;
	Конецпопытки;
			
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СОБЫТИЯ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
//

// Событие возникает перед открытием основной формы регламентированного отчета.
// В процедуре инициализируются стандартные переменные отчета. Выполняются специфические для
// внешних регламентированных отчетов действия, в случае если отчет внешний.
// Параметры:
//		Форма - основная форма отчета.
//		Отказ - признак отказа от открытия формы.
//		СтандартнаяОбработка - признак стандартной обработки открытия формы.
Процедура ПередОткрытиемОсновнойФормыРегламентиованногоОтчета(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	СтроковоеПредставлениеТипаОбъекта = Строка(ТипЗнч(Форма.ЭтотОбъект));
	ЭтоВнешняяОбработка = (Лев(СтроковоеПредставлениеТипаОбъекта, 24) = "Внешняя обработка объект");
	Если ЭтоВнешняяОбработка И Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
		Если Форма.мПолноеИмяФайлаВнешнейОбработки = Неопределено Тогда
			Предупреждение("Внимание, отчет не зарегистрирован! Функция сохранения будет недоступна!");
			Форма.мЗаписьЗапрещена = Истина;
		КонецЕсли;
	КонецЕсли;
	Форма.АвтоЗаголовок = Ложь;

	Если Форма.ВладелецФормы <> Неопределено Тогда
		Если Не Форма.ВладелецФормы.ЭтоНовый() Тогда
			
			// При восстановлении сохраненных данных сразу открываем
			// нужную форму отчета, минуя основную форму.
			Отказ = Истина;

			Форма.мСохраненныйДок = Форма.ВладелецФормы.ДокументОбъект;
			
			// определяем границы периода построения отчета
			Форма.мДатаНачалаПериодаОтчета = НачалоДня(Форма.мСохраненныйДок.ДатаНачала);
			Форма.мДатаКонцаПериодаОтчета  = КонецДня(Форма.мСохраненныйДок.ДатаОкончания);
			
			// в некоторых отчетах (формы баланса, например) переменная мПериодичность не определена
			Попытка
				Форма.мПериодичность = Форма.мСохраненныйДок.Периодичность;
			Исключение
			КонецПопытки;

			// по реквизиту ВыбраннаяФорма документа определяем,
			// какую форму следует открыть
			ВыбраннаяФорма = Форма.ВладелецФормы.ВыбраннаяФорма;
			
			//УжеОткрытаяФорма = Отчеты[ЭтотОбъект.Метаданные().Имя].ПолучитьФорму(?(ПустаяСтрока(ВыбраннаяФорма), ПолучитьФормуДляПериода(мСохраненныйДок.ДатаОкончания), СокрЛП(ВыбраннаяФорма)), , мСохраненныйДок.Ссылка);
			УжеОткрытаяФорма = ФормаРеглОтчета(Форма.ЭтотОбъект.Метаданные().Имя, СокрЛП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Если УжеОткрытаяФорма.Открыта() И УжеОткрытаяФорма.мСохраненныйДок.Ссылка = Форма.мСохраненныйДок.Ссылка Тогда
				УжеОткрытаяФорма.Активизировать();
				Возврат;
			КонецЕсли;
			
			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
			Если Форма.ЭтотОбъект.Метаданные().Формы.Найти(СокрП(ВыбраннаяФорма)) <> Неопределено Тогда
				ВыбФормаОтчета = Форма.ПолучитьФорму(СокрП(ВыбраннаяФорма), , Форма.мСохраненныйДок.Ссылка);
			Иначе
				// Если не удалось найти форму с таким названием (могла быть переименована),
				// то по умолчанию выдаем текущую (действующую) форму
				ВыбраннаяФорма = Форма.мТаблицаФормОтчета[0].ФормаОтчета;
				ВыбФормаОтчета = Форма.ПолучитьФорму(ВыбраннаяФорма, , Форма.мСохраненныйДок.Ссылка);
			КонецЕсли;
			
			// Попытка получения переменной мВерсияФормы сохраненного документа для сравнения
			// с аналогичной переменной объекта отчет.
			Попытка
				ВерсияФормыДанных = Форма.мСохраненныйДок.ДанныеОтчета.Получить().ВерсияФормы;
				Если НЕ ПродолжитьПриНесоответствииВерсийФорм(ВерсияФормыДанных, ВыбФормаОтчета.мВерсияФормы) Тогда
					Возврат;
				КонецЕсли;
			Исключение
			Конецпопытки;
			
			Форма.мВыбраннаяФорма = ВыбраннаяФорма;

			ДобавитьНадписьВнешнийОтчет(ВыбФормаОтчета);
			ВыбФормаОтчета.РежимВыбора = Ложь;
			ВыбФормаОтчета.ЗакрыватьПриЗакрытииВладельца = Ложь;
			ВыбФормаОтчета.Открыть();

		ИначеЕсли Форма.ВладелецФормы.мСкопированаФорма <> Неопределено Тогда
			// Новый документ РегламентированныйОтчет был получен
			// методом копирования имеющегося.
			// Переменной мСохраненныйДок присвоим текущий документ
			Форма.мСохраненныйДок   = Форма.ВладелецФормы.ДокументОбъект;
			Форма.мСкопированаФорма = Форма.ВладелецФормы.мСкопированаФорма;

			Форма.Организация       = Форма.ВладелецФормы.Организация;
			// Скопируем периодичность.
			Попытка
				Форма.мПериодичность = Форма.ВладелецФормы.Периодичность;
			Исключение
			КонецПопытки;

			Попытка
				Форма.мДатаНачалаПериодаОтчета = Форма.ВладелецФормы.ДатаНачала;
			Исключение
			КонецПопытки;

			Попытка
				Форма.мДатаКонцаПериодаОтчета = КонецДня(Форма.ВладелецФормы.ДатаОкончания);
			Исключение
			КонецПопытки;

			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;

			Если НЕ ЗаблокироватьДокумент(Форма.мСохраненныйДок) Тогда
				Возврат;
			КонецЕсли;
			
		КонецЕсли;
	Иначе

	КонецЕсли;
	
КонецПроцедуры

// ОперацииПриВосстановленииРегламентированногоОтчета
// Процедура вызывается из процедуры ВосстановитьСохраненныеДанные
//
Процедура ОперацииПриВосстановленииРегламентированногоОтчета(Форма) Экспорт

	Форма.мВариант = Форма.мСохраненныйДок.Вид;
	Если Форма.мВариант = Неопределено Тогда
		Форма.мВариант = 0;
	КонецЕсли;

	Если Форма.мВариант = 0 Тогда
		Форма.ВидДокумента = 0;
		Форма.ЭлементыФормы.НомерКорректировки.Доступность = Ложь;
	Иначе
		Форма.ВидДокумента = 1;
		Форма.ЭлементыФормы.НомерКорректировки.Доступность = Истина;
		Форма.НомерКорректировки = Форма.мВариант;
	КонецЕсли;

КонецПроцедуры // ОперацииПриВосстановленииРегламентированногоОтчета

// Прячет картинку-индикатор процесса сохранения с формы регламентированного отчета.
//
// Параметры:
//	Форма - форма с которой следует скрть картинку-индикатор.
//
Процедура СкрытьКартинкуСохранение(Форма) Экспорт
	
	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Событие возникает после записи из регалментированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой происходила запись в документ.
Процедура ПослеЗаписиРегламентированногоОтчета(Форма) Экспорт
	
	ЗаблокироватьДокумент(Форма.мСохраненныйДок);
	СкрытьКартинкуСохранение(Форма);
	Форма.мСкопированаФорма = Неопределено;
	Попытка
		Если Форма.мЗаписываетсяНовыйДокумент = Истина Тогда
			Оповестить("Позиционирование в списке отчетов", Форма.мСохраненныйДок.Ссылка);
		КонецЕсли;
	Исключение
	Конецпопытки;
	
КонецПроцедуры

// Определяет существуют ли документы РегламентированныйОтчет, совпадающие по ключевым реквизитам
// с редактируемым.
//
// Параметры:
//	Форма - форма, в которой редактируется текущий документ.
//	КодИФНС - код ИФНС, в которой 
//
// Возвращаемое значение:
//	Булево: Истина, если существует документ в аналогичными реквизитами;
//			Ложь - в противном случае.
//
Функция СуществуетДокументСАналогичнымиРеквизитами(Форма, КодИФНС)
	
	Попытка
		Вариант = Форма.ВидДокумента*Форма.НомерКорректировки;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("мСохраненныйДок", ?(Форма.мСохраненныйДок = Неопределено, Неопределено, Форма.мСохраненныйДок.Ссылка));
	Запрос.УстановитьПараметр("ИсточникОтчета", Форма.ЭтотОбъект.Метаданные().Имя);
	Запрос.УстановитьПараметр("Организация", Форма.Организация);
	Запрос.УстановитьПараметр("ДатаНачалаНач", НачалоДня(Форма.мДатаНачалаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаНачалаКон", КонецДня(Форма.мДатаНачалаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаКонцаНач", НачалоДня(Форма.мДатаКонцаПериодаОтчета));
	Запрос.УстановитьПараметр("ДатаКонцаКон", КонецДня(Форма.мДатаКонцаПериодаОтчета));
	Запрос.УстановитьПараметр("КодИМНС", КодИФНС);
	Запрос.УстановитьПараметр("Вариант", Вариант);
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	КОЛИЧЕСТВО(РегламентированныйОтчет.Ссылка)
	               |ИЗ
	               |	Документ.РегламентированныйОтчет КАК РегламентированныйОтчет
	               |ГДЕ
	               |	РегламентированныйОтчет.Ссылка <> &мСохраненныйДок
	               |	И РегламентированныйОтчет.ИсточникОтчета = &ИсточникОтчета
	               |	И РегламентированныйОтчет.Организация = &Организация
	               |	И РегламентированныйОтчет.ДатаНачала МЕЖДУ &ДатаНачалаНач И &ДатаНачалаКон
	               |	И РегламентированныйОтчет.ДатаОкончания МЕЖДУ &ДатаКонцаНач И &ДатаКонцаКон
	               |	И РегламентированныйОтчет.Вид = &Вариант";
				   
	Если КодИФНС <> "не применимо" Тогда
		Запрос.Текст = Запрос.Текст + "
	               |	И РегламентированныйОтчет.КодИМНС = &КодИМНС";
	КонецЕсли;
			   
	РезультатЗапроса = ЗАпрос.Выполнить().Выгрузить();			   
	Если РезультатЗапроса.Количество() = 0 ИЛИ РезультатЗапроса.Получить(0).Получить(0) = 0 Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Функция определяет были ли изменены в течение сеанса работы с регламентированным
// отчетом его ключевые реквизиты.
//
// Параметры:
//	Форма - Форма из которой вызван отчет.
//	КодИФНС - код ИФНС, в которую представляется отчет или "не применимо".
//
// Возвращаемое значение:
//	Булево: Истина, если ключевые реквизиты были изменены в течение сеанса редактирования отчета;
//			Ложь - в противном случае.
//
Функция БылиИзмененыКлючевыеРеквизитыОтчета(Форма, КодИФНС)
	
	Попытка
		Вариант = Форма.ВидДокумента*Форма.НомерКорректировки;
		мСохраненныйДок = Форма.мСохраненныйДок;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
	Если мСохраненныйДок = Неопределено ИЛИ Форма.мСкопированаФорма <> Неопределено Тогда
		Возврат Истина;
	Иначе
		Если КодИФНС = "не применимо" Тогда
			Возврат Вариант <> мСохраненныйДок.Вид;
		Иначе
			Возврат Вариант <> мСохраненныйДок.Вид ИЛИ СокрЛП(КодИФНС) <> СокрЛП(мСохраненныйДок.КодИМНС);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

// Событие возникает перед записью из регламентированного отчета информации в экземпляр документа
// РегламентированныйОтчет.
// Проверяет возможность записи данных в экземлпяр документа РегламентированныйОтчет из 
// переданной в качестве параметра Формы регламентированного отчета.
// В случае невозможности записи выдает предупреждение.
// Параметры:
// 		Форма - форма регламентированного отчета, из которой производится попытка записи данных в документ.
// Возвращаемое значение:
//		Булево - Истина, если запись возможна; Ложь - в противном случае.
Функция ПриЗаписиРегламентированногоОтчета(Форма, КодИФНС = "не применимо", Автосохранение = Ложь, Вариант = Неопределено) Экспорт
	
	Если Вариант <> Неопределено И (Автосохранение И Вариант <> Форма.мВариант) Тогда
		Возврат Ложь;
	КонецЕсли;

	КартинкаСохранение = Форма.ЭлементыФормы.Найти("КартинкаСохранение");
	Если КартинкаСохранение <> Неопределено Тогда
	    КартинкаСохранение.Видимость = Истина;
	КонецЕсли;
	
	Если Форма.мЗаписьЗапрещена = Истина Тогда
		Предупреждение("Невозможно сохранить отчет! Воспользуйтесь механизмом внешних регламентированных отчетов, встроенным в конфигурацию!");
		СкрытьКартинкуСохранение(Форма);
		Возврат Ложь;
	КонецЕсли;
	Если БылиИзмененыКлючевыеРеквизитыОтчета(Форма, КодИФНС) И СуществуетДокументСАналогичнымиРеквизитами(Форма, КодИФНС) Тогда
		Если Автосохранение Тогда
			СкрытьКартинкуСохранение(Форма);
			Возврат Ложь;
		Иначе
			Ответ = Вопрос("Внимание! Подобный отчет уже существует! Записать новый?", РежимДиалогаВопрос.ДаНет);
			Если Ответ = КодВозвратаДиалога.Нет Тогда
				СкрытьКартинкуСохранение(Форма);
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	Форма.мЗаписываетсяНовыйДокумент = (Форма.мСохраненныйДок = Неопределено ИЛИ Форма.мСкопированаФорма <> Неопределено);
	
	Если Вариант <> Неопределено И ((Форма.мСохраненныйДок = Неопределено) ИЛИ (Форма.мСкопированаФорма <> Неопределено) ИЛИ (Вариант <> Форма.мВариант)) Тогда
		// Отчет новый или был скопирован.

		Если Форма.мСохраненныйДок = Неопределено ИЛИ Форма.мСкопированаФорма <> Неопределено Тогда
			// создаем новый документ вида РегламентированныйОтчет
				
			// создаем новый документ вида РегламентированныйОтчет
			Форма.мСохраненныйДок  = Документы.РегламентированныйОтчет.СоздатьДокумент();
			ЗаблокироватьДокумент(Форма.мСохраненныйДок);
			Форма.мЗаписываетсяНовыйДокумент = Истина;
			Форма.мСохраненныйДок.Дата = Форма.мДатаКонцаПериодаОтчета;
			Форма.мСохраненныйДок.УстановитьВремя();
			
		ИначеЕсли Вариант <> Форма.мВариант Тогда
			
			Ответ = роПолучитьОбщуюФорму("ВопросПриИзмененииВидаДокументаНомераКорректировки").ОткрытьМодально();
			Если Ответ = КодВозвратаДиалога.Да Тогда
				Если Форма.мСохраненныйДок.Заблокирован() Тогда
					Форма.мСохраненныйДок.Разблокировать();
				КонецЕсли;
				
				Форма.мСохраненныйДок  = Документы.РегламентированныйОтчет.СоздатьДокумент();
				ЗаблокироватьДокумент(Форма.мСохраненныйДок);
				Форма.мЗаписываетсяНовыйДокумент = Истина;
				Форма.мСохраненныйДок.Дата = Форма.мДатаКонцаПериодаОтчета;
				Форма.мСохраненныйДок.УстановитьВремя();
			ИначеЕсли Ответ <> КодВозвратаДиалога.Нет Тогда
				СкрытьКартинкуСохранение(Форма);
				Возврат Ложь;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Событие возникает при закрытии регламентированного отчета
//
// Параметры:
// 		Форма - закрываемая форма регламентированного отчета.
//
Процедура ПриЗакрытииРегламентированногоОтчета(Форма) Экспорт
	
	Если Форма.мСохраненныйДок <> Неопределено И Форма.мСохраненныйДок <> ОбщегоНазначения.ПустоеЗначениеТипа(ТипЗнч(Форма.мСохраненныйДок)) И Форма.мСохраненныйДок.Заблокирован() Тогда
		Форма.мСохраненныйДок.Разблокировать();
	КонецЕсли;
	
КонецПроцедуры

// Событие возникает перед закрытием регламентированного отчета
//
// Параметры:
// 		Форма - закрываемая форма регламентированного отчета;
//		Отказ - признак отказа от закрытия формы;
//		СтандартнаяОбработка - признак выполнения стандартной системной обработки события.
//
Процедура ПередЗакрытиемРегламентированногоОтчета(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	Если Форма.Модифицированность Тогда

		Ответ = Вопрос("Данные были изменены. Сохранить изменения?", РежимДиалогаВопрос.ДаНетОтмена, , КодВозвратаДиалога.Да);

		Если Ответ = КодВозвратаДиалога.Да Тогда
			Если НЕ Форма.Сохранить() Тогда
				Отказ = Истина;
			КонецЕсли;
		ИначеЕсли Ответ = КодВозвратаДиалога.Отмена Тогда
			Отказ = Истина;
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры	
	
////////////////////////////////////////////////////////////////////////////////
// ОБЩИЕ ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ВЫГРУЗКИ В ЭЛЕКТРОННОМ ВИДЕ, 
// ИСПОЛЬЗУЕМЫЕ В РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТАХ
//

// Процедура добавляет строку в таблицу сообщений, заполняемую при выгрузке регламентированного отчета.
// Параметры:
//		Форма - форма, из которой вызывается процедура;
//		Описание - описание ошибки;
//		Раздел - наименование раздела;
//		ИмяЯчейки - имя области на табличном поле, соответвующей показателю, с которым связана ошибка;
//		ФИО - ФИО физлица (для случая, когда ошибка обнаружена при проверке раздела ФизЛица).
Процедура роСообщитьВТаблицуСообщений(Форма, Описание, Раздел, ИмяЯчейки, ФИО = "") Экспорт
	
	НовСтр = Форма.ТаблицаСообщений.Добавить();
	НовСтр.Раздел = Раздел;
	НовСтр.ИмяЯчейки = ИмяЯчейки; 
	НовСтр.Описание = Описание;
	НовСтр.Страница = ФИО;
	
КонецПроцедуры

// Функция возвращает номер страницы раздела "Физлица", соответствующей переданному в качестве параметра строке - ФИО физлица.
// Параметры:
//		Форма - форма, из которой вызывается функция;
//		ФИО - строка, содержащая ФИО физлица.
// Возвращаемое значение:
//		Число - порядковый номер страницы, соответствующей указанному в качестве параметра ФИО.
Функция роНомерСтраницыПоФИОФизЛица(Форма, ФИО) Экспорт
	
	Если ТипЗнч(ФИО) = Тип("Число") Тогда
		Возврат ФИО;
	КонецЕсли;
	
	Ном = 0;
	Для Каждого Стр Из Форма.мСтруктураМногостраничныхРазделов.ФизЛица Цикл
		Ном = Ном + 1;
		Если Стр.Данные.ФизЛицФИО = ФИО Тогда
			Возврат Ном;
		КонецЕсли;
	КонецЦикла;
	Возврат 1; 
	
КонецФункции

// Процедура активизирует ячейку на поле табличного документа.
// Описание ячейки задается в виде строки таблицы значений.
// Параметры:
//		Форма - форма, из которой вызывается процедура;
//		Ячейка - строка таблицы значений, содержащая описание активизируемой ячейки.
Процедура роАктивизироватьЯчейку(Форма, Ячейка) Экспорт
	
	Попытка
		НомСтраницы = 0;
		
		Для Каждого СтрПан Из Форма.ЭлементыФормы.ОсновнаяПанель.Страницы Цикл
			НомСтраницы = НомСтраницы + 1;
			
			Если СтрПан.Имя = Ячейка.Раздел Тогда
				Форма.ЭлементыФормы.ОсновнаяПанель.ТекущаяСтраница = СтрПан;
				Форма.ОсновнаяПанельПриСменеСтраницы(Форма.ЭлементыФормы.ОсновнаяПанель, НомСтраницы);
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	Исключение
	КонецПопытки;
	
	Если Ячейка.Раздел = "ФизЛица" Тогда
		Попытка
			НС = роНомерСтраницыПоФИОФизЛица(Форма, Ячейка.Страница);
			Форма.ПоказатьСтраницуМногостраничногоРаздела(НС - 1, Ячейка.Раздел, Истина);
			ИмяСтраницы = НС;
		Исключение
		КонецПопытки;
	Иначе
		Попытка
			Форма.ПоказатьСтраницуМногостраничногоРаздела(Число(Ячейка.Страница) - 1, Ячейка.Раздел, Истина);
			ИмяСтраницы = Ячейка.Страница;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	ПолеТД = Форма.ЭлементыФормы["ПолеТабличногоДокумента" + Ячейка.Раздел];
	
	Попытка
		
		ПолеТД.ТекущаяОбласть = ПолеТД.Области.Найти(Ячейка.ИмяЯчейки);
		ИмяОбласти = Ячейка.ИмяЯчейки;
		
	Исключение
		
		Если (Ячейка.СтрокаПП <> Неопределено) И (НЕ (ПустаяСтрока(Ячейка.СтрокаПП))) Тогда
			
			Попытка
				ПолеТД.ТекущаяОбласть = ПолеТД.Области.Найти(Ячейка.ИмяЯчейки + Ячейка.СтрокаПП);
				ИмяОбласти = Ячейка.ИмяЯчейки + Ячейка.СтрокаПП;
			Исключение
				
				Попытка
					ПолеТД.ТекущаяОбласть = ПолеТД.Области.Найти(Ячейка.ИмяЯчейки + "_" + Ячейка.СтрокаПП);
					ИмяОбласти = Ячейка.ИмяЯчейки + "_" + Ячейка.СтрокаПП;
				Исключение
					
				КонецПопытки;
				
			КонецПопытки;
			
		Иначе
			
			Попытка
				ПолеТД.ТекущаяОбласть = ПолеТД.Области.Найти(Ячейка.ИмяЯчейки + "1");
				ИмяОбласти = Ячейка.ИмяЯчейки + "1";
			Исключение
				
				Попытка
					ПолеТД.ТекущаяОбласть = ПолеТД.Области.Найти(Ячейка.ИмяЯчейки + "_1");
					ИмяОбласти = Ячейка.ИмяЯчейки + "_1";
				Исключение
					
					ПолеТД.ТекущаяОбласть = ПолеТД.Область(Ячейка.ИмяЯчейки);
					
				КонецПопытки;
				
			КонецПопытки;
			
		КонецЕсли;
		
	КонецПопытки;
	
	//ПолеТД.Область(ИмяОбласти).Примечание.ВыводитьНаПечать = Ложь;
	
	Форма.ТекущийЭлемент = ПолеТД;
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА АВТОСОХРАНЕНИЯ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ
//

// Функция возвращает значение интервала автосохранения отчетов (в минутах)
// для пользователя текущего сеанса.
//
// Функция не имеет параметров.
// Возвращаемое значение: Число - интервал автосохранения регламентированных отчетов.
Функция ЗначениеИнтервалаАвтосохраненияРегламентированнойОтчетности() Экспорт
	
	ИнтервалАвтосохраненияРегламентированнойОтчетности = ВосстановитьЗначение("ИнтервалАвтосохраненияРегламентированнойОтчетности");
	Если ИнтервалАвтосохраненияРегламентированнойОтчетности = Неопределено Тогда
		ИнтервалАвтосохранения = 10;
	Иначе
		ИнтервалАвтосохранения = ИнтервалАвтосохраненияРегламентированнойОтчетности;
	КонецЕсли;
	Возврат ИнтервалАвтосохранения;
	
КонецФункции

// Процедура подключает обработчик ожидания в выбранной форме для механизма автосохранения.
//
// Параметры:
//	Форма - форма, для которой необходимо подключить обработчик ожидания.
//
Процедура ВключитьОбработчикАвтосохранения(Форма) Экспорт
	
	Форма.мИнтервалАвтосохранения = ЗначениеИнтервалаАвтосохраненияРегламентированнойОтчетности();
	Если Форма.мИнтервалАвтосохранения <> 0 Тогда
		Форма.ПодключитьОбработчикОжидания("ОбработчикСобытияПоТаймеру", Цел(Форма.мИнтервалАвтосохранения * 60));
	КонецЕсли;
		
КонецПроцедуры

// Процедура отключает обработчик ожидания в выбранной форме для механизма автосохранения.
//
// Параметры:
//	Форма - форма, для которой необходимо отключить обработчик ожидания.
//
Процедура ОтключитьОбработчикАвтосохранения(Форма) Экспорт
	
	Форма.ОтключитьОбработчикОжидания("ОбработчикСобытияПоТаймеру");
		
КонецПроцедуры

// Функция определяет возможность использования регламентированного отчета текущим пользователем.
//
// Параметры:
//	ИдентификаторОтчета - строка - уникальный идентификатор регламентированного отчета.
//
// Возвращаемое значение:
//	Булево. Истина - пользователь имеет право использовать отчет.
//			Ложь - пользователь не имеет право использовать отчет.
//			Неопределено - указанный отчет не зарегистрирован в системе.
//
Функция ПравоДоступаКРегламентированномуОтчету(ИдентификаторОтчета) Экспорт
	
	Если ЭтоВнешнийОтчет(ИдентификаторОтчета) <> Истина Тогда // это внутренний отчет
		
		Если Метаданные.Документы.Найти(ИдентификаторОтчета) <> Неопределено Тогда // это документ
			
			Если НЕ ПравоДоступа("Изменение", Метаданные.Документы[ИдентификаторОтчета]) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли Метаданные.Отчеты.Найти(ИдентификаторОтчета) <> Неопределено Тогда // это отчет
			
			Если НЕ ПравоДоступа("Использование", Метаданные.Отчеты[ИдентификаторОтчета]) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции	
	
///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПЕЧАТИ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ С ДВУХМЕРНЫМ ШТРИХКОДОМ
//

// Функция формирует файл с электронным представлением регалментированного отчета.
//
// Параметры:
//	Форма - вызывающая форма отчета, файл с электронным представлением которого необходимо сформировать.
//	ВремФайл - полное имя файла.
//
// Возвращаемое значение:
//	Булево - Истина, если выгрузка прошла успешно; Ложь - в противном случае.
//
Функция СформироватьТекстВыгрузки(Форма, ВремФайл) Экспорт
	
	НовыйДок = Документы.ВыгрузкаРегламентированныхОтчетов.СоздатьДокумент();
	СпДокОсн = Новый СписокЗначений;
	СпДокОсн.Добавить(Форма.мСохраненныйДок);
 	Возврат НовыйДок.ПолучитьФорму(, Форма).СформироватьИЗаписать(СпДокОсн, , , ВремФайл);
	
КонецФункции

// Функция возвращает признак печати раздела.
//
// Параметры:
//	Форма - вызывающая форма регламентированного отчета.
//	СтрокаРаздела - СтрокаДереваЗначений с описанием раздела.
//
// Возвращаемое значение:
//	Число - 1, если раздел печатается; в противном случае - 0.
//
Функция ПечататьРаздел(Форма, СтрокаРаздела, ЧтоИскать = Неопределено) Экспорт
	Перем КлючФизЛица;
	
	Если ЧтоИскать <> Неопределено Тогда
		Возврат 1;
	КонецЕсли;
	
	// если в настройках взведен флаг печати, то добавляем раздел в список печатаемых и выходим
	Если СтрокаРаздела.ВыводНаПечать <> 0 Тогда
		Форма.мПечатаемыеРазделы.Добавить(СтрокаРаздела.ИмяСтраницы);
		Возврат 1;
	КонецЕсли;
	
	
	Возврат 0;
	
КонецФункции
	
// Функция возвращает общую форму регламентированной отчетности.
//
// Параметры:
//	ИмяФормы - строка с именем запрашиваемой формы.
//	Владелец - форма-владелец открываемой формы.
//	КлючУникальности - ключ для поиска уже открытых форм.
//
// Возвращаемое значение:
//	Форма - запрошенная общая форма регламентированной отчетности 
//			или Неопределено в случае отсутствия общей формы с указанным именем.
//
Функция роПолучитьОбщуюФорму(ИмяФормы, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	
	Если ((ИДКонфигурации() = "БП" И РедакцияКонфигурации() <> "1.0")
		ИЛИ (ИДКонфигурации() = "ЗУП")) И ВРЕГ(ИмяФормы) = "ВВОДРОССИЙСКОГОАДРЕСА" Тогда
		Возврат Обработки.РедактированиеКонтактнойИнформации.ПолучитьФорму("ФормаЗаписиАдреса", Владелец, КлючУникальности);
	КонецЕсли;
	
	Если Метаданные.Обработки.ОбщиеОбъектыМСФООтчетности.Формы.Найти(ИмяФормы) <> Неопределено Тогда
		Возврат Обработки.ОбщиеОбъектыМСФООтчетности.ПолучитьФорму(ИмяФормы, Владелец, КлючУникальности);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ПОИСКА
//

// Функция возвращает признак "вхождения" одного значения в другое, то есть
// если поиск производится в строках, то одна строка проверяется на вхождение в другую
// (без учета регистра), а в остальных случаях значения проверяются на равенство.
//
// Параметры:
//	ГдеИскать - значение, в котором следует произвести поиск.
//	ЧтоИскать - значение, которое следует найти.
//
// Возвращаемое значение:
//	Булево - признак "вхождения" одного значения в другое.
//
Функция ЗначениеСодержитЗначение(ГдеИскать, ЧтоИскать)
	
	ТипГдеИскать = ТипЗнч(ГдеИскать);
	Если ТипГдеИскать <> Тип("Строка") Тогда
		Если ТипГдеИскать = Тип("Число") Тогда
			СтрокаГдеИскать = Формат(ГдеИскать, "ЧГ=");
		ИначеЕсли ТипГдеИскать = Тип("Дата") Тогда
			СтрокаГдеИскать = Формат(ГдеИскать, "ДФ=dd.MM.yyyy");
		Иначе
			СтрокаГдеИскать = Строка(ГдеИскать);
		КонецЕсли;
	Иначе
		СтрокаГдеИскать = ГдеИскать;
	КонецЕсли;
	
	Возврат (Найти(ВРЕГ(СтрокаГдеИскать), ВРЕГ(ЧтоИскать.ИскомоеЗначение)) <> 0);
	
КонецФункции

// Процедура вызывается при нажатии на кнопку "Поиск" верхней командной панели
// регламентированного отчета.
// Выводит форму критериев поиска, запускает процедуру поиска и выводит окно с результатами.
//
// Параметры:
//	Форма - форма в которой следует произвести поиск.
//
Процедура роПоискВРегламентированномОтчете(Форма) Экспорт
	
	ФормаПоиска = роПолучитьОбщуюФорму("НастройкиПоиска", Форма);
	ЧтоИскать = ФормаПоиска.ОткрытьМодально();
	Если ЧтоИскать = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Форма.мРезультатПоиска = Новый ТаблицаЗначений;
	Форма.мРезультатПоиска.Колонки.Добавить("Раздел");
	Форма.мРезультатПоиска.Колонки.Добавить("Страница");
	Форма.мРезультатПоиска.Колонки.Добавить("НаименованиеЛиста");
	Форма.мРезультатПоиска.Колонки.Добавить("ИмяЯчейки");
	Форма.мРезультатПоиска.Колонки.Добавить("СтрокаПП");
	Форма.мРезультатПоиска.Колонки.Добавить("НайденоВСтроке");
	
	Форма.мСчетчикиСтраницПриПоиске = Новый ТаблицаЗначений;
	Форма.мСчетчикиСтраницПриПоиске.Колонки.Добавить("ИмяТабличногоПоля");
	Форма.мСчетчикиСтраницПриПоиске.Колонки.Добавить("Счетчик");
	
	Форма.Печать("", ЧтоИскать);
	
	Состояние("Поиск завершен.");
	//РезультатПоиска.ВыбратьСтроку();
	Если Форма.мРезультатПоиска.Количество() = 0 Тогда
		Предупреждение("По Вашему запросу ничего не найдено!");
		Возврат;
	КонецЕсли;
	
	ФормаРезультатыПоиска = роПолучитьОбщуюФорму("РезультатыПоиска", Форма);
	Если ФормаРезультатыПоиска.Открыта() Тогда
		ФормаРезультатыПоиска.Закрыть();
	КонецЕсли;
	ФормаРезультатыПоиска.Заголовок = Форма.Заголовок + " - результаты поиска значения [" + ЧтоИскать.ИскомоеЗначение + "]";
	ФормаРезультатыПоиска.ЗакрыватьПриЗакрытииВладельца = Истина;
	ФормаРезультатыПоиска.ЭлементыФормы.РезультатыПоиска.Значение = Форма.мРезультатПоиска.Скопировать();
	ФормаРезультатыПоиска.НадписьНайдено = "Найдено: " + Формат(Форма.мРезультатПоиска.Количество(), "ЧГ=");
	ФормаРезультатыПоиска.Открыть();
	
КонецПроцедуры

// Вычисляет значение показателя отчета по указанному "корню" имени показателя
// Например, 
// для показателей "ИНН_1"," ИНН_2" и т.д. "корнем" является "ИНН"
// для показателей "КПП1_1", "КПП1_2" и т.д. "корнем" является "КПП1"
// Параметры:
// Табл - таблица значений, описывающая показатели листа отчета
// Корень - строка - "корень", значение для которого требуется получить 
Функция поискВычислитьЗначениеПоКорню(Табл, Корень)
	
	Табл2 = Табл.Скопировать();
	ИтоговоеЗначение = "";
	Для Каждого Стр Из Табл2 Цикл
		Если Стр.Корень = Корень Тогда
			ИтоговоеЗначение = ИтоговоеЗначение + Стр.Знач;
		КонецЕсли;
	КонецЦикла;
	
	Если ((ВРЕГ(Лев(Корень, 4)) = "ДАТА") ИЛИ (СтрЧислоВхождений(Корень, "Дата") <> 0)) 
		И (((СтрДлина(ИтоговоеЗначение)=8) ИЛИ (СтрДлина(ИтоговоеЗначение)=6)) ИЛИ (ПустаяСтрока(ИтоговоеЗначение)))Тогда
		
		Если ПустаяСтрока(ИтоговоеЗначение) Тогда
			ИтоговоеЗначение = "00.00.0000";
		Иначе
			ИтоговоеЗначение = Лев(ИтоговоеЗначение, 2) + "." + Сред(ИтоговоеЗначение, 3, 2) + "." + Сред(ИтоговоеЗначение, 5);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ИтоговоеЗначение;
	
КонецФункции

//Функция собирает значения из отдельных "ячеек", например, ИНН1 из ИНН1_1 + ИНН1_2 + ...
Функция ПолучитьХарактеристикиЗначенийТабличногоПоля(Данные)
	
	ТП = Новый ТаблицаЗначений;
	ТП.Колонки.Добавить("Имя");
	ТП.Колонки.Добавить("Кол");
	ТП.Колонки.Добавить("Номер");
	ТП.Колонки.Добавить("Знач");
	ТП.Колонки.Добавить("Корень");
	
	Для Каждого Стр Из Данные Цикл
		НоваяСтрока = ТП.Добавить();
		НоваяСтрока.Имя = Стр.Ключ;
		НоваяСтрока.Кол = 1;
		НоваяСтрока.Знач = Стр.Значение;
	КонецЦикла;
	
	ТП.Сортировать("Имя");
	
	Для Каждого Стр Из ТП Цикл
		Имя = Стр.Имя;
		
		Если ЭтоКодПоказателяП(Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		ПризнакКвадратика = Ложь;//признак того, что значение является частью другого значения
		
		НомерСимвола = СтрДлина(Имя);
		Было_ = Ложь;//признак того, что в текущем наименовании показателя уже встречался символ "_"
		БылаЦифра = Ложь;
		
		Пока НомерСимвола > 0 Цикл
			
			Симв = Сред(Имя, НомерСимвола, 1);
			КодСимв = КодСимвола(Симв, 1);
			
			Если (КодСимв >= КодСимвола("0", 1) И КодСимв <= КодСимвола("9", 1)) ИЛИ (Симв = "_") Тогда
				
				Если Симв = "_" Тогда
					Если БылаЦифра Тогда
						
						ПризнакКвадратика = Истина;
						НомерСимвола = НомерСимвола - 1;
						Прервать;
						
					КонецЕсли;
				Иначе//это цифра
					БылаЦифра = Истина;
				КонецЕсли;
				
			Иначе
				Прервать;
			КонецЕсли;
			
			НомерСимвола = НомерСимвола - 1;
			
		КонецЦикла;
		
		Если БылаЦифра Тогда
			Корень = Лев(Стр.Имя, НомерСимвола);
			Номер = Сред(Стр.Имя, НомерСимвола + 1);
			Попытка
				Стр.Номер = Число( ?( Лев(Номер, 1) = "_", Сред(Номер, 2), Номер));
			Исключение
				Сообщить("Ошибки преобразования номера из окончания: " + Корень + " === " + Номер, СтатусСообщения.Важное);
			Конецпопытки;
			Стр.Корень = Корень;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Стр Из ТП Цикл
		Если НЕ ЗначениеЗаполнено(Стр.Корень) Тогда
			Стр.Корень = Стр.Имя;
		КонецЕсли;
	КонецЦикла;
	
	ТП.Сортировать("Корень, Номер");
	
	ТП2 = ТП.Скопировать();
	ТП2.Свернуть("Корень", "Кол");
	
	Для Каждого Стр Из ТП2 Цикл
		Если Стр.Кол > 1 И Стр.Корень <> "П" Тогда
			СтрокиДляУдаления = ТП.НайтиСтроки(Новый Структура("Корень", Стр.Корень));
			НовоеИмя = СтрокиДляУдаления[0].Имя;
			Для Каждого Эл Из СтрокиДляУдаления Цикл
				Данные.Удалить(Эл.Имя);
			КонецЦикла;
			Данные.Вставить(НовоеИмя, поискВычислитьЗначениеПоКорню(ТП, Стр.Корень));
		КонецЕсли;
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

// Процедура производит поиск в указанной форме. 
// Параметры поиска задаются в структуре СтруктураПоиска.
//
// Параметры:
//	Форма - форма, в которой производится поиск.
//	СтруктураПоиска - структура, задающая условия поиска.
//
Процедура роНайтиЗначение(Форма, СтруктураПоиска, НеСворачивать = Ложь) Экспорт
	
	ТаблДок = Форма.ЭлементыФормы[СтруктураПоиска.ИмяТабличногоПоля];
	СтрокаСчетчикаТабличногоПоля = Форма.мСчетчикиСтраницПриПоиске.Найти(СтруктураПоиска.ИмяТабличногоПоля, "ИмяТабличногоПоля");
	Если СтрокаСчетчикаТабличногоПоля = Неопределено Тогда
		СтрокаСчетчикаТабличногоПоля = Форма.мСчетчикиСтраницПриПоиске.Добавить();
		СтрокаСчетчикаТабличногоПоля.ИмяТабличногоПоля = СтруктураПоиска.ИмяТабличногоПоля;
		СтрокаСчетчикаТабличногоПоля.Счетчик = 0;
	КонецЕсли;
	СтрокаСчетчикаТабличногоПоля.Счетчик = СтрокаСчетчикаТабличногоПоля.Счетчик + 1;
	
	Состояние("Поиск в разделе """ + СтруктураПоиска.НаименованиеЛиста + """" 
			+ ?(СтрокаСчетчикаТабличногоПоля.Счетчик = 1, "", " лист №" + СтрокаСчетчикаТабличногоПоля.Счетчик) + " (найдено " + Форма.мРезультатПоиска.Количество() + ") ...");
	
	Если СтруктураПоиска.ЧтоИскать.ИскатьВТексте Тогда
		
		Для Стр = 1 По ТаблДок.ВысотаТаблицы Цикл
			Для Кол = 1 По ТаблДок.ШиринаТаблицы Цикл
				Обл = ТаблДок.Область(Стр, Кол, Стр, Кол);
				Если ЗначениеСодержитЗначение(Обл.Текст, СтруктураПоиска.ЧтоИскать) Тогда
					
					НовСтр = Форма.мРезультатПоиска.Добавить();
					НовСтр.Раздел = Сред(СтрокаСчетчикаТабличногоПоля.ИмяТабличногоПоля, 24);
					НовСтр.Страница = СтрокаСчетчикаТабличногоПоля.Счетчик;
					НовСтр.НаименованиеЛиста = СтруктураПоиска.НаименованиеЛиста;
					НовСтр.ИмяЯчейки = Обл.Имя;
					НовСтр.НайденоВСтроке = Обл.Текст;
					
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
	Иначе
		
		ЗначащиеЯчейки = Новый Структура;
		
		Для Каждого Обл Из ТаблДок.Области Цикл
			Если Обл.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник И Обл.СодержитЗначение = Истина Тогда
				ЗначащиеЯчейки.Вставить(Обл.Имя, Обл.Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если СтрДлина(СтруктураПоиска.ЧтоИскать.ИскомоеЗначение) > 1 И НЕ НЕСворачивать Тогда
			ЗначащиеЯчейки = ПолучитьХарактеристикиЗначенийТабличногоПоля(ЗначащиеЯчейки);
		КонецЕсли;
		
		РезультатПоиска = Новый ТаблицаЗначений;
		РезультатПоиска.Колонки.Добавить("Раздел");
		РезультатПоиска.Колонки.Добавить("Страница");
		РезультатПоиска.Колонки.Добавить("НаименованиеЛиста");
		РезультатПоиска.Колонки.Добавить("ИмяЯчейки");
		РезультатПоиска.Колонки.Добавить("СтрокаПП");
		РезультатПоиска.Колонки.Добавить("НайденоВСтроке");
		РезультатПоиска.Колонки.Добавить("НомерСтроки");
		РезультатПоиска.Колонки.Добавить("НомерКолонки");
		
		Для Каждого Обл Из ЗначащиеЯчейки Цикл
			Если ЗначениеСодержитЗначение(Обл.Значение, СтруктураПоиска.ЧтоИскать) Тогда
				
				НовСтр = РезультатПоиска.Добавить();
				НовСтр.Раздел = Сред(СтрокаСчетчикаТабличногоПоля.ИмяТабличногоПоля, 24);
				НовСтр.Страница = СтрокаСчетчикаТабличногоПоля.Счетчик;
				НовСтр.НаименованиеЛиста = СтруктураПоиска.НаименованиеЛиста;
				НовСтр.ИмяЯчейки = Обл.Ключ;
				НовСтр.НайденоВСтроке = Обл.Значение;
				
				ИскомаяЯчейка = ТаблДок.Области.Найти(НовСтр.ИмяЯчейки);
				Если ИскомаяЯчейка = Неопределено Тогда
					ИскомаяЯчейка = ТаблДок.Области.Найти(НовСтр.ИмяЯчейки + "_1");
				КонецЕсли;
				
				Если ИскомаяЯчейка = Неопределено Тогда
					ИскомаяЯчейка = ТаблДок.Области.Найти(НовСтр.ИмяЯчейки + "1");
				КонецЕсли;
				
				Если ИскомаяЯчейка = Неопределено Тогда
					НовСтр.НомерСтроки = 0;
					НовСтр.НомерКолонки = 0;
				Иначе
					НовСтр.НомерСтроки = ИскомаяЯчейка.Верх;
					НовСтр.НомерКолонки = ИскомаяЯчейка.Лево;
				КонецЕсли;
				
			КонецЕсли;
		КонецЦикла;
		
		РезультатПоиска.Сортировать("НомерСтроки, НомерКолонки");
		
		Для Каждого Стр Из РезультатПоиска Цикл
			
			НовСтр = Форма.мРезультатПоиска.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтр, Стр);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Создает соответствующий экземпляру документа вида РегламентированныйОтчет объект Отчет
// и инициализирует основные переменные объекта.
//
// Параметры:
//	Док - ДокументСсылка.РегламентированныйОтчет, который требуется "открыть".
//
// Возвращаемое значение:
//	Форма, если удалось создать соответствующий отчет или Неопределено в противном случае.
//
Функция ИнициализацияОтчета(Док, Форма = Неопределено) Экспорт

	Отчет = РеглОтчеты(Док.ИсточникОтчета).ПолучитьФорму(, , Новый УникальныйИдентификатор);
	Отчет.мСохраненныйДок = Док.ПолучитьОбъект();
			
	// определяем границы периода построения отчета
	Отчет.мДатаНачалаПериодаОтчета = НачалоДня(Отчет.мСохраненныйДок.ДатаНачала);
	Отчет.мДатаКонцаПериодаОтчета  = КонецДня(Отчет.мСохраненныйДок.ДатаОкончания);
			
	// в некоторых отчетах (формы баланса, например) переменная мПериодичность не определена
	Попытка
		Отчет.мПериодичность = Отчет.мСохраненныйДок.Периодичность;
	Исключение
	КонецПопытки;

	ВыбраннаяФорма = Док.ВыбраннаяФорма;
			
	Если Отчет.ЭтотОбъект.Метаданные().Формы.Найти(СокрП(ВыбраннаяФорма)) <> Неопределено Тогда
		ВыбФормаОтчета = Отчет.ПолучитьФорму(СокрП(ВыбраннаяФорма), Форма, Новый УникальныйИдентификатор);
	Иначе
		// Если не удалось найти форму с таким названием (могла быть переименована),
		// то по умолчанию выдаем текущую (действующую) форму
		ВыбраннаяФорма = Отчет.мТаблицаФормОтчета[0].ФормаОтчета;
		ВыбФормаОтчета = Отчет.ПолучитьФорму(ВыбраннаяФорма, Форма, Новый УникальныйИдентификатор);
	КонецЕсли;
			
	// Попытка получения переменной мВерсияФормы сохраненного документа для сравнения
	// с аналогичной переменной объекта отчет.
	Попытка
		ВерсияФормыДанных = Отчет.мСохраненныйДок.ДанныеОтчета.Получить().ВерсияФормы;
		Если НЕ ПродолжитьПриНесоответствииВерсийФорм(ВерсияФормыДанных, ВыбФормаОтчета.мВерсияФормы) Тогда
			Возврат Неопределено;
		КонецЕсли;
	Исключение
	Конецпопытки;
			
	Отчет.мВыбраннаяФорма = ВыбраннаяФорма;
	Возврат ВыбФормаОтчета;
	
КонецФункции	

// Пытается выгрузить регламентированный отчет.
//
// Параметры:
//	ДокументСсылка.РегламентированныйОтчет - отчет, коотрый требуется выгрузить.
//
// Возвращаемое значение:
//	Булево - Истина, если отчет удалось выгрузить; Ложь - в противном случае.
//
Функция ВыгрузитьОтчет(Док) Экспорт
	
	Попытка
		Отчет = ИнициализацияОтчета(Док);
		Если Отчет = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		Отчет.Инициализация(Истина);
		Отчет.Выгрузить();
		Отчет = Неопределено;
		Возврат Истина;
	Исключение
		Возврат Ложь;
	Конецпопытки;
	
КонецФункции

// Возвращает представление вида документа для отображения в журнале документов.
//
// Параметры:
//	Вариант - число, значение реквизита Вид документа РегламентированныйОтчет.
//
// Возвращаемое значение:
//	Строка - пользовательское представление вида документа для отображения в журнале.
//
Функция ПредставлениеВидаДокумента(Вид) Экспорт
	
	Если Вид = 0 Тогда
		Возврат "П";
	ИначеЕсли Вид = Неопределено Тогда
		Возврат "-";
	Иначе
		Возврат "К/" + Вид;
	КонецЕсли;
	
КонецФункции

// ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод
// Функция анализирует таблицу значений мТаблицаФормОтчета
// на предмет выявления форм, которые действуют за один и тот же период ("пересекаются")
// Параметры:
//  Нет.
// Возвращаемое значение:
//  ТаблицаЗначений, в которую входят строки из мТаблицаФормОтчета, удовлетворяющие 
//  условию/отбору по текущему установленному периоду.
//
Функция ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма) Экспорт

	// Объявим таблицу результата.
	РезультирующаяТаблица = Форма.мТаблицаФормОтчета.Скопировать();
	РезультирующаяТаблица.Очистить();

	// Осуществим перебор по таблице содеражащей формы отчетов и периоды действий.
	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ОбщегоНазначения.ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			// Перебираемая запись из таблицы форм удовлетворяет текущим параметрам
			// учитывая конец периода отчета.
			НоваяФорма = РезультирующаяТаблица.Добавить();
			НоваяФорма.ФормаОтчета        = ЭлФорма.ФормаОтчета;
			НоваяФорма.ОписаниеОтчета     = ЭлФорма.ОписаниеОтчета;
			НоваяФорма.ДатаНачалоДействия = ЭлФорма.ДатаНачалоДействия;
			НоваяФорма.ДатаКонецДействия  = ЭлФорма.ДатаКонецДействия;

		КонецЕсли;

	КонецЦикла;

	Возврат РезультирующаяТаблица;

КонецФункции // ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод

// Процедура назначает форму отчета по умолчанию 
//   при изменении периода представления отчета.
// При отсутствии формы, соответствующей выбранному 
//   периоду, по умолчанию выдаем текущую (действующую) форму.
//
// Вызывается из других процедур модуля.
// Выбор осуществляется не по таблице мТаблицаФорм, а по формам действующим
// в выбранный период (возвращается функцией ПолучитьТаблицуОтчетовВДействующих...
//
Процедура ВыборФормыРегламентированногоОтчетаПоУмолчанию(Форма) Экспорт

	ТаблицаФормОтчета = ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма);
	Для Каждого Стр Из ТаблицаФормОтчета Цикл
		Если Стр.ДатаКонецДействия = ОбщегоНазначения.ПустоеЗначениеТипа(Тип("Дата")) Тогда
			Стр.ДатаКонецДействия = '20291231';
		КонецЕсли;
	КонецЦикла;

	ТаблицаФормОтчета.Сортировать("ДатаКонецДействия Убыв");

	Для Каждого Строка Из ТаблицаФормОтчета Цикл
		Если (Строка.ДатаНачалоДействия > КонецДня(Форма.мДатаКонцаПериодаОтчета)) ИЛИ
			((Строка.ДатаКонецДействия > '00010101000000') И (Строка.ДатаКонецДействия < НачалоДня(Форма.мДатаКонцаПериодаОтчета))) Тогда

			Продолжить;
		КонецЕсли;

		Форма.мВыбраннаяФорма = Строка.ФормаОтчета;
		Форма.ЭлементыФормы.ОписаниеНормативДок.Значение = Строка.ОписаниеОтчета;

		Возврат;
	КонецЦикла;

	// Если не удалось найти форму, соответствующую выбранному периоду,
	// то по умолчанию выдаем текущую (действующую) форму.
	Если Форма.мВыбраннаяФорма = Неопределено Тогда
		Если ТаблицаФормОтчета.Количество() >= 1 Тогда
			мВыбраннаяФорма = Форма.мТаблицаФормОтчета[0].ФормаОтчета;
			Форма.ЭлементыФормы.ОписаниеНормативДок.Значение = Форма.мТаблицаФормОтчета[0].ОписаниеОтчета;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // ВыборФормыРегламентированногоОтчетаПоУмолчанию()

// КоличествоФормСоответствующихВыбранномуПериоду
//
Функция КоличествоФормСоответствующихВыбранномуПериоду(Форма) Экспорт

	ИтоговоеКоличество = 0;

	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ОбщегоНазначения.ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			ИтоговоеКоличество = ИтоговоеКоличество + 1; 

		КонецЕсли;

	КонецЦикла;

	Возврат ИтоговоеКоличество;

КонецФункции // КоличествоФормСоответствующихВыбранномуПериоду

// Функция вызывается по нажатию кнопки "Выбрать форму..." формы.
// Функция организует модальное окно, где предлагает пользователю указать какую из форм
// необходимо использовать для выбранного (текущего) периода.
// Параметры:
//  Формы          - ссылка на основную форму.
// Возвращаемое значение:
//  Название формы отчета. Аналог мВыбраннойФормы
//
Функция ВыбратьФормуОтчетаИзДействующегоСписка(Форма) Экспорт

	Результат = Неопределено;

	// Получим таблицу соответствующих периоду форм.
	ТаблицаВыбораФормы = ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма);

	// Если в таблице есть колонка нарастающий итог, то удалим её
	// используется в декларациях по алкогольной продукции.
	Если ТаблицаВыбораФормы.Колонки.Найти("НарастающийИтог") <> Неопределено Тогда
		ТаблицаВыбораФормы.Колонки.Удалить("НарастающийИтог");
	КонецЕсли;

	// Если в таблице есть колонка НаименованиеОтчета, то удалим её
	// используется в декларациях по алкогольной продукции.
	Если ТаблицаВыбораФормы.Колонки.Найти("НаименованиеОтчета") <> Неопределено Тогда
		ТаблицаВыбораФормы.Колонки.Удалить("НаименованиеОтчета");
	КонецЕсли;

	// В полученной таблице найдем текущую форму, чтобы сфокусировать на ней курсор выбора.
	НайденнаяСтрока = ТаблицаВыбораФормы.Найти(Форма.мВыбраннаяФорма, "ФормаОтчета");

	// Удалим колонку ФормаОтчета, чтобы не показывалась в форме выбора.
	ТаблицаВыбораФормы.Колонки.Удалить("ФормаОтчета");

	// Установим размеры колонок.
	ТаблицаВыбораФормы.Колонки[0].Ширина = 35;
	ТаблицаВыбораФормы.Колонки[0].Заголовок = "Утверждена";
	ТаблицаВыбораФормы.Колонки[1].Ширина = 14;
	ТаблицаВыбораФормы.Колонки[1].Заголовок = "Начало действия";
	ТаблицаВыбораФормы.Колонки.Добавить("Период");
	Для Каждого Стр Из ТаблицаВыбораФОрмы Цикл
		Если ПустоеЗначение(Стр.ДатаКонецДействия) Тогда
			Стр.Период = "По наст. время";
		Иначе
			Стр.Период = Формат(Стр.ДатаКонецДействия, "ДФ=дд.ММ.гггг");
		КонецЕсли;
	КонецЦикла;

	ТаблицаВыбораФормы.Колонки.Удалить("ДатаКонецДействия");
	ТаблицаВыбораФормы.Колонки[2].Ширина = 14;
	ТаблицаВыбораФормы.Колонки[2].Заголовок = "Конец действия";

	// Выведем диалог выбора форм.
	ВыбСтрока = ТаблицаВыбораФормы.ВыбратьСтроку("Выберите форму отчета", НайденнаяСтрока);

	// Если форма выбрана, то...
	Если Не ВыбСтрока = Неопределено Тогда

		// Организуем структуру поиска по таблице мТаблицаФормОтчетов, т.к. название формы было удалено.
		СтрОтбора = Новый Структура;
		СтрОтбора.Вставить("ОписаниеОтчета", ВыбСтрока.ОписаниеОтчета);

		// В эталонной таблице форм, найдем соответствующую форму.
		ВыбСтрока = Форма.мТаблицаФормОтчета.НайтиСтроки(СтрОтбора);

		// Получим название формы отчета (формы).
		// мВыбраннаяФорма = ВыбСтрока[0].ФормаОтчета;
		Результат = ВыбСтрока[0].ФормаОтчета;

		// Получим описание формы отчета.
		Форма.ЭлементыФормы.ОписаниеНормативДок.Значение = ВыбСтрока[0].ОписаниеОтчета;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ВыбратьФормуОтчетаИзДействующегоСписка

// Пытается напечатать регламентированный отчет.
//
// Параметры:
//	ДокументСсылка.РегламентированныйОтчет - отчет, который требуется напечатать.
//	ВидПечати - одно из двух значений: "ПоказатьБланк", если требуется показать окно
//										предварительного просмотра;
//									   "ПечататьСразу", если требуется вывести на печать
//										без предварительного просмотра.
//	ПечататьДвухмерныйШтрихКод - признак формирования печатных листов с нанесением двухмерного штрихкода.
//	ПроверятьСоотношенияПриПечатиИВыгрузки - признак проверки контрольных соотношений
//
// Возвращаемое значение:
//	Булево - Истина, если отчет удалось распечатать; Ложь - в противном случае.
//
Функция НапечататьОтчеты(Док, ВидПечати = "ПоказатьБланк", ПечататьДвухмерныйШтрихКод = Неопределено, Форма = Неопределено, ПроверятьСоотношенияПриПечатиИВыгрузки = Неопределено) Экспорт
	
	ПредПросмотр = роПолучитьОбщуюФорму("ПечатьРегламентированныхОтчетов", Форма);
	Если ПредПросмотр.Открыта() Тогда
		ПредПросмотр.Закрыть();
	КонецЕсли;
	Для Каждого Стр Из Док Цикл	
		ОбработкаПрерыванияПользователя();
		Попытка
			Отчет = ИнициализацияОтчета(Стр.Значение, Форма);
			Если Отчет = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			Отчет.Инициализация(Истина);

			Если ПроверятьСоотношенияПриПечатиИВыгрузки <> Неопределено И ПроверятьСоотношенияПриПечатиИВыгрузки <> 2 Тогда
				Попытка
					Отчет.мПроверятьСоотношенияПриПечатиИВыгрузки = ПроверятьСоотношенияПриПечатиИВыгрузки;
				Исключение
				КонецПопытки;
			КонецЕсли;

			Отчет.Печать(ВидПечати);
			Отчет = Неопределено;
		Исключение
			Сообщить(ПредставлениеДокументаРеглОтч(Стр.Значение) + ". Не удалось напечатать отчет! Вероятно, отчетом не предусмотрена возможность печати без открытия формы.", СтатусСообщения.Важное);
		КонецПопытки;
	КонецЦикла;
	
КонецФункции

Функция ПредставлениеПериодаДокументаВыгрузкаРегламентированныхОтчетов(Док) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Док) Тогда
		Возврат "";
	КонецЕсли;
	
	ГодДокСтрока = Формат(Год(Док.ПериодПо), "ЧГ=");
	МесяцДок = Месяц(Док.ПериодПо);
	Если МесяцДок = 1 Тогда
		Возврат "По итогам января " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 2 Тогда
		Возврат "По итогам февраля " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 3 Тогда
		Возврат "По итогам I квартала " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 4 Тогда
		Возврат "По итогам апреля " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 5 Тогда
		Возврат "По итогам мая " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 6 Тогда
		Возврат "По итогам II квартала " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 7 Тогда
		Возврат "По итогам июля " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 8 Тогда
		Возврат "По итогам августа " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 9 Тогда
		Возврат "По итогам III квартала " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 10 Тогда
		Возврат "По итогам октября " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 11 Тогда
		Возврат "По итогам ноября " + ГодДокСтрока + "г.";
	ИначеЕсли МесяцДок = 12 Тогда
		Возврат "По итогам " + ГодДокСтрока + "г.";
	КонецЕсли;
	
КонецФункции

// Пытается выгрузить регламентированные отчеты.
//
// Параметры:
//	ДокументСсылка.РегламентированныйОтчет - отчет, коотрый требуется выгрузить.
// Возвращаемое значение:
//	Булево - Истина, если отчет удалось выгрузить; Ложь - в противном случае.
//
Функция ВыгрузитьОтчеты(Доки) Экспорт
	
	Попытка
		Если ТипЗнч(Доки) <> Тип("СписокЗначений") ИЛИ Доки.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		Для Каждого Док Из Доки Цикл
			Если Док.Значение.Организация <> Доки.Получить(0).Значение.Организация Тогда
				Предупреждение("У выбранных отчетов различаются реквизиты ""Организация"". Пакетная выгрузка невозможна!");
				Возврат Истина;
			КонецЕсли;
			Если КонецДня(Док.Значение.ДатаОкончания) <> КонецДня(Доки.Получить(0).Значение.ДатаОкончания) Тогда
				Предупреждение("У выбранных отчетов различаются даты окончания периодов составления. Пакетная выгрузка невозможна!");
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
		НовыйДок = Документы.ВыгрузкаРегламентированныхОтчетов.СоздатьДокумент();
		НовыйДок.УстановитьВремя(РежимАвтоВремя.ТекущееИлиПоследним);
	 	НовыйДок.ПолучитьФорму().СформироватьИЗаписать(Доки);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

// Пытается выгрузить регламентированные отчеты.
//
// Параметры:
//	ДокументСсылка.РегламентированныйОтчет - отчет, коотрый требуется выгрузить.
//
// Возвращаемое значение:
//	Булево - Истина, если отчет удалось выгрузить; Ложь - в противном случае.
//
Функция ПроверитьРегламентированныеОтчеты(Доки) Экспорт
	
	Попытка
		Если ТипЗнч(Доки) <> Тип("СписокЗначений") ИЛИ Доки.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		//Для Каждого Док Из Доки Цикл
		//	Если Док.Значение.Организация <> Доки.Получить(0).Значение.Организация Тогда
		//		Предупреждение("У выбранных отчетов различаются реквизиты ""Организация"". Выгрузка невозможна!");
		//		Возврат Истина;
		//	КонецЕсли;
		//	Если КонецДня(Док.Значение.ДатаОкончания) <> КонецДня(Доки.Получить(0).Значение.ДатаОкончания) Тогда
		//		Предупреждение("У выбранных отчетов различаются даты окончания периодов составления. Проверка невозможна!");
		//		Возврат Истина;
		//	КонецЕсли;
		//КонецЦикла;
		НовыйДок = Документы.ВыгрузкаРегламентированныхОтчетов.СоздатьДокумент();
		НовыйДок.УстановитьВремя(РежимАвтоВремя.ТекущееИлиПоследним);
	 	НовыйДок.ПолучитьФорму().Проверить(Доки);
		Возврат Истина;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Процедура ПриНажатииНаКнопкуПереходаВРежимВводаДанных(Форма) Экспорт
	
	Форма.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.РежимВводаИнформации.Пометка = НЕ Форма.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.РежимВводаИнформации.Пометка;
	Если Форма.ЭлементыФормы.КоманднаяПанельФормы.Кнопки.РежимВводаИнформации.Пометка Тогда
		Форма.ЭлементыФормы.ПанельЭУВерхняя.Свертка = РежимСверткиЭлементаУправления.Верх;
		Если Форма.ЭлементыФормы.Найти("ПанельЭУНижняя") <> Неопределено Тогда
			Форма.ЭлементыФормы.ПанельЭУНижняя.Свертка = РежимСверткиЭлементаУправления.Низ;
		КонецЕсли;
	Иначе
		Форма.ЭлементыФормы.ПанельЭУВерхняя.Свертка = РежимСверткиЭлементаУправления.Нет;
		Если Форма.ЭлементыФормы.Найти("ПанельЭУНижняя") <> Неопределено Тогда
			Форма.ЭлементыФормы.ПанельЭУНижняя.Свертка = РежимСверткиЭлементаУправления.Нет;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция АвтосохранениеВозможно(Форма) Экспорт

	Возврат Форма.мЗаписьЗапрещена <> Истина И Форма.мСохраненныйДок <> Неопределено И Форма.мСохраненныйДок <> Новый("ДокументОбъект.РегламентированныйОтчет") И Форма.Модифицированность;
		
КонецФункции

#КонецЕсли
