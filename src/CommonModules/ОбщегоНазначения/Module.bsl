// Получение представления для документа, удостоверяющего личность
//
// Параметры
//  ДанныеФизЛица  – Коллекция данных физ. лица (структура, строка таблицы, ...), содержащая значения: 
//                   ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан  
//
// Возвращаемое значение:
//   Строка   – Представление документа, удостоверяющего личность
//
Функция ПолучитьПредставлениеДокументаФизЛица(ДанныеФизЛица)

	Возврат Строка(ДанныеФизЛица.ДокументВид) + " серия " +
			ДанныеФизЛица.ДокументСерия       + ", номер " +
			ДанныеФизЛица.ДокументНомер       + ", выданный " +
			Формат(ДанныеФизЛица.ДокументДатаВыдачи, "ДФ=dd.MM.yyyy")  + " " +
			ДанныеФизЛица.ДокументКемВыдан;

КонецФункции // ПолучитьПредставлениеДокументаФизЛица()

// Функция формирует фамилию и инициалы либо по наименованию элемента спр-ка ФизическиеЛица
//  либо по переданным строкам.
//  Если передан Объект, то извлеченная из него строка считается совокупностью 
//  Фамилия + Имя + Отчество, разделенными пробелами.
//
// Параметры
//  Объект		- строка или ссылка или объект элемента спр-ка ФизическиеЛица.
//  Фамилия		- фамилия физ. лица.
//  Имя			- имя физ. лица.
//  Отчество	- отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой. Побочные эффекты - переданная целая строка 
//  Побочные эффекты - переданная целая строка разбивается на подстроки, соответствующие
//  отдельным Фамилии,Имени и Отчеству
//
Функция ФамилияИнициалыФизЛица(Объект = "", Фамилия = " ", Имя = " ", Отчество = " ") Экспорт

	ТипОбъекта = ТипЗнч(Объект);
	Если ТипОбъекта = Тип("Строка") и Фамилия = " " Тогда
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(Объект)," ");
		
	ИначеЕсли ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или ТипОбъекта = Тип("СправочникОбъект.ФизическиеЛица") ИЛИ
			  ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") или ТипОбъекта = Тип("СправочникОбъект.СотрудникиОрганизаций") Тогда
			  
		Если ТипОбъекта = Тип("СправочникСсылка.ФизическиеЛица") или 
			ТипОбъекта = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Наименование = ПолучитьЗначениеРеквизита(Объект, "Наименование");
		Иначе
			Наименование = Объект.Наименование;
		КонецЕсли;
	
		// Избавление от возможных выражений в скобках, например (осн.), (вн. совм.).
		НачальнаяПозиция	= Найти(Наименование,"(");
		КонечнаяПозиция		= Найти(Наименование,")");
		ДлинаСтроки			= СтрДлина(Наименование);
		Если НачальнаяПозиция > 0 Тогда
			СтрокаДляОбработки = Лев(Наименование, НачальнаяПозиция - 1) + ?(КонечнаяПозиция > 0,Прав(Наименование, ДлинаСтроки - КонечнаяПозиция),"")
		Иначе
			СтрокаДляОбработки = Наименование;
		КонецЕсли; 
		ФИО = РазложитьСтрокуВМассивПодстрок(СокрЛП(СтрокаДляОбработки)," ");
		
	Иначе
		
		// используем возможно переданные отдельные строки
		Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"")
	КонецЕсли;
			
	КоличествоПодстрок = ФИО.Количество();
	Фамилия = ?(КоличествоПодстрок > 0,ФИО[0],"");
	Имя		= ?(КоличествоПодстрок > 1,ФИО[1],"");
	Отчество= ?(КоличествоПодстрок > 2,ФИО[2],"");
	
	Возврат ?(НЕ ПустаяСтрока(Фамилия), 
				Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + ?(НЕ ПустаяСтрока(Отчество),Лев(Отчество,1)+".", ""), ""),
				"");

КонецФункции

// Функция формирует фамилию и инициалы работника в заданном падеже 
// по переданным данным о работнике.
//  либо по переданным строкам.
//
// Параметры
//  Работник	- строка (Фамилия + Имя + Отчество, разделенными пробелами) 
//                или ссылка на элемент справочника ФизическиеЛица или Сотрудники.
//  Падеж (необязательный), тип число
//   Падеж, в который необходимо поставить ФИО.
//   1 - Именительный
//   2 - Родительный
//   3 - Дательный
//   4 - Винительный
//   5 - Творительный
//   6 - Предложный
//
//  Пол (необязательный), тип ПеречислениеСсылка.ПолФизическихЛиц
//   Данный параметр предназначен для разрешения возможных неоднозначностей
//   В остальных случаях рекомендуется опускать этот параметр.
// Возвращаемое значение 
//  Фамилия и Инициалы одной строкой.
//
Функция ПредставлениеРаботника(Работник, Знач Падеж = 1, Знач Пол = Неопределено) Экспорт

	ТипДанных = ТипЗнч(Работник);
	Если ТипДанных = Тип("Строка") Тогда
		РаботникФИО = Работник;
		РаботникПол = Пол;
	Иначе
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Работник", Работник);
		Если ТипДанных = Тип("СправочникСсылка.СотрудникиОрганизаций") Тогда
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	СотрудникиОрганизаций.Наименование,
			|	СотрудникиОрганизаций.Физлицо.Пол КАК Пол
			|ИЗ
			|	Справочник.СотрудникиОрганизаций КАК СотрудникиОрганизаций
			|ГДЕ
			|	СотрудникиОрганизаций.Ссылка = &Работник";
		Иначе
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ФизическиеЛица.Наименование,
			|	ФизическиеЛица.Пол
			|ИЗ
			|	Справочник.ФизическиеЛица КАК ФизическиеЛица
			|ГДЕ
			|	ФизическиеЛица.Ссылка = &Работник";
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			РаботникФИО = Выборка.Наименование;
			РаботникПол = Выборка.Пол;
		Иначе
			Возврат ""
		КонецЕсли;
	КонецЕсли;
	
	ФИО = ОбщегоНазначения.ФамилияИнициалыФизЛица(РаботникФИО);
	
	ПозицияПервогоПробела = Найти(ФИО + " "," ");
	Фамилия  = Лев(ФИО,ПозицияПервогоПробела-1);
	Инициалы = Сред(ФИО,ПозицияПервогоПробела+1);
	
	РезультатСклонения = "";
	Если УниверсальныеМеханизмы.Просклонять(глЗначениеПеременной("глКомпонентаСклоненияФИО"), Фамилия, Падеж, РезультатСклонения, РаботникПол) Тогда	
		ФИО = РезультатСклонения + " " + Инициалы;	
	КонецЕсли;
	
	Возврат ФИО
	
КонецФункции

// Функция возвращает совокупность данных о физическом лице в виде структуры, 
// В совокупность данных входит ФИО, должность в заданной организации, 
// паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица - физическое лицо,
//                 по которому возвращается совокупность данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//  ФИОКратко    - Булево - если Истина (по умолчанию), Представление физ.лица включает фамилию и инициалы, если Ложь - фамилию и полностью имя и отчество
//
// Возвращаемое значение:
//  Структура    - Структура с совокупностью данных о физическом лице:
//                 - Фамилия
//                 - Имя
//                 - Отчетсво
//                 - Представление (Фамилия И.О.)
//                 - Подразделение
//                 - ДокументВид
//                 - ДокументСерия
//                 - ДокументНомер
//                 - ДокументДатаВыдачи
//                 - ДокументКемВыдан
//                 - ДокументКодПодразделения
//
Функция ДанныеФизЛица(Организация, ФизЛицо, ДатаСреза, ФИОКратко = Истина) Экспорт
	
	//Смартис Лиманчук начало 27.04.2012
	ДоступныРаботникиОрганизаций = ПравоДоступа("Чтение",Метаданные.РегистрыСведений.РаботникиОрганизаций);
	//Смартис Лиманчук окончание 27.04.2012
	
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,"+
	//Смартис Лиманчук начало 27.04.2012
	//|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	//|	РаботникиОрганизацийСрезПоследних.Должность,
	//|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	?(ДоступныРаботникиОрганизаций,"
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,","")+"
	//Смартис Лиманчук окончание 27.04.2012
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан
	|ИЗ
	|	(ВЫБРАТЬ Ссылка КАК ФизЛицо ИЗ Справочник.ФизическиеЛица ГДЕ Ссылка = &ФизЛицо) КАК ФизЛица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ФИОФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо = &ФизЛицо) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо"+
	//Смартис Лиманчук начало 27.04.2012
	//|	ЛЕВОЕ СОЕДИНЕНИЕ 
	//|		(ВЫБРАТЬ 
	//|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	//|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	//|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	//|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	//|		ИЗ
	//|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо = &ФизЛицо И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	//|		ГДЕ
	//|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	//|		) КАК РаботникиОрганизацийСрезПоследних
	//|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	?(ДоступныРаботникиОрганизаций,"
	|	ЛЕВОЕ СОЕДИНЕНИЕ 
	|		(ВЫБРАТЬ 
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	|		ИЗ
	|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо = &ФизЛицо И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ГДЕ
	|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|		) КАК РаботникиОрганизацийСрезПоследних
	|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо","")+"
	//Смартис Лиманчук окончание 27.04.2012
	|";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	Данные.Следующий();
	
	Результат = Новый Структура("Фамилия, Имя, Отчество, Представление, 
								|ТабельныйНомер, Должность, ПодразделениеОрганизации, 
								|ДокументВид, ДокументСерия, ДокументНомер,  
								|ДокументДатаВыдачи, ДокументКемВыдан, 
								|ПредставлениеДокумента");

	ЗаполнитьЗначенияСвойств(Результат, Данные);

	Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество, ФИОКратко);
	Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
	
	Возврат Результат;
	
КонецФункции // ДанныеФизЛица

// Функция возвращает совокупность данных о физических лицах в виде таблицы
// значений. В совокупность данных входит ФИО, должность в заданной 
// организации, паспортные данные и др.
//
// Параметры:
//  Организация  - СправочникСсылка.Организации - организация, по которой
//                 определяется должность и подразделение работника(ов)
//  ФизЛицо      - СправочникСсылка.ФизическиеЛица или Массив - физическое лицо
//                 или список физ. лиц, по которым возвращается совокупность 
//                 данных
//  ДатаСреза    - Дата - дата, на которую считываются данные
//
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с совокупностью данных о физическом лице. 
//                  Колонки: возвращаемой таблицы:
//                  - Фамилия
//                  - Имя
//                  - Отчетсво
//                  - Представление (Фамилия И.О.)
//                  - Подразделение
//                  - ДокументВид
//                  - ДокументСерия
//                  - ДокументНомер
//                  - ДокументДатаВыдачи
//                  - ДокументКемВыдан
//
Функция ДанныеФизЛиц(Организация, ФизЛицо, ДатаСреза) Экспорт

	//Смартис Лиманчук начало 27.04.2012
	ДоступныРаботникиОрганизаций = ПравоДоступа("Чтение",Метаданные.РегистрыСведений.РаботникиОрганизаций);
	//Смартис Лиманчук окончание 27.04.2012
	
	ЗапросПоЛицам = Новый Запрос();
	ЗапросПоЛицам.УстановитьПараметр("ДатаСреза",   ДатаСреза);
	ЗапросПоЛицам.УстановитьПараметр("Организация", Организация);
	ЗапросПоЛицам.УстановитьПараметр("ФизЛицо", ФизЛицо);
	ЗапросПоЛицам.Текст =
	"ВЫБРАТЬ
	|	ФИОФизЛицСрезПоследних.Фамилия,
	|	ФИОФизЛицСрезПоследних.Имя,
	|	ФИОФизЛицСрезПоследних.Отчество,"+
	//Смартис Лиманчук начало 27.04.2012
	//|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	//|	РаботникиОрганизацийСрезПоследних.Должность,
	//|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,
	?(ДоступныРаботникиОрганизаций,"
	|	РаботникиОрганизацийСрезПоследних.ТабельныйНомер,
	|	РаботникиОрганизацийСрезПоследних.Должность,
	|	РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации,","")+"
	//Смартис Лиманчук окончание 27.04.2012
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументВид,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументСерия,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументНомер,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументДатаВыдачи,
	|	ПаспортныеДанныеФизЛицСрезПоследних.ДокументКемВыдан
	|ИЗ
	|	(ВЫБРАТЬ Ссылка КАК ФизЛицо ИЗ Справочник.ФизическиеЛица ГДЕ Ссылка В (&ФизЛицо)) КАК ФизЛица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ФИОФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ФИОФизЛицСрезПоследних.ФизЛицо
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ДатаСреза, ФизЛицо В (&ФизЛицо)) КАК ПаспортныеДанныеФизЛицСрезПоследних
	|	ПО ФизЛица.ФизЛицо = ПаспортныеДанныеФизЛицСрезПоследних.ФизЛицо"+
	//Смартис Лиманчук начало 27.04.2012
	//|	ЛЕВОЕ СОЕДИНЕНИЕ 
	//|		(ВЫБРАТЬ 
	//|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	//|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	//|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	//|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	//|		ИЗ
	//|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо В (&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	//|		ГДЕ
	//|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	//|		) КАК РаботникиОрганизацийСрезПоследних
	//|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо
	?(ДоступныРаботникиОрганизаций,"
	|	ЛЕВОЕ СОЕДИНЕНИЕ 
	|		(ВЫБРАТЬ 
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.Код КАК ТабельныйНомер,
	|			РаботникиОрганизацийСрезПоследних.Сотрудник.ФизЛицо КАК ФизЛицо,
	|			РаботникиОрганизацийСрезПоследних.Должность КАК Должность,
	|			РаботникиОрганизацийСрезПоследних.ПодразделениеОрганизации КАК ПодразделениеОрганизации
	|		ИЗ
	|			РегистрСведений.РаботникиОрганизаций.СрезПоследних(&ДатаСреза,	Сотрудник.ФизЛицо В (&ФизЛицо) И Организация = &Организация) КАК РаботникиОрганизацийСрезПоследних
	|		ГДЕ
	|			РаботникиОрганизацийСрезПоследних.ПричинаИзмененияСостояния <> ЗНАЧЕНИЕ(Перечисление.ПричиныИзмененияСостояния.Увольнение)
	|		) КАК РаботникиОрганизацийСрезПоследних
	|	ПО ФизЛица.ФизЛицо = РаботникиОрганизацийСрезПоследних.Физлицо","")+"
	//Смартис Лиманчук окончание 27.04.2012 
	|";
	
	Данные = ЗапросПоЛицам.Выполнить().Выбрать();
	
	ТабРезультат = Новый ТаблицаЗначений();
	ТабРезультат.Колонки.Добавить("Фамилия");
	ТабРезультат.Колонки.Добавить("Имя");
	ТабРезультат.Колонки.Добавить("Отчество");
	ТабРезультат.Колонки.Добавить("Представление");
	ТабРезультат.Колонки.Добавить("ТабельныйНомер");
	ТабРезультат.Колонки.Добавить("Должность");
	ТабРезультат.Колонки.Добавить("ПодразделениеОрганизации");
	ТабРезультат.Колонки.Добавить("ДокументВид");
	ТабРезультат.Колонки.Добавить("ДокументСерия");
	ТабРезультат.Колонки.Добавить("ДокументНомер");
	ТабРезультат.Колонки.Добавить("ДокументДатаВыдачи");
	ТабРезультат.Колонки.Добавить("ДокументКемВыдан");
	ТабРезультат.Колонки.Добавить("ПредставлениеДокумента");
								
	Пока Данные.Следующий() Цикл
		
		Результат = ТабРезультат.Добавить();
		
		ЗаполнитьЗначенияСвойств(Результат, Данные);

		Результат.Представление          = ПолучитьФамилиюИмяОтчество(Данные.Фамилия, Данные.Имя, Данные.Отчество);
		Результат.ПредставлениеДокумента = ПолучитьПредставлениеДокументаФизЛица(Данные);
		
	КонецЦикла;

	Возврат ТабРезультат;
	
КонецФункции // ДанныеФизЛиц

// Функция формирует фамилию и инициалы
//
// Параметры
//  Фамилия  - фамилия физ. лица.
//  Имя      - имя физ. лица.
//  Отчество - отчество физ. лица.
//
// Возвращаемое значение 
//  Фамилия, имя, отчество одной строкой.
//
Функция ПолучитьФамилиюИмяОтчество(Фамилия = " ", Имя = " ", Отчество = " ", ФИОКратко = Истина) Экспорт

	Если ФИОКратко Тогда
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Лев(Имя,1) + "." + 
				?(НЕ ПустаяСтрока(Отчество) , 
				Лев(Отчество,1)+".", ""), ""), "");
	Иначе
		Возврат ?(НЕ ПустаяСтрока(Фамилия), Фамилия + ?(НЕ ПустаяСтрока(Имя)," " + Имя + 
				?(НЕ ПустаяСтрока(Отчество) , " " + Отчество, ""), ""), "");
	КонецЕсли;

КонецФункции // ПолучитьФамилиюИмяОтчество()

Функция ПолучитьМассивПрефиксовРИБ()
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	               |	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	               |ИЗ
	               |	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Заполнение отбора значениями из таблицы значений.
// Соответствие полей устанавливается по представлению и типам значений
//
// Параметры
//  Отбор  – Отбор           – Отбор, который требуется заполнить значениями
//  ТЗ     – ТаблицаЗначений – Таблица содержит значения для отбора.
//                             Структура колонок повторяет структуру отбора
//
Процедура ЗаполнитьОтборПоТаблицеЗначений(Отбор, ТЗ) Экспорт

	Для каждого ЭлементОтбора Из ТЗ Цикл
	
		СтрокаТаблицы = Неопределено;
		
		Для каждого стр Из Отбор Цикл
			
			Если стр.Представление = ЭлементОтбора.Представление
				И стр.ТипЗначения = ЭлементОтбора.ТипЗначения Тогда
				Если ПустаяСтрока(стр.Представление)
					И ПустаяСтрока(стр.ПутьКданным) Тогда
					
					Продолжить;
					
				КонецЕсли;
				СтрокаТаблицы = стр;
				
				Прервать;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ПустаяСтрока(ЭлементОтбора.ПутьКданным) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаТаблицы = Неопределено Тогда
			
			СтрокаТаблицы = Отбор.Добавить(ЭлементОтбора.ПутьКданным, ЭлементОтбора.Имя, ЭлементОтбора.Представление);		
					
		КонецЕсли;
		
		СтрокаТаблицы.ВидСравнения = ЭлементОтбора.ВидСравнения;
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ЭлементОтбора, "Значение, ЗначениеПо, ЗначениеС, Использование");
			
	КонецЦикла;

КонецПроцедуры // УстановитьОтборИзТаблицы(Отбор, ТЗ)

// Функция выделяет первое слово в предложении
Функция ВыделитьСлово(ИсходнаяСтрока) Экспорт
	
	Буфер = СокрЛ(ИсходнаяСтрока);
	ПозицияПослПробела = Найти(Буфер, " ");

	Если ПозицияПослПробела = 0 Тогда
		ИсходнаяСтрока = "";
		Возврат Буфер;
	КонецЕсли;
	
	ВыделенноеСлово = СокрЛП(Лев(Буфер, ПозицияПослПробела));
	ИсходнаяСтрока = Сред(ИсходнаяСтрока, ПозицияПослПробела + 1);
	
	Возврат ВыделенноеСлово;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Процедура вычисляет количество лет, месяцев и дней между двумя датами
//
// Параметры
//  Дата1	– дата, первая дата (более поздняя, часто текущая, стаж определяется по состоянию на эту дату)
//  Дата2	– дата, вторая дата (ранняя дата, с нее начинается "течение" стажа)
//  Лет		– Число, в этот параметр будет записано кол-во лет между двумя датами (Дата1-Дата2)
//  Месяцев	– Число, в этот параметр будет записано кол-во месяцев между двумя датами (Дата1-Дата2)
//  Дней	– Число, в этот параметр будет записано кол-во дней между двумя датами (Дата1-Дата2)
//
Процедура РазобратьРазностьДат(Дата1, Дата2, Лет = 0, Месяцев = 0, Дней = 0) Экспорт
	
	Лет		= 0;
	Месяцев	= 0;
	Дней	= 0;
	Если Дата1 > Дата2 Тогда
		
		ВременнаяДата = Дата1;
		Если День(ВременнаяДата) < День(Дата2) Тогда
			Дней = (ВременнаяДата - ДобавитьМесяц(ВременнаяДата,-1))/86400;
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-1);
		КонецЕсли;
		Если Месяц(ВременнаяДата) < Месяц(Дата2) Тогда
			ВременнаяДата = ДобавитьМесяц(ВременнаяДата,-12);
			Месяцев = 12;
		КонецЕсли;
		Лет		= Макс(			 Год(ВременнаяДата)		- Год(Дата2),	0);
		Месяцев	= Макс(Месяцев	+ Месяц(ВременнаяДата)	- Месяц(Дата2),	0);
		Дней	= Макс(Дней		+ День(ВременнаяДата)	- День(Дата2),	0);
		
		// скорректируем отображаемое значение, если "вмешалось" разное количество дней в месяцах
		Если Дата2 <> (ДобавитьМесяц(Дата1,-Лет*12-Месяцев)-Дней*86400) Тогда
			Дней = Дней + (День(КонецМесяца(Дата2)) - День(НачалоМесяца(Дата2))) - (День(КонецМесяца(ДобавитьМесяц(Дата1,-1))) - День(НачалоМесяца(ДобавитьМесяц(Дата1,-1))));
		КонецЕсли;
		
	КонецЕсли;

КонецПроцедуры	// РазобратьРазностьДат

// Функция определяет дату и время начала календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = НачалоМесяца(ИсходнаяДата);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 10;
	Иначе
		Результат = НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 20;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоДекады()

// Функция определяет дату и время конца календарной декады для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецДекады(ИсходнаяДата) Экспорт

	ДеньМесяца = День(ИсходнаяДата);

	Если ДеньМесяца <= 10 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 9);
	ИначеЕсли ДеньМесяца <= 20 Тогда
		Результат = КонецДня(НачалоМесяца(ИсходнаяДата) + 60 * 60 * 24 * 19);
	Иначе
		Результат = КонецМесяца(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецДекады()

// Функция определяет дату и время начала полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьНачалоПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = НачалоГода(ИсходнаяДата);
	Иначе
		Результат = ДобавитьМесяц(НачалоГода(ИсходнаяДата), 6);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьНачалоПолугодия()

// Функция определяет дату и время конца полугодия для указанной даты.
//
// Параметры:
//  ТекущаяДата - Исходная дата.
//
// Возвращаемое значение:
//  Дата.
//
Функция ПолучитьКонецПолугодия(ИсходнаяДата) Экспорт

	Если Месяц(ИсходнаяДата) < 7 Тогда
		Результат = ДобавитьМесяц(КонецГода(ИсходнаяДата), -6);
	Иначе
		Результат = КонецГода(ИсходнаяДата);
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПолучитьКонецПолугодия()

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");

	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "", КодЯзыка = "ru") Экспорт	


	ДатаДока = ДокументОбъект.Дата;
	
	Если ТипЗнч(ДокументОбъект) <> Тип("ВыборкаИзРезультатаЗапроса") 		
	  И ТипЗнч(ДокументОбъект) <> Тип("Структура") Тогда
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();		
		Если МетаданныеДокумента.Реквизиты.Найти("ДатаВходящегоДокумента") <> Неопределено Тогда 
			Если ЗначениеЗаполнено(ДокументОбъект.ДатаВходящегоДокумента) Тогда
				ДатаДока = ДокументОбъект.ДатаВходящегоДокумента;		
			КонецЕсли;
		КонецЕсли;
		
	конецЕсли;
	
	
	Если ДокументОбъект = Неопределено Тогда
		Возврат "";
	Иначе
			Возврат ?(НЕ ЗначениеЗаполнено(НазваниеДокумента), МетаданныеДокумента.Синоним, НазваниеДокумента ) + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
							  + НСтр("ru=' от ';uk=' від '",КодЯзыка) + Формат(ДатаДока, "ДФ='дд ММММ гггг';Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));
	КонецЕсли;

КонецФункции // СформироватьЗаголовокДокумента()

// Функция формирует представление суммы прописью в указанной валюте
//
// Возвращаемое значение:
//  Строка - сумма прописью
//
Функция СформироватьСуммуПрописью(Сумма, Валюта, КодЯзыка = "ru") Экспорт	

	
	ПараметрыПрописи = Локализация.ПараметрыПрописи(Валюта, КодЯзыка); 
	Если ПараметрыПрописи = "" Тогда
		Возврат ФорматСумм(Сумма);
	Иначе
		Возврат ЧислоПрописью(Сумма,"Л="+Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка),ПараметрыПрописи);
	КонецЕсли;

КонецФункции // СформироватьСуммуПрописью()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ НОМЕРАМИ ДОКУМЕНТОВ

Процедура ПроверитьНомерНалоговогоДокумента(Документ) Экспорт
	
	// поддерживаем особый порядок нумерации налоговых накладных
	// при изменении даты документа возможно потребуется изменение=очистка номера
	
	Если НЕ ЗначениеЗаполнено(Документ.Ссылка) Тогда
		// это новый документ, номер еще не присвоен или задан вручную
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Документ.Номер) Тогда
	    Возврат;
	КонецЕсли;
	
	ЗапросСтарыеДанные = Новый Запрос();
	ЗапросСтарыеДанные.Текст = "ВЫБРАТЬ
	               |	НалоговыйДокумент.Дата,
				   |	НалоговыйДокумент.ВидОперации,
				   |	НалоговыйДокумент.СпецРежимНалогообложения,
	               |	НалоговыйДокумент.Организация
	               |ИЗ
	               |	Документ.НалоговаяНакладная КАК НалоговыйДокумент
	               |ГДЕ
	               |	НалоговыйДокумент.Ссылка = &Ссылка";
	ЗапросСтарыеДанные.УстановитьПараметр("Ссылка",    Документ.Ссылка);
	
	Если ТипЗнч(Документ) = Тип("ДокументОбъект.Приложение2КНалоговойНакладной") Тогда
		ЗапросСтарыеДанные.Текст = СтрЗаменить(ЗапросСтарыеДанные.Текст,"Документ.НалоговаяНакладная", "Документ.Приложение2КНалоговойНакладной")
	КонецЕсли;
	
	СтарыеДанные = ЗапросСтарыеДанные.Выполнить().Выбрать();
	СтарыеДанные.Следующий();
	
	СтараяУчетнаяПолитика = РегистрыСведений.УчетнаяПолитикаОрганизаций.СрезПоследних(СтарыеДанные.Дата, Новый Структура("Организация", СтарыеДанные.Организация));
	НоваяУчетнаяПолитика  = РегистрыСведений.УчетнаяПолитикаОрганизаций.СрезПоследних(Документ.Дата, 	 Новый Структура("Организация", Документ.Организация));
				   
	Если  СтараяУчетнаяПолитика.Количество() > 0
		И НоваяУчетнаяПолитика.Количество()  > 0 Тогда
	
		Если    СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументов	<> НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументов 
			ИЛИ СтараяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов    	<> НоваяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов  Тогда
		
		    Документ.Номер = "";
			
		ИначеЕсли НоваяУчетнаяПолитика[0].ВестиМесячнуюНумерациюНалоговыхДокументов 
			И НачалоМесяца(СтарыеДанные.Дата) <> НачалоМесяца(Документ.Дата) Тогда
			
			Документ.Номер = "";

		КонецЕсли;
	
	КонецЕсли;	
	
	Если НЕ СтарыеДанные.ВидОперации = Документ.ВидОперации
		  И (   (СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийНалоговаяНакладная.НеНДСОперации ИЛИ СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииВозврат ИЛИ СтарыеДанные.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииКорректировка)
			 ИЛИ(Документ.ВидОперации = Перечисления.ВидыОперацийНалоговаяНакладная.НеНДСОперации ИЛИ Документ.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииВозврат ИЛИ Документ.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииКорректировка))
		  И (     НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоНеНДСОперациям = Истина
		      ИЛИ СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоНеНДСОперациям = Истина) Тогда
		   
		Документ.Номер = "";		   
	
	КонецЕсли;
	
	Если НЕ СтарыеДанные.СпецРежимНалогообложения = Документ.СпецРежимНалогообложения
	   И (НоваяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоСпецРежимам = Истина
	 ИЛИ СтараяУчетнаяПолитика[0].ВестиРаздельнуюНумерациюНалоговыхДокументовПоСпецРежимам = Истина) Тогда
	
		Документ.Номер = "";
	
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьМесячныйПрефиксНалоговыхДокументов(Дата) Экспорт

	НомерМесяца = Месяц(Дата);
	Индекс = НомерМесяца*3 - 2;
	
	Возврат Сред("Ян|Фв|Мр|Ап|Ма|Ин|Ил|Ав|Сн|Ок|Но|Дк", Индекс, 2);	

КонецФункции

Процедура ДобавитьПрефиксыНалоговогоДокумента(ДокументОбъект, Префикс) Экспорт
	
	// особые опциональные правила нумерации налоговых документов:
	// возможность вести сквозную нумерацию Налоговых накладных и Приложений 2 к ней
	// возможность вести помесячную нумерацию
	Если  НЕ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.НалоговаяНакладная")
		И НЕ ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.Приложение2КНалоговойНакладной") Тогда
		Возврат;
	КонецЕсли;
	
	УчетнаяПолитика	= ОбщегоНазначения.ПолучитьПараметрыУчетнойПолитикиРегл(ДокументОбъект.Дата, ДокументОбъект.Организация);
	УчетнаяПолитикаНеЗадана = (УчетнаяПолитика = Неопределено);
	Если УчетнаяПолитикаНеЗадана тогда
		Возврат;
	КонецЕсли;

	ПрефиксНалоговых = "";
	
	Если УчетнаяПолитика.ВестиРаздельнуюНумерациюНалоговыхДокументовПоНеНДСОперациям = Истина
		И (    ДокументОбъект.ВидОперации = Перечисления.ВидыОперацийНалоговаяНакладная.НеНДСОперации 
	       ИЛИ ДокументОбъект.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииВозврат 
	       ИЛИ ДокументОбъект.ВидОперации = Перечисления.ВидыОперацийПриложение2КНалоговойНакладной.НеНДСОперацииКорректировка) Тогда
	   
	   ПрефиксНалоговых = "Т";//технологические (нераспечатываемые) документы
   	   
   КонецЕсли;		
	
	Если УчетнаяПолитика.ВестиРаздельнуюНумерациюНалоговыхДокументов = Истина Тогда
		
		// разделяем префиксом Налоговые от Приложений
		Если ТипЗнч(ДокументОбъект) = Тип("ДокументОбъект.НалоговаяНакладная") Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "Н";
		Иначе
			ПрефиксНалоговых = ПрефиксНалоговых + "П";
		КонецЕсли;
		
	КонецЕсли;
	
	Если УчетнаяПолитика.ВестиМесячнуюНумерациюНалоговыхДокументов = Истина Тогда
	    // разделяем префиксом по месяцам
		ПрефиксНалоговых = ПрефиксНалоговых + ПолучитьМесячныйПрефиксНалоговыхДокументов(ДокументОбъект.Дата);
	КонецЕсли;
	
	Если УчетнаяПолитика.ВестиРаздельнуюНумерациюНалоговыхДокументовПоСпецРежимам = Истина Тогда
		
		// разделяем префиксом Налоговые от Приложений
		СпецРежим = ДокументОбъект.СпецРежимНалогообложения;
		
		Если СпецРежим = 0 Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "";
		ИначеЕсли СпецРежим = 2 Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "U";
		ИначеЕсли СпецРежим = 3 Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "V";
		ИначеЕсли СпецРежим = 4 Тогда
			ПрефиксНалоговых = ПрефиксНалоговых + "W";
		КонецЕсли;
		
	КонецЕсли;
	
	ПрефиксНалоговых = Лев(ПрефиксНалоговых + "00000", 5);
	
	Префикс = СОКРП(Префикс) + ПрефиксНалоговых; 
	
Конецпроцедуры

Процедура ДобавитьПрефиксОрганизации(ДокументОбъект, Префикс) Экспорт
 
	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда
		Префикс = "";
	Иначе

		Префикс = ДокументОбъект.Организация.Префикс;

	КонецЕсли;
Конецпроцедуры

// процедура формирования номера документа
Процедура ПриУстановкеНовогоНомераДляДокументов(Источник, СтандартнаяОбработка, Префикс) Экспорт
	ДобавитьПрефиксОрганизации(Источник, Префикс);
	Если ТипЗнч(Источник.Ссылка) = Тип("ДокументСсылка.ПриходныйКассовыйОрдер") ИЛИ ТипЗнч(Источник.Ссылка) = Тип("ДокументСсылка.РасходныйКассовыйОрдер") Тогда
		УчетнаяПолитикаНеЗадана = Ложь;
		мУчетнаяПолитикаБУ = ОбщегоНазначения.ПолучитьПараметрыУчетнойПолитики(Источник.Дата, УчетнаяПолитикаНеЗадана, Источник.Организация, "Бух");
		Если НЕ УчетнаяПолитикаНеЗадана Тогда
			Если мУчетнаяПолитикаБУ.ВестиУчетДенежныхСредствПоОбособленнымПодразделениям Тогда
				Касса = Источник.Касса;
				Если ЗначениеЗаполнено(Касса) Тогда
					Если ЗначениеЗаполнено(Касса.ОбособленноеПодразделение) Тогда
						ПрефиксПодразделения = Касса.ОбособленноеПодразделение.Префикс;
						Если ЗначениеЗаполнено(ПрефиксПодразделения) Тогда
							Префикс = СокрЛП(ПрефиксПодразделения);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	ДобавитьПрефиксУзла(Префикс);
	
	ДобавитьПрефиксыНалоговогоДокумента(Источник, Префикс);
	
	//Префикс = "Э";
	
КонецПроцедуры

//Процедура выполняет удаление движений документа по регистрам при отмене проведения
//	Является обработчиком подписки на событие "ОбработкаУдаленияПроведенияДокумента"
//
Процедура ОбработкаУдаленияПроведенияДокумента(Источник, Отказ) Экспорт
	
	УдалитьДвиженияРегистратора(Источник, Отказ);
	
	Если Источник.ДополнительныеСвойства.Свойство("ТаблицаСтаройРегистрацииВПоследовательности")
	  И Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности.Количество() > 0 Тогда
		УправлениеЗапасамиПартионныйУчет.СдвинутьГраницуПоследовательностиНазад(Источник.Дата, Источник.Ссылка, Источник.ДополнительныеСвойства.ТаблицаСтаройРегистрацииВПоследовательности);
	КонецЕсли;	
	
КонецПроцедуры

Процедура ПриУстановкеНовогоКодаДляСправочникаИлиПВХ(Источник, СтандартнаяОбработка, Префикс) Экспорт
 	ДобавитьПрефиксУзла(Префикс);
КонецПроцедуры

// Проверяет дату на заполненность по аналогии с системной функцией "ПустаяСтрока".
// 
Функция ПустаяДата(ПроверяемаяДата) Экспорт
	
	Если ТипЗнч(ПроверяемаяДата) = Тип("Дата") 
	   И ПроверяемаяДата = Дата(1,1,1) Тогда
	   
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции // ПустаяДата()

// Функция возвращает массив вышестоящих групп указанного элемента.
// 
// Переметры:
//  Элемент      - Элемент справочника, для которого ищется родитель
//
// Возвращаемое значение
//  Массив вышестояших групп
//
Функция ПолучитьСписокВышеСтоящихГрупп(ЭлементСправочника) Экспорт
	
	Результат = Новый Массив;		
	
	Если НЕ ЗначениеЗаполнено(ЭлементСправочника) Тогда
		Возврат Результат;
	КонецЕсли;
	
	МетаданныеСправочника = ЭлементСправочника.Метаданные();
	Если НЕ МетаданныеСправочника.Иерархический Тогда
		Возврат Результат;
	КонецЕсли;
	ИмяСправочника = МетаданныеСправочника.Имя;	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	Справочник1.Родитель КАК Родитель1,
	|	Справочник2.Родитель КАК Родитель2,
	|	Справочник3.Родитель КАК Родитель3,
	|	Справочник4.Родитель КАК Родитель4,
	|	Справочник5.Родитель КАК Родитель5
	|ИЗ
	|	Справочник." + ИмяСправочника + " КАК Справочник1
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник2
	|		ПО (Справочник2.Ссылка = Справочник1.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник3
	|		ПО (Справочник3.Ссылка = Справочник2.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник4
	|		ПО (Справочник4.Ссылка = Справочник3.Родитель)
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник." + ИмяСправочника + " КАК Справочник5
	|		ПО (Справочник5.Ссылка = Справочник4.Родитель)
	|ГДЕ
	|	Справочник1.Ссылка = &Ссылка";
	
	ТекущийЭлемент = ЭлементСправочника;
	
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл		
		Запрос.УстановитьПараметр("Ссылка", ТекущийЭлемент);
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			Для Индекс = 1 по 5 Цикл
				ТекущийЭлемент = Выборка["Родитель" + Индекс];
				Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда
					Результат.Добавить(ТекущийЭлемент);
				Иначе
					Прервать;
				КонецЕсли;				
			КонецЦикла;
		Иначе
			ТекущийЭлемент = Неопределено;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

// Проверяет значения констант из коллекции с текущим значением в ИБ,
// не проверяется для типа данных ХранилищеЗначений
// 
// Параметры: 
//  КоллекцияКонстантДляПроверки  - структура
//									ключ 		- строка, имя константы
//									значение 	- значение константы
//
// Возвращаемое значение:
//  Массив констант значение которых изменилось по сравнению с переданной коллекцией
//
Функция СоздатьМассивИзмененныхКонстант(КоллекцияКонстантДляПроверки) Экспорт
	
	МассивИзмененныхКонстант = Новый Массив;
	
	Для каждого ЭлементКоллекции Из КоллекцияКонстантДляПроверки Цикл
		
		ИмяКонстанты 	  = ЭлементКоллекции.Ключ;
		ЗначениеКонстанты = ЭлементКоллекции.Значение;
		
		ТекущееЗначение   = Константы[ИмяКонстанты].Получить();
		Если  ТипЗнч(ТекущееЗначение) = Тип("ХранилищеЗначения") Тогда
			// не сравниваем значения констант, у которых Тип данных - Хранилище значений
			Продолжить;
		КонецЕсли;	
		
		Если ЗначениеКонстанты <> ТекущееЗначение Тогда
			МассивИзмененныхКонстант.Добавить(Метаданные.Константы[ИмяКонстанты]);
		КонецЕсли;
	
	КонецЦикла;
	
	Возврат МассивИзмененныхКонстант;
	
КонецФункции
 

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ЗАПИСИ НАБОРОВ ЗАПИСЕЙ РЕГИСТРОВ, КОНСТАНТ

// Функция выполняет запись переданного набора записей и 
// формирует сообщение об ошибке, если не удалось записать набор
//
// Параметры
//  НаборЗаписей  - набор записей регистра сведений, который необходимо записать
//
// Возвращаемое значение:
//   Булево   - Истина, когда набор записей записан
//
Функция ЗаписатьНабор(НаборЗаписей) Экспорт

	Попытка
		НаборЗаписей.Записать();
	Исключение
		ВывестиИнформациюОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке()).Описание);
		Если ТранзакцияАктивна() Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		Возврат Ложь;
	КонецПопытки;

	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ НАСТРОЙКИ ПОРЯДКА ЭЛЕМЕНТОВ СПРАВОЧНИКА

// Вспомогательная функция для определнения условий запроса в механизме
// изменения порядка следования элементов. Ставит условия на родителя и владельца
//
// Параметры
//  Элемент - СправочникСсылка, для которого необходимо изменить порядок
//  Запрос - Запрос, в который дописываем условия
// 
//  Возвращаемое значение:
//   Строка - условие запроса
// 
Функция ПолучитьДополнениеЗапроса(Элемент, Запрос, БезПервогоИ = Ложь)

	ТекстЗапроса = "";
	
	Если Элемент.Метаданные().Иерархический = Истина Тогда
		Запрос.УстановитьПараметр("ТекущийРодитель", Элемент.Родитель);
		Если НЕ БезПервогоИ Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Родитель = &ТекущийРодитель
		|";
	КонецЕсли; 
	
	Если Элемент.Метаданные().Владельцы.Количество() > 0 Тогда
		Запрос.УстановитьПараметр("ТекущийВладелец", Элемент.Владелец);
		Если НЕ (ПустаяСтрока(ТекстЗапроса) И БезПервогоИ) Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|	И
			|";
		КонецЕсли; 
		ТекстЗапроса = ТекстЗапроса + "
		|	СправочникПорядка.Владелец = &ТекущийВладелец
		|";
	КонецЕсли; 

	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает значение порядка для нового элемента справочника.
//
// Параметры
//  ЭлементОбъект - СправочникОбъект - новый объект
//
// Возвращаемое значение:
//   Число - новый порядок
//
Функция НазначитьНовыйПорядок(ЭлементОбъект)

	ИмяТаблицы = ЭлементОбъект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	СправочникПорядка.Порядок
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка";
	
	ДополнениеЗапроса = ПолучитьДополнениеЗапроса(ЭлементОбъект, Запрос, Истина);
	
	Если НЕ ПустаяСтрока(ДополнениеЗапроса) Тогда
		Запрос.Текст = Запрос.Текст + "
		|ГДЕ
		|" + ДополнениеЗапроса + "
		|";
	КонецЕсли; 
	
	Запрос.Текст = Запрос.Текст + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок УБЫВ
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат 0;
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат (Выборка.Порядок + 1)
	КонецЕсли; 

КонецФункции

// Процедура вызывается перед записью объекта, для которого необходимо
// контролировать порядок элементов.
// 
// Параметры
//  Отказ - Булево, отказ от записи объекта
//  ЭтотОбъект - СправочникОбъект
//  КонтролироватьПорядок - Булево, контролировать порядок при записи объекта или нет
//
Процедура ПередЗаписьюОбъектаПорядка(Отказ, ЭтотОбъект, КонтролироватьПорядок) Экспорт

	Если ЭтотОбъект.ЭтоНовый() Тогда
		ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
	Иначе
		Если ЭтотОбъект.Ссылка.Родитель <> ЭтотОбъект.Родитель ИЛИ ЭтотОбъект.Ссылка.Владелец <> ЭтотОбъект.Владелец Тогда
			ЭтотОбъект.Порядок = НазначитьНовыйПорядок(ЭтотОбъект);
		КонецЕсли;
	КонецЕсли;
	
	Если КонтролироватьПорядок Тогда
	
		ИмяТаблицы = ЭтотОбъект.Метаданные().Имя;
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ЭтотОбъект.Порядок);
		
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Порядок
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок = &ТекущийПорядок
		|";
		
		Если НЕ ЭтотОбъект.ЭтоНовый() Тогда
			Запрос.УстановитьПараметр("ТекущаяСсылка", ЭтотОбъект.Ссылка);
			Запрос.Текст = Запрос.Текст + "
			|И
			|	СправочникПорядка.Ссылка <> &ТекущаяСсылка
			|";
		КонецЕсли; 
		
		Запрос.Текст = Запрос.Текст + ПолучитьДополнениеЗапроса(ЭтотОбъект, Запрос);
		
		Если НЕ Запрос.Выполнить().Пустой() Тогда
			Отказ = Истина;
			#Если Клиент Тогда
				Сообщить("Не уникальный порядок элемента справочника.");
			#КонецЕсли
		КонецЕсли;
	
	КонецЕсли; 

КонецПроцедуры

// Процедура изменяет порядок следования объектов с настраиваемым из ВЯ
// порядком следования.
// 
// Параметры:
//  ЭлементСсылка - СправочникСсылка, элемент для которого необходимо изменить порядок
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
Процедура ИзменитьПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг = Истина) Экспорт
	
	ЭлементЗамены = ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг);
	
	Если ЭлементЗамены = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	НовыйПорядокЗамены   = ЭлементЗамены.Порядок;
	НовыйПорядокЭлемента = ЭлементСсылка.Порядок;
	
	Если НаправлениеПорядка = "Вверх" Тогда
		Если НовыйПорядокЗамены < НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены + 1;
		КонецЕсли; 
	Иначе
		Если НовыйПорядокЗамены > НовыйПорядокЭлемента Тогда
			ПромежуточныйПорядок = НовыйПорядокЗамены;
			НовыйПорядокЗамены   = НовыйПорядокЭлемента;
			НовыйПорядокЭлемента = ПромежуточныйПорядок;
		Иначе
			НовыйПорядокЭлемента = НовыйПорядокЗамены - 1;
		КонецЕсли;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	ФиксироватьТранзакцию = Истина;
	
	Если НовыйПорядокЗамены <> ЭлементЗамены.Порядок Тогда
		ОбъектЗамены = ЭлементЗамены.ПолучитьОбъект();
		ОбъектЗамены.Порядок = НовыйПорядокЗамены;
		ОбъектЗамены.КонтролироватьПорядок = Ложь;
		Попытка
			ОбъектЗамены.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли; 
	
	Если ФиксироватьТранзакцию Тогда
		ОбъектЭлемента = ЭлементСсылка.ПолучитьОбъект();
		ОбъектЭлемента.Порядок = НовыйПорядокЭлемента;
		Попытка
			ОбъектЭлемента.Записать();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ФиксироватьТранзакцию = Ложь;
		КонецПопытки;
	КонецЕсли;
	
	Если ФиксироватьТранзакцию Тогда
		ЗафиксироватьТранзакцию();
	Иначе
		ОтменитьТранзакцию();
	КонецЕсли; 
	
КонецПроцедуры

// Функция определяет элемент справочника, с которым необходимо
// произвести "рокировку" текущего элемента
//
// Параметры
//  ЭлементСсылка - СпраовочникСсылка, элемент для изменения порядка
//  НаправлениеПорядка - Строка, "Вверх" или "Вниз"
//
// Возвращаемое значение:
//   СправочникСсылка
//
Функция ОпределитьНовыйПорядок(ЭлементСсылка, НаправлениеПорядка, ЦиклическийСдвиг)

	ТекущийПорядок = ЭлементСсылка.Порядок;
	
	ИмяТаблицы = ЭлементСсылка.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
	Запрос.Текст = "
	|ВЫБРАТЬ ПЕРВЫЕ 1
	|	СправочникПорядка.Ссылка
	|ИЗ
	|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
	|ГДЕ
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "<", ">") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
	|УПОРЯДОЧИТЬ ПО
	|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
	|";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Ссылка;
		
	ИначеЕсли ЦиклическийСдвиг Тогда
		// Текущий элемент или первый (при движении вверх)
		// или последний (при движении вниз)
		// или вообще единственный
		
		Запрос = Новый Запрос;
		
		Запрос.УстановитьПараметр("ТекущийПорядок", ТекущийПорядок);
	
		Запрос.Текст = "
		|ВЫБРАТЬ ПЕРВЫЕ 1
		|	СправочникПорядка.Ссылка
		|ИЗ
		|	Справочник." + ИмяТаблицы + " КАК СправочникПорядка
		|ГДЕ
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", ">", "<") + " &ТекущийПорядок " + ПолучитьДополнениеЗапроса(ЭлементСсылка, Запрос) + "
		|УПОРЯДОЧИТЬ ПО
		|	СправочникПорядка.Порядок " + ?(НаправлениеПорядка = "Вверх", "УБЫВ", "ВОЗР") + "
		|";
		
		РезультатЗапроса = Запрос.Выполнить();
		
		Если РезультатЗапроса.Пустой() Тогда
			Возврат Неопределено;
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Выборка.Следующий();
			Возврат Выборка.Ссылка;
		КонецЕсли; 
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПРОВЕРКИ НАЛИЧИЯ И ЗАПОЛНЕНИЯ РЕВИЗИТОВ

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	ИначеЕсли ЗаданныйТип = ТипЗнч(Неопределено) Тогда
		Возврат Неопределено;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

//Предназначена для получения массива пустых значений, содержащих значение Неопределено и значения переданного типа или описания типов
Функция МассивПустыхЗначений(ОписаниеТипов) Экспорт
	МассивЗначений = новый Массив;
	МассивЗначений.Добавить(неопределено);
	Если ТипЗнч(ОписаниеТипов)=Тип("ОписаниеТипов") Тогда
		Для каждого Тип из ОписаниеТипов.Типы() Цикл
			МассивЗначений.Добавить(ПустоеЗначениеТипа(Тип));
		КонецЦикла;
	ИначеЕсли ТипЗнч(ОписаниеТипов)=Тип("Тип") Тогда	
		МассивЗначений.Добавить(ПустоеЗначениеТипа(ОписаниеТипов));
	КонецЕсли;
	
	Возврат МассивЗначений;

КонецФункции




// Позволяет определить есть ли среди реквизитов табличной части документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - строковое имя табличной части документа, среди реквизитов которого производится поиск
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиДокумента(ИмяРеквизита, МетаданныеДокумента, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеДокумента.ТабличныеЧасти.Найти(ИмяТабЧасти);
	// есть таб. часть в документе
	Возврат ТабЧасть <> Неопределено И ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено

КонецФункции // ЕстьРеквизитТабЧастиДокумента()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ЕстьНеЦифры(Знач СтрокаПроверки) Экспорт

	СписокКодовЧисел = Новый СписокЗначений;
	Для а = 48 По 57 Цикл
		СписокКодовЧисел.Добавить(а);
	КонецЦикла; 
	
	СтрокаПроверки = СокрЛП(СтрокаПроверки);
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			Если СписокКодовЧисел.НайтиПоЗначению(КодСимвола(Сред(СтрокаПроверки, а, 1))) = Неопределено Тогда
				Возврат Истина;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЕсли; 

	Возврат Ложь;
	
КонецФункции

// Если в шапке переданного документа есть реквизит с указанным именем, то возвращается его значение.
// Если такого реквизита нет - возвращается Неопределено.
//
// Параметры:
//  ИмяРеквизита - Строка. Имя искомого реквизита.
//  ДокументОбъект - объект переданного документа.
//  МетаданныеДокумента - Метаданные переданного документа.
//  ПустоеЗначение - значение, которое должно вернуться, если в шапке нет такого реквизита,
//  если не передано, то возвращается значение Неопределено.
//
// Возвращаемое значение:
//  Значение реквизита - значение найденного реквизита или ПустоеЗначение.
//
Функция ПолучитьРеквизитШапки(ИмяРеквизита, ДокументОбъект, МетаданныеДокумента, ПустоеЗначение = Неопределено) Экспорт

	ЗначениеРеквизита = ?(МетаданныеДокумента.Реквизиты.Найти(ИмяРеквизита) <> Неопределено,
	                      ДокументОбъект[ИмяРеквизита], ПустоеЗначение);

	Возврат ЗначениеРеквизита;

КонецФункции // ПолучитьРеквизитШапки()

// Определяет существуют ли в конфигурации документы, вводимые на основании указанного
//
// Параметры
//   МетаданныеДокумента - <Объект описания метаданного>, метаданные документа,
//                        на основании которого могут вводиться другие документы
//
// Возвращаемое значение:
//   булево
//
Функция СуществуютДокументыВводимыеНаОсновании(МетаданныеДокумента) Экспорт 
	
	Для каждого Метаданное Из Метаданные.Документы Цикл
		Если Метаданное.ВводитсяНаОсновании.Содержит(МетаданныеДокумента) Тогда
			 Возврат Истина
		КонецЕсли;	
	КонецЦикла;
	
	Возврат Ложь
	
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ЗАГРУЗКИ КЛАССИФИКАТОРОВ

Процедура ЗагрузитьКлассификаторИзXML(ПустойЭлементСправочника, ИмяФайлаПоУмолчанию) Экспорт
	
	ФормаЗагрузки = ПолучитьОбщуюФорму("ФормаЗагрузкиКлассификатораИзXML");
	ФормаЗагрузки.ПустойЭлементСправочника = ПустойЭлементСправочника;
	ФормаЗагрузки.ИмяФайлаПоУмолчанию = ИмяФайлаПоУмолчанию;
	ФормаЗагрузки.Открыть();
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕХАНИЗМОМ ОТПРАВКИ СООБЩЕНИЙ В ОТДЕЛ ТЕХНИЧЕСКОЙ ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

// Функнция проверяет заполнения обязательных параметров для отправки сообщения
//  в отдел технической поддержки.
//
// Параметры
//  ТаблицаДанных - Таблица значений
//
// Возвращаемое значение:
//   Булево - результат корректости проверки
//
Функция ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки(ТаблицаДанных, ПубликоватьСообщения = Истина) Экспорт

	ЗначениеПроверки = Истина;
	СтрокаЗаголовкаОшибки = "Не заполнены настройки для отправки сообщения.";
	
	СписокИменОбязательныхРеквизитов = Новый СписокЗначений;
	СписокИменОбязательныхРеквизитов.Добавить("ПараметрыОтправкиЭлектронногоСообщения_АдресЭлектроннойПочтыОтделаТехническойПоддержки");
	СписокИменОбязательныхРеквизитов.Добавить("ОсновныеДанные_РегистрационныйНомерПрограммы");
	СписокИменОбязательныхРеквизитов.Добавить("Владелец_Организация");
	
	Для каждого СтрокаРаздела Из ТаблицаДанных Цикл
		Для каждого ЭлементЗначения Из СтрокаРаздела.ДанныеРаздела Цикл
			Если СписокИменОбязательныхРеквизитов.НайтиПоЗначению(ЭлементЗначения.Ключ) <> Неопределено И НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
				Если ПубликоватьСообщения Тогда
					СообщитьОбОшибке("Не указан """ + Лев(ЭлементЗначения.Значение[0], (СтрДлина(ЭлементЗначения.Значение[0]) - 1)) + """.",, СтрокаЗаголовкаОшибки);
				КонецЕсли; 
				ЗначениеПроверки = Ложь;
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
	Возврат ЗначениеПроверки;

КонецФункции // ПроверитьСтруктуруЗаполненияПараметровДляОтправкиСообщенияВОтделТехническойПоддержки()

// Процедура формирует таблицу значений со структурой для заполнения данными
// с информацией обращения в отдел технической поддержки
//
// Параметры:
//  ТаблицаДанных - таблица значений для заполнения
//  ФормаНастройкиПараметров - общая форма настройки параметров для отправки в отдел технической поддержки
//
Процедура ЗаполнитьСтруктуруДанныхНастройкиОбращенияВОтделТехподдержкиПоУмолчанию(ТаблицаДанных, ФормаНастройкиПараметров = Неопределено) Экспорт

	// Структура данных - таблица значений:
	//  Колонки:
	//   ИмяРездела
	//   ПредставлениеРаздела
	//   ДанныеРаздела
	
	// Структура данных раздела
	//  Ключ - Имя значения настройки, как оно задано в форме настройки параметров обращения
	//  Значение - Массив значений
	// 
	// Массив значений:
	//  [0] - Представление наименования параметра для печати
	//  [1] - Значение параметра

	Если ТипЗнч(ТаблицаДанных) <> Тип("ТаблицаЗначений") Тогда
		ТаблицаДанных = Новый ТаблицаЗначений;
	КонецЕсли;
	
	Если ТаблицаДанных.Колонки.Количество() = 0 Тогда
		ТаблицаДанных.Колонки.Добавить("ИндексСортировки"    , Новый ОписаниеТипов("Число"));
		ТаблицаДанных.Колонки.Добавить("ИмяРаздела"          , Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ПредставлениеРаздела", Новый ОписаниеТипов("Строка"));
		ТаблицаДанных.Колонки.Добавить("ДанныеРаздела"       , Новый ОписаниеТипов("Структура"));
	КонецЕсли;
	
	ТаблицаДанных.Индексы.Добавить("ИмяРаздела");
	
	Если ФормаНастройкиПараметров = Неопределено Тогда
		ФормаНастройкиПараметров = ПолучитьОбщуюФорму("НастройкаПараметровОбращенияВОтделТехническойПоддержки");
	КонецЕсли;
	
	Для каждого ЭлементФормы Из ФормаНастройкиПараметров.ЭлементыФормы Цикл
		
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеВвода")
		   И ТипЗнч(ЭлементФормы) <> Тип("ПолеВыбора")
		   И ТипЗнч(ЭлементФормы) <> Тип("Флажок") Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРазделителяРаздела = Найти(ЭлементФормы.Имя, "_");
		Если ПозицияРазделителяРаздела = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяРаздела = Сред(ЭлементФормы.Имя, 1, (ПозицияРазделителяРаздела - 1));
		СтрокаРаздела = ТаблицаДанных.Найти(ИмяРаздела, "ИмяРаздела");
		Если СтрокаРаздела = Неопределено Тогда
			СтрокаРаздела = ТаблицаДанных.Добавить();
			СтрокаРаздела.ИмяРаздела           = ИмяРаздела;
			Попытка
				СтрокаРаздела.ПредставлениеРаздела = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела].Заголовок;
				СтрокаРаздела.ИндексСортировки     = ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы.Индекс(ФормаНастройкиПараметров.ЭлементыФормы.ОсновнаяПанель.Страницы[ИмяРаздела]);
			Исключение
				СтрокаРаздела.ПредставлениеРаздела = ИмяРаздела;
			КонецПопытки;
		КонецЕсли;
		
		МассивЗначений = Новый Массив;
		Попытка
			Если ТипЗнч(ЭлементФормы) = Тип("Флажок") Тогда
				МассивЗначений.Добавить((ЭлементФормы.Заголовок + ":"));
			Иначе
				МассивЗначений.Добавить(ФормаНастройкиПараметров.ЭлементыФормы["Надпись_" + ЭлементФормы.Имя].Заголовок);
			КонецЕсли; 
		Исключение
			МассивЗначений.Добавить(ЭлементФормы.Имя);
		КонецПопытки;
		МассивЗначений.Добавить("");
		
		СтрокаРаздела.ДанныеРаздела.Вставить(ЭлементФормы.Имя, МассивЗначений);
		
	КонецЦикла;
	
	ТаблицаДанных.Сортировать("ИндексСортировки ВОЗР");
	
КонецПроцедуры

// Функция формирует текст сообщения на линию техподдержки
//
// Параметры
//  НЕТ
//
// Возвращаемое значение:
//   Текст сообщения
//
Функция ПолучитьТекстСообщенияВОтделТехническойПоддержки() Экспорт

	ТекстВозврата = "";
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "============ Сведения об использовании ПП 1С:Предприятие 8 ============";
	
	ТаблицаДанных = Константы.ПараметрыСообщенияПриОбращенииВОтделТехническойПоддержки.Получить().Получить();
	
	// Сформируем обязательный информационный раздел
	
	СистемИнфо = Новый СистемнаяИнформация;
	
	ТекстВозврата = ТекстВозврата + Символы.ПС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "1. ДАННЫЕ ТЕКУЩЕГО КОМПЬЮТЕРА И КОНФИГУРАЦИИ";
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия 1С:Предприятия 8: "   + СистемИнфо.ВерсияПриложения;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Конфигурация: "              + Метаданные.Синоним;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Версия конфигурации: "       + Метаданные.Версия;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Поставщик: "                 + Метаданные.Поставщик;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Операционная система: "      + СистемИнфо.ВерсияОС;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Оперативная память (МБ): "   + СистемИнфо.ОперативнаяПамять;
	ТекстВозврата = ТекстВозврата + Символы.ПС + "Процессор: "                 + СистемИнфо.Процессор;

	НомерСтрокиРаздела = 1;
	
	Если ТипЗнч(ТаблицаДанных) = Тип("ТаблицаЗначений") Тогда
		
		Для каждого СтрокаТаблицыРаздела Из ТаблицаДанных Цикл
			
			СтрокаРаздела = "";
			
			Если СтрокаТаблицыРаздела.ИмяРаздела = "ПараметрыОтправкиЭлектронногоСообщения" Тогда
				Продолжить;
			КонецЕсли;
			
			Для каждого ЭлементЗначения Из СтрокаТаблицыРаздела.ДанныеРаздела Цикл
				Если НЕ ЗначениеЗаполнено(ЭлементЗначения.Значение[1]) Тогда
					Продолжить;
				КонецЕсли; 
				СтрокаРаздела = СтрокаРаздела + Символы.ПС + ЭлементЗначения.Значение[0] + " " + ?(ТипЗнч(ЭлементЗначения.Значение[1]) = Тип("Булево"), ?(ЭлементЗначения.Значение[1], "Да", "Нет"), ЭлементЗначения.Значение[1]);
			КонецЦикла; 
			
			Если НЕ ЗначениеЗаполнено(СтрокаРаздела) Тогда
				Продолжить;
			КонецЕсли;
			
			НомерСтрокиРаздела = НомерСтрокиРаздела + 1;
			
			СтрокаРаздела = Строка(НомерСтрокиРаздела) + ". " + ВРег(СтрокаТаблицыРаздела.ПредставлениеРаздела) + СтрокаРаздела;
			
			ТекстВозврата = ТекстВозврата + Символы.ПС;
			ТекстВозврата = ТекстВозврата + Символы.ПС + СтрокаРаздела;
		
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстВозврата;

КонецФункции // ПолучитьТекстСообщенияВОтделТехническойПоддержки()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная));

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Служебная функция - возвращает принадлежность объекта метаданных определенному классу
// 
// Параметры:
//	Класс  - класс
//	Объект - объект метаданных
// 
Функция ПринадлежностьКлассуМетаданных(Класс, Объект) Экспорт
	Для Каждого МДОбъект Из Метаданные[Класс] Цикл
		Если МДОбъект = Объект Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции // ПринадлежностьКлассуМетаданных()

//функция выполняет приведение строки к числу
// Параметры:
//  ЧислоСтрокой           - Строка - Строка приводимая к числу
//  ВозвращатьНеопределено - Булево - Если Истина и строка содержит некорректное значение, то возвращать Неопределено
//
// Возвращаемое значение:
//  Число
//
Функция ПривестиСтрокуКЧислу(ЧислоСтрокой, ВозвращатьНеопределено = Ложь) Экспорт
	
	ОписаниеТипаЧисла = Новый ОписаниеТипов("Число");
	ЗначениеЧисла = ОписаниеТипаЧисла.ПривестиЗначение(ЧислоСтрокой);
	
	Если ВозвращатьНеопределено И (ЗначениеЧисла = 0) Тогда
		
		Стр = Строка(ЧислоСтрокой);
		Если Стр = "" Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Стр = СтрЗаменить(СокрЛП(Стр), "0", "");
		Если (Стр <> "") И (Стр <> ".") И (Стр <> ",") Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеЧисла;	
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СВОЙСТВАМИ И КАТЕГОРИЯМИ ОБЪЕКТОВ

//Функция возвращает список доступных назначений для "Свойств и категорий объектов" 
//по переданной ссылке
// Параметры:
//	Ссылка - Ссылка на справочник или документ
//
// Возвращаемое значение:
// Список значений: доступные назначения для свойств и категорий
Функция ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке(Ссылка) Экспорт

	Результат = Новый СписокЗначений;
	
	Если Ссылка = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	ТипСсылки = ТипЗнч(Ссылка);
	ЭтоХарактеристика = (ТипСсылки = Тип("СправочникСсылка.ХарактеристикиНоменклатуры"));

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("НазначениеХарактеристика", ПланыВидовХарактеристик.НазначенияСвойствКатегорийОбъектов.Справочник_ХарактеристикиНоменклатуры);

	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	Назначения.Ссылка КАК Ссылка,
	|	Назначения.ТипЗначения КАК ТипЗначения
	|ИЗ
	|	ПланВидовХарактеристик.НазначенияСвойствКатегорийОбъектов КАК Назначения
	|ГДЕ
	|	НЕ Назначения.ЭтоГруппа
	|";

	Если ЭтоХарактеристика Тогда
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка = &НазначениеХарактеристика
		|";
	Иначе
		ТекстЗапроса = ТекстЗапроса + "
		|	И Назначения.Ссылка <> &НазначениеХарактеристика
		|";
	КонецЕсли;

	Запрос.Текст = ТекстЗапроса;

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ЭтоХарактеристика Или Выборка.ТипЗначения.СодержитТип(ТипСсылки) Тогда
			Результат.Добавить(Выборка.Ссылка);
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции // ПолучитьСписокНазначенийСвойствКатегорийОбъектовПоСсылке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Сравнивает два массива однотипных значений (кроме коллекций значений)
//
// Параметры: 
//  ПервыйМассив,ВторойМассив - сравниваемые массивы
//
// Возвращаемое значение:
//  булево.
//
Функция МассивыИдентичны(ПервыйМассив,ВторойМассив) Экспорт

    ЭлементовМассива = ПервыйМассив.Количество();
	МассивыСовпадают = (ЭлементовМассива = ВторойМассив.Количество()); 
	  
	Если МассивыСовпадают Тогда
		Для Сч = 1 По ЭлементовМассива Цикл
			Если ПервыйМассив[Сч-1] <> ВторойМассив[Сч-1] Тогда
				Возврат Ложь
			КонецЕсли;
		КонецЦикла; 		
	КонецЕсли;

	Возврат МассивыСовпадают

КонецФункции // МассивыИдентичны()

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

// Удаление из массива пустых элементов
//
// Параметры:
//   МассивЭлементов - Массив
//
Процедура УдалитьНеЗаполненныеЭлементыМассива(МассивЭлементов) Экспорт

	Колво = МассивЭлементов.Количество();
	Для н=1 По Колво Цикл
		Если НЕ ЗначениеЗаполнено(МассивЭлементов[Колво-н]) Тогда
			МассивЭлементов.Удалить(Колво-н);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

// Разворачивает таблицу  значений по вложенной таблице
//
// Параметры
//  ТаблицаЗначений  – <ТаблицаЗначений> – базовая таблица
//  КолонкаВложеннойТаблицы  – <Строка> – Наименование колонки влолженной таблицы
//  СписокРаспределяемыхКолонок  – <Структура> – Структура с именами колонок базовой таблицы, значения которых будут распределяться по колонке вложенной таблицы
//         						Ключ - Имя колонки базовой таблицы
//         						Значение - Имя колонки вложенной таблицы. Если во вложенной таблице колонка не обнаружена - обработка прекращается.
// Возвращаемое значение:
//   <ТаблицаЗначений>   – таблица значений, развернутая по значениям вложенной таблицы.
//
// При совпадении имен базовой и вложенной таблиц - если  
Функция РазвернутьПоВложеннойТаблице(ТаблицаЗначений, КолонкаВложеннойТаблицы,СписокРаспределяемыхКолонок, СписокИсключаемыхКолонок, СообщатьОбОшибке = Истина) Экспорт

	Если ТаблицаЗначений.Количество()=0 Тогда
		// Таблица не заполнена, софрмировать новую таблицу не представляется возможнным
		// Отсуттствует вложенная таблица, структуру данных выходной таблицы сформировать невозможно
		Если СообщатьОбОшибке Тогда
			СообщитьОбОшибке("Отсутствуют строки в базовой таблице, распределение по вложенной таблице невозможно.",,,СтатусСообщения.Внимание);
		КонецЕсли; 
		Возврат Неопределено;
	КонецЕсли; 
	
	КолонкиВложеннойТаблицы = ТаблицаЗначений[0][КолонкаВложеннойТаблицы].Колонки;
	//Заполним значения по тем колонкам, по которым не были заполены значения ранее
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		Если НЕ ЗначениеЗаполнено(Колонка.Значение) Тогда
			СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
		КонецЕсли;
		Если КолонкиВложеннойТаблицы.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено Тогда
			// Во вложенной таблице не обнаружена колонка, по которой производится распределение.
			Если СообщатьОбОшибке Тогда
				СообщитьОбОшибке("Во вложенной таблице не обнаружена колонка ("+?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+"), по которой производится распределение.",,,СтатусСообщения.Внимание);
			КонецЕсли; 
			Возврат Неопределено;
		КонецЕсли; 
	КонецЦикла;
	
	НоваяТаблицаЗначений = Новый ТаблицаЗначений();
	Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
	    Если Колонка.Имя = КолонкаВложеннойТаблицы Тогда
			Продолжить;
	    ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого Колонка Из КолонкиВложеннойТаблицы Цикл
		Если не НоваяТаблицаЗначений.Колонки.Найти(Колонка.Имя) = неопределено Тогда
			Продолжить;
		ИначеЕсли СписокИсключаемыхКолонок.Свойство(Колонка.Имя) Тогда
			Продолжить;
		КонецЕсли; 
		НоваяТаблицаЗначений.Колонки.Добавить(Колонка.Имя,Колонка.ТипЗначения);
	КонецЦикла; 
	
	Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 

		ТаблицаДляРаспределения = СтрокаБазовойТаблицы[КолонкаВложеннойТаблицы];

		Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

			СтрокаНовойТаблицы = НоваяТаблицаЗначений.Добавить();

			Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

				Если СписокРаспределяемыхКолонок.Свойство(Колонка.Имя) тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[СписокРаспределяемыхКолонок[Колонка.Имя]];

				ИначеЕсли не КолонкиВложеннойТаблицы.Найти(Колонка.Имя) = Неопределено тогда
					СтрокаНовойТаблицы[Колонка.Имя]= СтрокаТаблицыРаспределения[Колонка.Имя];

				ИначеЕсли Не(ТаблицаЗначений.Колонки.Найти(Колонка.Имя)=Неопределено) тогда
					СтрокаНовойТаблицы[Колонка.Имя] = СтрокаБазовойТаблицы[Колонка.Имя];

				Иначе
					// Колонка не найдена - ошибка при выполнении распределения по вложенной таблице
		  			Если СообщатьОбОшибке Тогда
						СообщитьОбОшибке("при распределении по вложенной таблице невозможно определить значение для колонки :"+Колонка.Имя+".",,,СтатусСообщения.Внимание);
					КонецЕсли; 

				КонецЕсли;

			КонецЦикла; // Для каждого Колонка из НоваяТаблицаЗначений.Колонки Цикл

		КонецЦикла; // Для каждого СтрокаТаблицыРаспределения из ТаблицаДляРаспределения Цикл

	КонецЦикла; // Для каждого СтрокаБазовойТаблицы Из ТаблицаЗначений Цикл 
	
	Для каждого Колонка Из СписокРаспределяемыхКолонок Цикл
		СписокРаспределяемыхКолонок.Вставить(Колонка.Ключ,Колонка.Ключ);
	КонецЦикла;
	
	// Распределение базовых данных по распределяемым колонкам
	НоваяТаблицаЗначений = СформироватьКорректирующиеЗаписи(ТаблицаЗначений,НоваяТаблицаЗначений,СписокРаспределяемыхКолонок);
	
	Возврат НоваяТаблицаЗначений;

КонецФункции // РазвернутьПоВложеннойТаблице()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫВОДА СООБЩЕНИЙ


Функция ОпределитьВажностьСобытияЖурналаРегистрации(Статус)
	ВидСобытия = УровеньЖурналаРегистрации.Информация;
	Если Статус = СтатусСообщения.Внимание Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Предупреждение;
	ИначеЕсли Статус = СтатусСообщения.Важное или  Статус = СтатусСообщения.ОченьВажное Тогда
		ВидСобытия = УровеньЖурналаРегистрации.Ошибка;
	КонецЕсли;
    Возврат  ВидСобытия;
КонецФункции

//Процедура проверяет необходимость вывода сообщения в журнал регистрации, при необходимости выводит сообщение в журнал регистрации
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//
Процедура ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок="")
	//Если сообщение выводится во внешнем соединении, оно всегда должно быть выведено в журнал регистрации (независимо от настроек)
	//Это необходимо для того, чтобы в ЖР были видны сообщения при автоматическом обновлении
	#Если НЕ ВнешнееСоединение Тогда
	ДублироватьСообщенияВЖурналРегистрации = глЗначениеПеременной("ДублироватьСообщенияВЖурналРегистрации");
	Если НЕ ДублироватьСообщенияВЖурналРегистрации Тогда
		Возврат;
	КонецЕсли;
	#КонецЕсли
	Важность = ОпределитьВажностьСобытияЖурналаРегистрации(Статус);
	Если Заголовок <> "" Тогда
		//вывод заголовка как отдельной записи в журнал
		ЗаписьЖурналаРегистрации("Сообщение", УровеньЖурналаРегистрации.Примечание, , ,Заголовок);
	КонецЕсли;
	
	ЗаписьЖурналаРегистрации("Сообщение", Важность, , ,ТекстСообщения);

КонецПроцедуры

// Процедура выводит пользователю сообщение: в журнал регистрации, в панель комментариев, в окно сообщений (в зависимости от настроек).
//
// Параметры:
//	ТекстСообщения - Строка - Текст сообщения
//	Статус - ПеречислениеСсылка.ВидыСообщений - Вид сообщения
//		   - СтатусСообщения - Статус сообщения (используется для совместимости со старыми вызовами процедуры Сообщить)
//	Заголовок - Строка - Текст заголовка
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//	СтрокаРодитель - Родительская строка дерева значений для вывода сообщения
//	РаскрытьСообщение - Булево - Признак раскрытия строки дерева сообщений
//
// Возвращаемое значение:
//	СтрокаДереваЗначенний - Строка дерева значений, в которую записано текущее сообщение
//Если вывод сообщений в панель комментариев не предусмотрен, возвращается Неопределено
Функция Сообщение(Знач ТекстСообщения, Статус = Неопределено, Заголовок = "", РасшифровкаСообщения = Неопределено, СтрокаРодитель = Неопределено, РаскрытьСообщение = Истина, ЭтоСообщениеОбОшибке = Ложь) Экспорт
	
	ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
	СтрокаДереваЗначений = ВыводСообщений.ВывестиСообщениеВПанельКомментариев(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, СтрокаРодитель, РаскрытьСообщение);
	Если СтрокаДереваЗначений = Неопределено Тогда //Сообщение в панель комментариев не выведено, значит необходимо вывести его в окно сообщений
		ВыводСообщений.ВывестиСообщениеВОкноСообщений(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, ЭтоСообщениеОбОшибке);
	КонецЕсли;
	
	Возврат СтрокаДереваЗначений;
	
КонецФункции // Сообщение()

////////////////////////////////////////////////////////////////////////////////
// ВЫВОД ТРАССИРОВОЧНЫХ СООБЩЕНИЙ
Процедура СообщитьОСостоянииОбновления(Подсистема, Действие, Комментарий="", Уровень=0, флЗавершающее=ложь) Экспорт
	СтрокаТабуляций = "";
	Для ш = 1 По Уровень Цикл
		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
	КонецЦикла;	
	Если флЗавершающее Тогда
		ВидСообщенияе = СтатусСообщения.Информация;
	Иначе
		ВидСообщения = СтатусСообщения.Внимание;
	КонецЕсли;
	
	ОбщегоНазначения.Сообщение(СтрокаТабуляций + Подсистема + ": " + Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),ВидСообщения);
КонецПроцедуры	


Процедура СообщитьОСостоянииИзмененияНастройки(ИмяНастройки,Действие, Комментарий="", Уровень=0,текСтатусСообщения=неопределено) Экспорт
	Если текСтатусСообщения = неопределено Тогда
		СтатусСообщенияДляВывода = СтатусСообщения.Информация;
	Иначе
		СтатусСообщенияДляВывода = текСтатусСообщения;
	КонецЕсли;
		
	СтрокаТабуляций = "";
	Для ш = 1 По Уровень Цикл
		СтрокаТабуляций = СтрокаТабуляций + Символы.Таб;
	КонецЦикла;	
	ОбщегоНазначения.Сообщение(СтрокаТабуляций + "Настройка учета: "+ИмяНастройки+". "+Действие + ?(Комментарий = "",""," (" + Комментарий + ")"),СтатусСообщенияДляВывода);
КонецПроцедуры	

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте вывобит сообщение в обработку комментирования
// на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения  - строка, текст сообщения.
//					  Строка может содержать символы %%, которые при формировании 
//					  сообщения заменяются на представления элементов расшифровки
//  Отказ           - булево, признак отказа (необязательный).
//  Заголовок	    - Заголовок сообщения, для вывода сообщения если работа на сервере или внешнее соединение
//	Расшифровки 	- массив расшифровок для переданного ТекстСообщения
//					  Представляет собой массив структур с полями Представление и Расшифровка
//					  Поле Представление - текст, дополняющий ТекстСообщения
//					  Поле Расшифровка - действие, выполняемое по расшифровке
//
Процедура ВывестиИнформациюОбОшибке(Знач ТекстСообщения, Отказ = Истина, Заголовок = "", ВидСообщения = Неопределено, Расшифровки = Неопределено, РодительскаяСтрока = НеОпределено, РаскрытьСообщение = Истина) Экспорт
	
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#ИначеЕсли Клиент Тогда
	
	    Если ВидСообщения = Неопределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		КонецЕсли;
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстСообщения, ВидСообщения, Расшифровки, РодительскаяСтрока, РаскрытьСообщение);
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
		Сообщить(ТекстСообщения, СтатусСообщения.Важное);
		
	#КонецЕсли
	
КонецПроцедуры // ВывестиИнформациюОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения слущебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

Процедура СообщитьИнформациюПользователю(СтрокаСообщенияПользователю) Экспорт
	
	#Если Клиент Тогда
	Сообщить(СтрокаСообщенияПользователю);
	#КонецЕсли
	
КонецПроцедуры

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//	Заголовок - Строка - Текст заголовка
//          (выводится пользователю в режиме обычного приложения; 
//           в заголовке должен быть описан контекст выполняемых действий, например "Проведение документа №... от ...")
//	Статус - СтатусСообщения - Статус сообщения
//	РасшифровкаСообщения - Массив - Массив с данными расшифровки
//						 - Ссылка - Ссылка на объект
//
Процедура СообщитьОбОшибке(
	Знач ТекстСообщения, 
	Отказ = Ложь, 
	Заголовок = "",
	Статус = Неопределено,
	РасшифровкаСообщения = Неопределено
	) Экспорт

	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);

	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		//Для клиента и сервера запись в журнал регистрации попадет внутри процедуры Сообщение
		ДублироватьСообщениеВЖурналРегистрации(ТекстСообщения, Статус, Заголовок);
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
		
	#Иначе
		
		Сообщение(ТекстСообщения, Статус, Заголовок, РасшифровкаСообщения, Неопределено, Истина, Истина);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

Процедура ПоказатьДиалогСИнформациейОбОшибке(ИнформацияОбОшибке) Экспорт
	
	#Если Клиент Тогда
		ПоказатьИнформациюОбОшибке(ИнформацияОбОшибке);
	#Иначе
		СообщитьОбОшибке(ПолучитьПричинуОшибки(ИнформацияОбОшибке).Описание);
	#КонецЕсли
	
КонецПроцедуры

// Формирует строку представления документа для сообщений при проведении.
//
// Параметры
//  Источник - структура шапки или ссылка на проводимый документ.
//
// Возвращаемое значение
//  Строка с представлением документа
//
Функция ПредставлениеДокументаПриПроведении(Источник) Экспорт
	
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		ПредставлениеДокумента = Источник.ПредставлениеДокумента;
		Если Источник.Свойство("ВидОперации") Тогда
			ПредставлениеДокумента = ПредставлениеДокумента + " (" + Источник.ВидОперации + ")";
		КонецЕсли; 
	Иначе
		МетаданныеДокумента = Источник.Метаданные();
		ВидОперацииСтр = "";
		Если МетаданныеДокумента.Реквизиты.Найти("ВидОперации") <> Неопределено Тогда
			ВидОперацииСтр = " (" + Источник.ВидОперации + ")";
		КонецЕсли;
		ПредставлениеДокумента = СокрЛП(Источник) + ВидОперацииСтр;
	КонецЕсли; 
	
	ПредставлениеДокумента = "Проведение документа: " + ПредставлениеДокумента;
	
	Возврат ПредставлениеДокумента;
	
КонецФункции // ПредставлениеДокументаПриПроведении

// Предназначена для получения запросом представлений объектов
// Поддерживает два синтаксиса
// 1.
// Параметры:
//	СсылкиОбъектовПарам - массив ссылок
// Возвращаемое значение
//	Соответствие в котором ключ - одна из переданных ссылок, 
//  а значение - представление этой ссылки
// 2. 
// Параметры:
//	СсылкиОбъектовПарам - ссылка
// Возвращаемое значение
//	Строка предсатвления ссылки
//
// Пример использования:
// 	МассивСсылок = Новый Массив;
// 	МассивСсылок.Добавить(НоваяОрганизация);
// 	МассивСсылок.Добавить(СтараяОрганизация);
// 	Представления = ПолучитьПредставленияОбъектов(МассивСсылок);
//	НоваяОрганизацияСтрокой = Представления[НоваяОрганизация];
//	СтараяОрганизацияСтрокой = Представления[СтараяОрганизация];
//
Функция ПолучитьПредставленияОбъектов(СсылкиОбъектовПарам) Экспорт
	// соответствие возвращается если передан массив ссылок
	ПереданМассив = Истина;
	
	// Если передано одиночное значение - "превратим" его в массив
	Если ТипЗнч(СсылкиОбъектовПарам) <> Тип("Массив") Тогда
		Ссылка = СсылкиОбъектовПарам;
		СсылкиОбъектов = Новый Массив;
		СсылкиОбъектов.Добавить(Ссылка);
		ПереданМассив = Ложь;
		
	Иначе
		СсылкиОбъектов = СсылкиОбъектовПарам;
		
	КонецЕсли;
	
	// Обработаем массив СсылкиОбъектов и сформируем 
	// соответствие ссылок по их типам
	СсылкиПоТипам = Новый Соответствие;
	Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
		ПолноеИмя = СсылкаНаОбъект.Метаданные().ПолноеИмя();
		Если СсылкиПоТипам[ПолноеИмя] = НеОпределено Тогда
			СсылкиПоТипам[ПолноеИмя] = Новый Массив;
		КонецЕсли;
		СсылкиПоТипам[ПолноеИмя].Добавить(СсылкаНаОбъект);
	КонецЦикла;
	
	// формирование запроса
	ТекстЗапроса = "";
	Запрос = Новый Запрос;
	ПервоеЗначение = Истина;
	Для Каждого ЭлементСоответствия Из СсылкиПоТипам Цикл
		ИмяПараметра = "Массив" + СтрЗаменить(ЭлементСоответствия.Ключ, ".", "_");
		Если Не ПервоеЗначение Тогда
			ТекстЗапроса = ТекстЗапроса + "
			|ОБЪЕДИНИТЬ ВСЕ";
			
		КонецЕсли;
		ТекстЗапроса = ТекстЗапроса + "
		|ВЫБРАТЬ 
		|	Ссылка КАК Ссылка,
		|	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление
		|ИЗ " + ЭлементСоответствия.Ключ + "
		|ГДЕ Ссылка В (&" + ИмяПараметра + ")";
		Запрос.УстановитьПараметр(ИмяПараметра, ЭлементСоответствия.Значение);
		ПервоеЗначение = Ложь;
	КонецЦикла;
	// обработка запроса
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	Если ПереданМассив Тогда
		ВозвращаемоеСоответствие = Новый Соответствие;
		Пока Выборка.Следующий() Цикл
			ВозвращаемоеСоответствие[Выборка.Ссылка] = Выборка.Представление;
		КонецЦикла;
		
		// дополним пустыми представлениями неполученных запросом ссылок
		Для Каждого СсылкаНаОбъект Из СсылкиОбъектов Цикл
			Если ВозвращаемоеСоответствие[СсылкаНаОбъект] = НеОпределено Тогда
				ВозвращаемоеСоответствие[СсылкаНаОбъект] = "";
			КонецЕсли;
			
		КонецЦикла;
		Возврат ВозвращаемоеСоответствие;
		
	Иначе
		Если Выборка.Следующий() Тогда
			Возврат Выборка.Представление;
		Иначе
			// если ссылки не нашлось - пустое представление
			Возврат "";
		КонецЕсли;
		
	КонецЕсли; 
	
КонецФункции

// Проверяет принадлежность документа к видам учета
//
// Параметры: 
//  СтруктураШапкиДокумента - структура, содержащая реквизиты шапки документа
//  Отказ                   - флаг отказа в проведении.
//  Заголовок               - строка, заголовок сообщения об ошибке проведения.
//  МожетБытьТолькоНалоговый- строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок) Экспорт
	
	Перем Упр, Бух;
	
	ЕстьУпр = СтруктураШапкиДокумента.Свойство("ОтражатьВУправленческомУчете", Упр);
	ЕстьБух = СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете", Бух);
	
	Если ЕстьУпр ИЛИ ЕстьБух Тогда
		Если Упр <> Истина И Бух <> Истина  Тогда
			СообщитьОбОшибке("Документ должен принадлежать хотя бы одному из видов учета: ""Управленческий"" и (или)  ""Бухгалтерский"".", Отказ, Заголовок);
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПЕРЕЧИСЛЕНИЯМИ

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт

	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;

КонецФункции // ПолучитьСписокЭлементовПеречисления()

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт

	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;

КонецПроцедуры

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из Метаданные.Перечисления[ЗначениеПеречисления.Метаданные().Имя].ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

// сравнение значений перечислений на больше/меньше
// применяется для перечислений, для которых последовательность 
// значений имеет определяющее значение
//
// Параметры:
//  Значение1, Значение2 - сравниваемые значения перечислений
//
// Возвращаемое значение: число
//   1 - если Значение1 > Значение2
//  -1 - если Значение1 < Значение2
//   0 - если Значение1 = Значение2
//
Функция СравнениеПеречислений(Значение1, Значение2) Экспорт
    ИмяПеречисления = Метаданные.НайтиПоТипу(ТипЗнч(Значение1)).Имя;
    Менеджер = Перечисления[ИмяПеречисления];
    Если Менеджер.Индекс(Значение1) > Менеджер.Индекс(Значение2) Тогда
        Возврат 1;
    ИначеЕсли Менеджер.Индекс(Значение1) < Менеджер.Индекс(Значение2) Тогда
        Возврат -1;
    Иначе
        Возврат 0;
    КонецЕсли;
    
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МЕТАДАННЫМИ

// Функция возвращает имя табличной части, к которой принадлежит переданная строка
//
// Параметры
//  СтрокаТабличнойЧасти - ссылка на строку табличной части
//
// Возвращаемое значение:
//   Строка - имя табличной части, как оно задано в конфигураторе
//
Функция ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку(СтрокаТабличнойЧасти) Экспорт

	ИмяТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(СтрокаТабличнойЧасти)).Имя;
	Возврат ИмяТабличнойЧасти;

КонецФункции // ПолучитьИмяТабличнойЧастиПоСсылкеНаСтроку()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ДВИЖЕНИЯМИ ДОКУМЕНТОВ

// Функция возвращает массив, который содержит имена регистров 
// движения которых не надо удалять при очистке движений перед перепроведением
//	Остатки, движения по таким регистрам не используются 
// 		ни в процедурах контроля остатков (товаров, задолженностей)
// 		ни в логике формирования других движений (например, партии, авансы)
//
Функция ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(ТекущийРежимПроведенияДокумента)
	
	МассивРегистров = Новый Массив;
	
	//В список регистров могут быть включены только те, движения которых записываются через коллекцию движений (Движения.<...>), 
	//а не через набор записей 
	
	// Регистры вида "Обороты", которые 
	//- не используются для формирования движений 
	//- двигаются документами, для которых применяется выборочное удаление движений
	МассивРегистров.Добавить("ДвиженияДенежныхСредств");
	МассивРегистров.Добавить("Закупки");
	МассивРегистров.Добавить("Продажи");

	// Далее перечислены регистры, которые используются для контроля остатков, формирования движений 
	// только при оперативном проведении. Их 
	// - следует очищать если документ проводится оперативно
	// - можно не очищать, если документ проводится неоперативно
	Если ТекущийРежимПроведенияДокумента = РежимПроведенияДокумента.Неоперативный Тогда
		МассивРегистров.Добавить("ВзаиморасчетыСКонтрагентами");
		МассивРегистров.Добавить("ДенежныеСредства");
		МассивРегистров.Добавить("ЗаказыПоставщикам");
		МассивРегистров.Добавить("РазмещениеЗаказовПокупателей");
		МассивРегистров.Добавить("РасчетыСКонтрагентами");
		МассивРегистров.Добавить("ТоварыВНТТ");
		МассивРегистров.Добавить("ТоварыВРезервеНаСкладах");
		МассивРегистров.Добавить("ТоварыВРознице");
		МассивРегистров.Добавить("ТоварыКПередачеОрганизаций");
		МассивРегистров.Добавить("ТоварыКПередачеСоСкладов");
		МассивРегистров.Добавить("ТоварыКПеремещениюВНТТ");
		МассивРегистров.Добавить("ТоварыКПолучениюНаСклады");
		МассивРегистров.Добавить("ТоварыНаСкладах");
		МассивРегистров.Добавить("ТоварыОрганизаций");
		МассивРегистров.Добавить("ТоварыПереданные");
		МассивРегистров.Добавить("ТоварыПолученные");
	КонецЕсли;
	
	Возврат МассивРегистров;
	
КонецФункции // ПолучитьРегистрыДляОптимизацииПерезаписиДвижений

// Процедура удаления движений документа при перепроведении (отмене проведения)
//
// Параметры:
//	ДокументОбъект 				- документ, движения которого удаляются
//	Отказ 						- булево, признак отказа
//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
//								нужен для составления списка регистров, которые не надо очищать
Процедура УдалитьДвиженияРегистратора(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры = Ложь, РежимПроведенияДокумента = Неопределено) Экспорт
	
	// Удалим те движения, которые уже записаны
	УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента);

	// Очистим непустые коллекции движений документа
	ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект);
	
	// Удаление записей регистрации из всех последовательностей - после удаления движений по регистрам
	УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, Истина);
	
КонецПроцедуры

// Процедура очистки записанных движений документа
//
// Параметры:
//	ДокументОбъект 				- документ, движения которого удаляются
//	Отказ 						- булево, признак отказа
//	ВыборочноОчищатьРегистры 	- булево, признак выборочной очистки наборов записей 
//								Если Истина - часть наборов записей не будут очищены, будут очищены только коллекции движений
//	РежимПроведенияДокумента 	- режим проведения (оперативный / неоперативный), 
//								нужен для составления списка регистров, которые не надо очищать
Процедура УдалитьЗаписанныеДвиженияДокумента(ДокументОбъект, Отказ, ВыборочноОчищатьРегистры, РежимПроведенияДокумента)
	
	// Получим перечень регистров, движения по которым нужно очистить
	МассивРегистров = ПроведениеДокументов.МассивРегистровНужноОчистить(ДокументОбъект);
	
	Если МассивРегистров.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Если очищать регистры надо выборочно, то подготовим список таких регистров, 
	//	которые можно не очищать при перепроведении
	Если ВыборочноОчищатьРегистры Тогда
		РегистрыДляОптимизацииПерезаписиДвижений = ПолучитьРегистрыДляОптимизацииПерезаписиДвижений(РежимПроведенияДокумента);
	КонецЕсли;
	
	// Переменные логики отложенного проведения
	ДокументИспользуетсяВОтложенномПроведении = Ложь;
	ВыполняетсяДопроведение                   = Ложь;
	ПроведениеПоВсемВидамУчета                = Ложь;
	
	СтруктураПараметровПроведения = ОтложенноеПроведениеДокументов.ПолучитьПараметрыПроведенияДокумента(ДокументОбъект);
	ДокументИспользуетсяВОтложенномПроведении = СтруктураПараметровПроведения.ДокументИспользуетсяВОтложенномПроведении;
	
	Если ДокументИспользуетсяВОтложенномПроведении Тогда
		ВыполняетсяДопроведение = СтруктураПараметровПроведения.ВыполняетсяДопроведение;
		ПроведениеПоВсемВидамУчета = СтруктураПараметровПроведения.ПроведениеПоВсемВидамУчета;
		РегистрыОтложенногоПроведения = ОтложенноеПроведениеДокументов.ПолучитьРегистрыОтложенногоПроведения();
	КонецЕсли;
	
	//Обойдем список регистров, по которым существуют движения, и выполним очистку необходимых регистров
	Для Каждого ПолноеИмяРегистра ИЗ МассивРегистров Цикл
		
		// Имя регистра передается как значение, 
		// полученное с помощью функции ПолноеИмя() метаданных регистра
		ПозицияТочки = Найти(ПолноеИмяРегистра, ".");
		ТипРегистра = Лев(ПолноеИмяРегистра, ПозицияТочки - 1);
		ИмяРегистра = СокрП(Сред(ПолноеИмяРегистра, ПозицияТочки + 1));
		
		// Используется для оптимизации перезаписи движений платформой
		//	Если значение Ложь, набор записей не будет очищен
		// По умолчанию все движения надо удалять
		УдалятьДвижения = Истина;
		
		Если ВыборочноОчищатьРегистры И РегистрыДляОптимизацииПерезаписиДвижений.Найти(ИмяРегистра) <> Неопределено Тогда
			УдалятьДвижения = Ложь;
		КонецЕсли;
		
		Если ДокументИспользуетсяВОтложенномПроведении Тогда
			Если ВыполняетсяДопроведение Тогда
				//	Если выполняется допроведение, то удаляются только движения по регистрам, 
				//	которые формируются при отложенном проведении
				Если РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			Иначе
				// Документ проводится в режиме отложенного проведения
				
				// Если для документа выключен режим проведения "по всем видам учета", 
				// то всегда удаляются движения по регистрам, которые формируются при допроведении
				//	(независимо от того, входят ли они в список РегистрыДляОптимизацииПерезаписиДвижений)
				Если НЕ УдалятьДвижения
					И НЕ ПроведениеПоВсемВидамУчета 
					И РегистрыОтложенногоПроведения.Найти(СокрЛП(ПолноеИмяРегистра)) <> Неопределено Тогда
					
					УдалятьДвижения = Истина;
				КонецЕсли;
			КонецЕсли; 
		КонецЕсли; 
		
		Если УдалятьДвижения Тогда
			// Удаление движений происходит без контроля доступа - передаем пустую таблицу движений
			ПолныеПрава.ЗаписатьНаборЗаписейНаСервере(ИмяРегистра, ДокументОбъект.Ссылка,, ТипРегистра);
		Иначе
			//Установим признак модифицированности набора записей, чтобы записались все коллекции движений, по которым
			//были записи на момент проведения
			ДокументОбъект.Движения[ИмяРегистра].Очистить();
		КонецЕсли;
	КонецЦикла;	
	
КонецПроцедуры

// Процедура очищает коллекцию движений документа
//
Процедура ОчисткаКоллекцииДвиженийДокумента(ДокументОбъект)
		
	Если ДокументОбъект.Движения.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Движение ИЗ ДокументОбъект.Движения Цикл
		// Очистим не пустые коллекции движений
		Если Движение.Количество() > 0 Тогда
			Движение.Очистить();
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт

	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл

		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);

	КонецЦикла;

КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Проверяет наличие требуемых данных в источнике и Формирует таблицу значений
//
// Параметры
//  Источник  – ТаблицаЗначений или ТабличнаяЧасть или КоллекцияСтрокДереваЗначений с исходными данными
//
//  Реквизиты – структура – Структура реквизитов. 
//							Ключ 		- Наименование колонки в источнике
//							Значение    - Наименование колонки в получаемой ТЗ
//							Если значение опущено - приравнивается ключу.
//	ПолучитьНомерСтрокиДокумента - булево
//	                        Используется только при выгрузке из табличной части документа.
//							В формируемой таблице создает новую колонку "НомерСтрокиДокумента"
//								и заполняет её реальными номерами строк
//
//  КоллекцияКолонокДереваЗначений - только для коллекции строк дерева значений.
// Возвращаемое значение:
//  Таблица значений или Неопределено (если не хватает реквизитов)
//
Функция СформироватьТаблицуЗначений(Источник,Реквизиты=Неопределено,ПолучитьНомерСтрокиДокумента = ложь,ФормироватьОтстутствующиеКолонки=Ложь,КоллекцияКолонокДереваЗначений=Неопределено) экспорт

	ЭтоТаблицаЗначений=(ТипЗнч(Источник)= тип("ТаблицаЗначений"));
	ЭтоСтрокиДереваЗначений=(ТипЗнч(Источник)= тип("КоллекцияСтрокДереваЗначений"));
	Если ЭтоСтрокиДереваЗначений и КоллекцияКолонокДереваЗначений = Неопределено тогда
		Возврат Неопределено;
	Конецесли;
	
	Если НЕ ЗначениеЗаполнено(Реквизиты) тогда
		Если ЭтоТаблицаЗначений тогда
			НоваяТЗ = Источник.Скопировать();
	  		Возврат НоваяТЗ;
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			Реквизиты = Новый Структура();
			Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
				Реквизиты.Вставить(Колонка.Имя);
			КонецЦикла;
		Иначе
			НоваяТЗ = Источник.Выгрузить();
	  		Возврат НоваяТЗ;
		КонецЕслИ;
	Конецесли;
	
	Если не ЭтоТаблицаЗначений  и не ЭтоСтрокиДереваЗначений тогда
		РеквизитыТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(Источник)).Реквизиты;
	Конецесли;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
 		НоваяТЗ.Колонки.Добавить("НомерСтрокиДокумента",Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5,0)));
	КонецЕсли;

	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
		Если не ЭтоТаблицаЗначений и ПолучитьНомерСтрокиДокумента тогда
			Строка.НомерСтрокиДокумента = НоваяТЗ.Количество();
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		Если ЭтоТаблицаЗначений тогда
			ИсточникКолонка = Источник.Колонки.Найти(ИскомыйРеквизит);
		ИначеЕсли ЭтоСтрокиДереваЗначений тогда
			ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		Иначе
			ИсточникКолонка = РеквизитыТабличнойЧасти.Найти(ИскомыйРеквизит);
		Конецесли;
		Если ИсточникКолонка= неопределено тогда
			//недостаточно реквизитов
			Если ФормироватьОтстутствующиеКолонки тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит);
			Иначе
				Возврат Неопределено;
			КонецЕсли;	
		Иначе
			Если ЭтоТаблицаЗначений ИЛИ ЭтоСтрокиДереваЗначений тогда
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
			Иначе
				НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.Тип);
			КонецЕсли;
			НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
		Конецесли;
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Формирует структуру, содержащую значения реквизитов шапки документа.
//
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокумента(ДокументОбъект) Экспорт
	
	СтруктураШапкиДокумента = Новый Структура;
	СтруктураШапкиДокумента.Вставить("Ссылка", ДокументОбъект.Ссылка);
	СтруктураШапкиДокумента.Вставить("Дата", ДокументОбъект.Дата);
	
	ТипДокумента = ТипЗнч(ДокументОбъект);
	
	МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
	СтруктураШапкиДокумента.Вставить("ВидДокумента",  МетаданныеДокумента.Имя);
	СтруктураШапкиДокумента.Вставить("ПредставлениеДокумента", СокрЛП(ДокументОбъект));
	СтруктураШапкиДокумента.Вставить("ПредставлениеВидаДокумента",  МетаданныеДокумента.Представление());
	
	Для каждого Реквизит из МетаданныеДокумента.Реквизиты Цикл
		СтруктураШапкиДокумента.Вставить(Реквизит.Имя, ДокументОбъект[Реквизит.Имя]);
	КонецЦикла;
	
	
	// Вставим свойства в структуру и далее при необходимости установим некоторые значения в Истину
	СтруктураШапкиДокумента.Вставить("ЕстьНалогНаПрибыль" , Ложь);
	СтруктураШапкиДокумента.Вставить("ЕстьНДС"            , Ложь);
	СтруктураШапкиДокумента.Вставить("ЕстьЕдиныйНалог"    , Ложь);
	
	Если СтруктураШапкиДокумента.Свойство("Организация")
		И ЗначениеЗаполнено(СтруктураШапкиДокумента.Организация)
		И СтруктураШапкиДокумента.Свойство("ОтражатьВБухгалтерскомУчете") 
		И СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		
		УчетнаяПолитика = ОбщегоНазначения.ПолучитьПараметрыУчетнойПолитикиРегл(СтруктураШапкиДокумента.Дата, СтруктураШапкиДокумента.Организация, Ложь);
		
	  	Если ЗначениеЗаполнено(УчетнаяПолитика) Тогда
			СтруктураШапкиДокумента.Вставить("ЕстьНалогНаПрибыль" , УчетнаяПолитика.ЕстьНалогНаПрибыль);
			СтруктураШапкиДокумента.Вставить("ЕстьНДС"            , УчетнаяПолитика.ЕстьНДС);
			СтруктураШапкиДокумента.Вставить("ЕстьЕдиныйНалог"    , УчетнаяПолитика.ЕстьЕдиныйНалог);
			
			СтруктураШапкиДокумента.Вставить("СпособОценкиМПЗРегл", УчетнаяПолитика.СпособОценкиМПЗ);
			
		КонецЕсли; 
		
	КонецЕсли; 	
	
	СтруктураШапкиДокумента.Вставить("ИспользоватьРАУЗ", УправлениеЗапасами.ИспользуетсяРасширеннаяАналитикаУчета(СтруктураШапкиДокумента.Дата));
		
	Возврат СтруктураШапкиДокумента;
	
КонецФункции // СформироватьСтруктуруШапкиДокумента()

//Формирует структуру, содержащую значения реквизитов шапки документа.
//Проверяет признаки отражения в учете
//При необходимости корректирует признаки отражения в учете в связи с отложенным проведением или допроведением документа
// Параметры: 
//  ДокументОбъект - объект документа для формирования структуры шапки, 
//	Отказ - признак отказа от проведения документа
//	Заголовок - строка, заголовок для формирования сообщений об ошибках
//	МожетБытьТолькоНалоговый - булево, признак того что флаг отражения в НУ может быть установлен независимо от флага отражения в БУ
// Возвращаемое значение:
//  Сформированная структура.
//
Функция СформироватьСтруктуруШапкиДокументаИПроверитьОтражениеВУчете(ДокументОбъект, Отказ, Заголовок, МожетБытьТолькоНалоговый = Ложь) Экспорт
	СтруктураШапкиДокумента = СформироватьСтруктуруШапкиДокумента(ДокументОбъект);
	
	ПроверитьПринадлежностьКВидамУчета(СтруктураШапкиДокумента, Отказ, Заголовок);
	Если Отказ Тогда
		Возврат СтруктураШапкиДокумента;
	КонецЕсли;
	
	//Проверяем - возможно, документ должен проводиться отложенно
	Если ОтложенноеПроведениеДокументов.ДокументПодерживаетОтложенноеПроведение(ДокументОбъект,СтруктураШапкиДокумента) Тогда
		ОтложенноеПроведениеДокументов.ПодготовитьКПроведениюПоВидамУчета(ДокументОбъект.ДополнительныеСвойства, СтруктураШапкиДокумента);
	КонецЕсли;
	Возврат СтруктураШапкиДокумента;
КонецФункции


// Выполняет движение по регистру.
//
// Параметры:
//  НаборДвижений               - набор движений регистра,
//  ПустыеКолонкиСоставногоТипа - структура, содержащая имена измерений,ресурсов и
//  реквизитов составного типа, которые могут содержать пустые ссылки.
//
Процедура ВыполнитьДвижениеПоРегистру(НаборДвижений, ВидДвижения = Неопределено,
	                                  ПустыеКолонкиСоставногоТипа = Неопределено) Экспорт

	ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
	Если ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ПустыеКолонкиСоставногоТипа = Неопределено Тогда
		ПустыеКолонкиСоставногоТипа = Новый Структура;
	КонецЕсли;
	
	//
	КолонкиТаблицы = ТаблицаДвижений.Колонки;
	
	//
	МетаРег = НаборДвижений.Метаданные();
	ИзмеренияСостТипа = Новый Структура;
	ИзмеренияСостТипаСтр = "";
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Если (МетаИзм.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаИзм.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаИзм.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаИзм.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаИзм.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРек Из МетаРег.Реквизиты Цикл
		Если (МетаРек.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРек.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРек.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРек.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРек.Имя;
			КонецЕсли; 
			
		КонецЕсли;
	КонецЦикла;
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Если (МетаРес.Тип.Типы().Количество() > 1)
		   И НЕ (ПустыеКолонкиСоставногоТипа.Свойство(МетаРес.Имя)) Тогда
			Если не КолонкиТаблицы.Найти(МетаРес.Имя)=Неопределено Тогда
				ИзмеренияСостТипа.Вставить(МетаРес.Имя);
				ИзмеренияСостТипаСтр = ИзмеренияСостТипаСтр + ", " + МетаРес.Имя;
			КонецЕсли; 
		КонецЕсли;
	КонецЦикла;
	
	Если ИзмеренияСостТипаСтр <> "" Тогда
		ИзмеренияСостТипаСтр = Сред(ИзмеренияСостТипаСтр, 3);
	КонецЕсли;
	
	ТипЧисло = Тип("Число");
	ТипСтрока = Тип("Строка");
	ТипДата = Тип("Дата");
	
	ЕстьПериод = НЕ ТаблицаДвижений.Колонки.Найти("Период") = Неопределено;

	Для Каждого СтрокаДвижения ИЗ ТаблицаДвижений Цикл
		Движение = НаборДвижений.Добавить();
		ЗаполнитьЗначенияСвойств(Движение, СтрокаДвижения, ,ИзмеренияСостТипаСтр);
		
		Если ВидДвижения <> Неопределено Тогда
			Движение.ВидДвижения = ВидДвижения;
		КонецЕсли;
		
		Если ЕстьПериод И НЕ СтрокаДвижения.Период = '00010101000000' Тогда
			Движение.Период = СтрокаДвижения.Период;
		ИначеЕсли НаборДвижений.мПериод <> Неопределено Тогда
			Движение.Период = НаборДвижений.мПериод;
		КонецЕсли; 
		Движение.Активность = Истина;
		
		Для Каждого КлючИЗначение ИЗ ИзмеренияСостТипа Цикл
			ЗначениеВКолонке = СтрокаДвижения[КлючИЗначение.Ключ];
			
			Если ЗначениеВКолонке = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначенияВКолонке = ТипЗнч(ЗначениеВКолонке);
			
			Если ТипЗначенияВКолонке = ТипЧисло Тогда
				Если ЗначениеВКолонке = 0 Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипСтрока Тогда
				Если ЗначениеВКолонке = "" Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ТипЗначенияВКолонке = ТипДата Тогда
				Если ЗначениеВКолонке = '00010101000000' Тогда
					Продолжить;
				КонецЕсли;
			ИначеЕсли ЗначениеВКолонке.Пустая() Тогда
				Продолжить;
			КонецЕсли;
			
			Движение[КлючИЗначение.Ключ] = ЗначениеВКолонке;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ВыполнитьДвижениеПоРегистру()

// Заполняет набор записей регистра СвободныеОстатки по данным базового регистра
//
// Параметры:
//  НаборСвободныеОстатки	- таблица движений регистра СвободныеОстатки, которую нужно заполнить
//  НаборБазовыйРегистр		- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
//
Процедура ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборБазовыйРегистр, ВидРегистраОснования) Экспорт

	Если НаборБазовыйРегистр.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
		
	ДатаНачалаИспользованияРегистраСвободныеОстатки = глЗначениеПеременной("ДатаНачалаИспользованияРегистраСвободныеОстатки");
	
	// Сначала проверим период записей, потом выполним заполнение
	// Считаем, что период всех записей одинаковый
	Если НаборБазовыйРегистр[0].Период < ДатаНачалаИспользованияРегистраСвободныеОстатки Тогда
		Возврат;
	КонецЕсли;
	
	ОбратныйВидДвижения = (ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах
							ИЛИ ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыКПередачеСоСкладов);
			
	Для каждого ЭлДвижение Из НаборБазовыйРегистр Цикл
		
		ЭлЗапись = НаборСвободныеОстатки.Добавить();
		ЭлЗапись.РегистрОснование = ВидРегистраОснования;
		ЗаполнитьЗначенияСвойств(ЭлЗапись, ЭлДвижение);
		
		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
			ЭлЗапись.Качество = Справочники.Качество.Новый;
		КонецЕсли;
		
		Если ОбратныйВидДвижения Тогда
			Если ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход Тогда
				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Расход;
			Иначе
				ЭлЗапись.ВидДвижения = ВидДвиженияНакопления.Приход;
			КонецЕсли; 
		КонецЕсли;
		
		Если ВидРегистраОснования = Перечисления.ВидыРегистровОснованийРегистраСвободныеОстатки.ТоварыВРезервеНаСкладах Тогда
			// Резервирование зависит от обособленного учета (ОУ)
			// если ведется ОУ, то резервирование влияет на количество с учетом серии
			// если ОУ не ведется, количество с учетом серии не изменяется
			Если глЗначениеПеременной("ИспользоватьУказаниеСерийНоменклатурыПриРезервировании") Тогда
				ТипДокументСсылкаЗаказПокупателя = Тип("ДокументСсылка.ЗаказПокупателя");
				Если ТипЗнч(ЭлДвижение.ДокументРезерва) = ТипДокументСсылкаЗаказПокупателя 
					И ЭлДвижение.ДокументРезерва.ДоговорКонтрагента.ОбособленныйУчетТоваровПоЗаказамПокупателей Тогда
					
					ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
				КонецЕсли; 
			КонецЕсли; 
		Иначе
			ЭлЗапись.КоличествоСУчетомСерии = ЭлЗапись.Количество;
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры //
 
// Выполняет движения по регистру СвободныеОстатки.
//
// Параметры:
//  НаборДвижений			- таблица движений регистра (базовый регистр) на основании которого необходимо заполнить регистр СвободныеОстатки
//  Регистратор				- документ, регистратор движений
//  Замещение				- булево, замещать записи регистра	
//  ВидРегистраОснования	- перечисление <ВидыРегистровОснованийРегистраСвободныеОстатки>
//
Процедура ВыполнитьДвиженияПоРегиструСвободныеОстатки(НаборДвижений, Регистратор, Замещение, ВидРегистраОснования, Отказ = Ложь) Экспорт
	
	Если НЕ глЗначениеПеременной("ИспользоватьРегистрСвободныеОстатки") Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Регистратор) = Тип("ДокументСсылка.КорректировкаЗаписейРегистров") Тогда
		// При изменении базовых регистров документом "Корректировка записей регистров"
		// не выполняется автоматическое формирование движений по регистру
		Возврат;
	КонецЕсли; 
	
	НаборСвободныеОстатки = РегистрыНакопления.СвободныеОстатки.СоздатьНаборЗаписей();
	НаборСвободныеОстатки.Отбор.Регистратор.Установить(Регистратор);
	
	ЗаполнитьСвободныеОстаткиПоДаннымБазовогоРегистра(НаборСвободныеОстатки, НаборДвижений, ВидРегистраОснования);
	
	Попытка
		
		// Набор может не измениться
		Если НаборСвободныеОстатки.Модифицированность() Тогда
			НаборСвободныеОстатки.Записать(Ложь);
		КонецЕсли; 
	
	Исключение
		СообщитьОбОшибке(ОписаниеОшибки(), Отказ); 
		ВызватьИсключение "Операция не выполнена";
	КонецПопытки;	
	
КонецПроцедуры // ВыполнитьДвиженияПоРегиструСвободныеОстатки
 
// Процедура сворачивает движения по регистру накопления
//
Процедура СвернутьТаблицуДвиженийРегистраНакопления(НаборДвижений, ТабДвижений = Неопределено, УдалятьПустыеДвижения = Ложь) Экспорт
	
	Если ТипЗнч(НаборДвижений) = Тип("Строка") Тогда
		МетаРег = Метаданные.РегистрыНакопления[НаборДвижений];
		ТаблицаДвижений = ТабДвижений;
	Иначе
		МетаРег = НаборДвижений.Метаданные();
		Если ТабДвижений = Неопределено Тогда
			ТаблицаДвижений = НаборДвижений.мТаблицаДвижений;
		Иначе
			ТаблицаДвижений = ТабДвижений;
		КонецЕсли;
	КонецЕсли;
	
	
	Если ТаблицаДвижений = Неопределено ИЛИ ТаблицаДвижений.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Измерения = "Период,Регистратор,Активность";
	Если МетаРег.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
		Измерения = Измерения + ",ВидДвижения";
	КонецЕсли;
	
	Для Каждого МетаИзм Из МетаРег.Измерения Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	Для Каждого МетаИзм Из МетаРег.Реквизиты Цикл
		Измерения = Измерения + "," + МетаИзм.Имя;
	КонецЦикла;
	
	Ресурсы = "";
	Для Каждого МетаРес Из МетаРег.Ресурсы Цикл
		Ресурсы = Ресурсы + МетаРес.Имя + ",";
	КонецЦикла;
	
	ТаблицаДвижений.Свернуть(Измерения, Ресурсы);
	
	Если УдалятьПустыеДвижения Тогда
		
		СтруктРесурсы   = Новый Структура(Ресурсы);
		МассивПустСтрок = Новый Массив;
		СтруктПоиска    = Новый Структура;
		
		Для Каждого РесурсКлюч Из СтруктРесурсы Цикл
			СтруктПоиска.Вставить( РесурсКлюч.Ключ, 0);
		КонецЦикла;
		
		МассивПустСтрок = ТаблицаДвижений.НайтиСтроки(СтруктПоиска);
		Для К = 0 По МассивПустСтрок.ВГраница() Цикл
			ТаблицаДвижений.Удалить(МассивПустСтрок[К]);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры // СвернутьТаблицуДвиженийРегистраНакопления()

// Получить движение(набор записей) для документа-объекта
//
// Параметры
//  Объект  – 	ДокументОбъект – Документ. для которого производится поиск движения
//  ТипДвижения  – Регистр<...>Менеджер – менеджер регистра, движение по которому пытаемся сформировать
//             или <Строка> - имя регистра, движение по которому пытаемся сформировать
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей   – набор записей для объекта
//   или Неопределено - если такого регистра не существует или документ не является регистратором регистра
//
Функция ПолучитьДвижение(Объект, ТипДвижения, Сообщать=Ложь) Экспорт
	
	Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
		Движение = Объект.Движения.Найти(ТипДвижения);
		ДвижениеНевозможно = Движение = Неопределено;
	Иначе
		ТипТипаДвижения = ТипЗнч(ТипДвижения.СоздатьНаборЗаписей());
		ДвижениеНевозможно = Истина;
		Для каждого Движение Из Объект.Движения Цикл
			Если ТипЗнч(Движение) = ТипТипаДвижения Тогда
				ДвижениеНевозможно = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ДвижениеНевозможно Тогда
			Движение = Неопределено;
		КонецЕсли; 
	КонецЕсли;
	
	Если Сообщать И ДвижениеНевозможно Тогда
		Если ТипЗнч(ТипДвижения) = Тип("Строка") Тогда
			ПредставлениеТипаДвижения = ТипДвижения;
		Иначе
			ПредставлениеТипаДвижения = Строка(ТипЗнч(ТипДвижения));
		КонецЕсли;
		СообщитьОбОшибке("Требуется подключение """ + ТипЗнч(Объект) + """ к формированиям движения по регистру """ + ПредставлениеТипаДвижения + """!");
	КонецЕсли;
	
	Возврат Движение;
	
КонецФункции // ПолучитьДвижение()

// Получить набор записей по регистру по ссылке на документ
//
// Параметры
//  Ссылка  		– ДокументСсылка		– Ссылка на документ, для которого производится поиск движений по регистру (набора записей)
//  РегистрДвижения – Регистр<...>Менеджер	– менеджер регистра, движение по которому пытаемся обнаружить
//  ПрочитатьЗаписи - Булево 				- Прочитать существующий набор записей для документа (если документ может формировать движения по указанному регистру).
//                 
// Возвращаемое значение:
//   Регистр<...>НаборЗаписей – Набор записей по регистру с отбором по документу,
//	 Неопределено 				в случае если документ не может формировать движений по регистру.
//
Функция ПолучитьНаборЗаписейПоСсылке(Ссылка, РегистрДвижения, ПрочитатьЗаписи = Ложь, Сообщать=Ложь) Экспорт
	Движения = неопределено;
	Если Ссылка.Метаданные().Движения.Содержит(Метаданные.НайтиПоТипу(ТипЗнч(РегистрДвижения))) тогда
        Движения = РегистрДвижения.СоздатьНаборЗаписей();
		Движения.Отбор.Регистратор.Установить(Ссылка);
		Если ПрочитатьЗаписи тогда
			Движения.Прочитать();
		КонецЕсли;
	ИначеЕсли Сообщать тогда
			СообщитьОбОшибке("Требуется подключение документа """+Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)).Представление()+""" к формированию движений по регистру """+
			СтрЗаменить(Лев(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":"))," менеджер","")+Сред(Строка(ТипЗнч(РегистрДвижения)),Найти(Строка(ТипЗнч(РегистрДвижения)),":")+1)+
			"""!");
	КонецЕсли;
	
	Возврат Движения;
КонецФункции // ПолучитьНаборЗаписейПоСсылке()

// Процедура сворачивает переданный набор записей регистра бухгалтерии по измерениям и реквизитам
// Параметры: НаборЗаписейРегистраБухгалтерии, тип - набор записей регистров бухгалтерии Налоговый или Хозрасчетный
//            СтрокаГруппировка, тип - строка - список колонок таблицы значений по которым будет выполняться группировка
//            СтрокаСуммирование, тип - строка - список колонок таблицы значений которые будут суммироваться
Процедура СвернутьНаборЗаписейРегистраБухгалтерии(НаборЗаписейРегистраБухгалтерии,СтрокаГруппировка,СтрокаСуммирование) Экспорт
	Перем ТаблицаЗаписейРегистраБухгалтерии;
	
	КоличествоЗаписейНабораЗаписей = НаборЗаписейРегистраБухгалтерии.Количество();
	//Если количество записей не больше 1 - не требуется выполнять сворачивание
	Если КоличествоЗаписейНабораЗаписей<=1 Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаЗаписейРегистраБухгалтерии = НаборЗаписейРегистраБухгалтерии.Выгрузить();
	//Данная колонка в таблице не нужна
	ТаблицаЗаписейРегистраБухгалтерии.Колонки.Удалить("НомерСтроки");
	
	
	ТаблицаЗаписейРегистраБухгалтерии.Свернуть(СтрокаГруппировка,СтрокаСуммирование);
	//ничего не свернулось, количество записей осталось без изменений 
	//	- не требуется загружать свернутую таблицу в набор записей 
	Если ТаблицаЗаписейРегистраБухгалтерии.Количество()=КоличествоЗаписейНабораЗаписей Тогда
		Возврат;
	КонецЕсли;
	
	//поиск и удаление проводок с пустым  количеством и суммой
	
	//готовим структуру поиска - нулевые значения колонок, которые входят в список суммируемых колонок
	СтруктураПоиска = новый Структура(СтрокаСуммирование);
	Для каждого элементСтруктуры из СтруктураПоиска цикл
		СтруктураПоиска[ЭлементСтруктуры.Ключ]=0;
	КонецЦикла;
	МассивСтрокКУдалению = ТаблицаЗаписейРегистраБухгалтерии.НайтиСтроки(СтруктураПоиска);
	//удаление строк с пустыми значениями суммируемых колонок
	Если МассивСтрокКУдалению.Количество()>0 Тогда
		Для каждого ЭлементМассива из МассивСтрокКУдалению цикл
			 ТаблицаЗаписейРегистраБухгалтерии.Удалить(ЭлементМассива);
		конецЦикла;
	КонецЕсли;
	
	НаборЗаписейРегистраБухгалтерии.Загрузить(ТаблицаЗаписейРегистраБухгалтерии);
КонецПроцедуры

// Возвращает рабочую дату
//
// Возвращаемое значение:
//   Дата - рабочая дата
//
Функция ПолучитьРабочуюДату() Экспорт

#Если Клиент Тогда
	Дата = РабочаяДата;
#Иначе
	Дата = ТекущаяДата();
#КонецЕсли

	Возврат Дата;

КонецФункции // ПолучитьРабочуюДату()

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 

	Возврат Истина;
	
КонецФункции

// Функция возвращает структуру, содержащую виды учета (УУ, БУ) и принадлежащие им регистры
//
Функция ПолучитьРегистрыПоВидамУчета()
	
	
	
	РегистрыПоВидамУчета = Новый Структура;
	
	РегистрыПоВидамУчета.Вставить("ОтражатьВУправленческомУчете", "ГрафикиАмортизацииОС,
				|МестонахождениеОС,
				|НачислениеАмортизацииОС,
				|НоменклатураОсновныхСредств,
				|ПараметрыАмортизацииОС,
				|ПервоначальныеСведенияОС,
				|СобытияОС,
				|СоставОС,
				|СостоянияОС,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОС,
				|БракВПроизводстве,
				|Затраты,
				|ЗатратыНаСтроительствоОбъектовОсновныхСредств,
				|НезавершенноеПроизводство,
				|ОССписанныеНаЗатраты,
				|ПартииТоваровНаСкладах,
				|СтоимостьОС,
				|СтроительствоОбъектовОсновныхСредств,
				|ТоварыНаСкладах,
				|СвободныеОстатки,
				|ТоварыОрганизаций,
				|УзлыКорректировкиСтоимостиСписания,
				|ДопРасходыНаПриобретениеТоваров,
				|НезавершенноеПроизводство,
				|ПартииМатериаловВЭксплуатации,
				|ПартииТоваровПереданные,
				|ПродажиСебестоимость,
				|РеализованныеТовары,");
				
	РегистрыПоВидамУчета.Вставить("ОтражатьВБухгалтерскомУчете", "ГрафикиАмортизацииОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|НачислениеАмортизацииОСБухгалтерскийУчет,
				|ПараметрыАмортизацииОСБухгалтерскийУчет,
				|ПервоначальныеСведенияОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|МестонахождениеОСБухгалтерскийУчет,
				|СобытияОСОрганизаций,
				|СостоянияОСОрганизаций,
				|СписанныеТовары,
				|СпособыОтраженияРасходовПоАмортизацииОСБухгалтерскийУчет,
				|СчетаБухгалтерскогоУчетаОС,
				|БракВПроизводствеБухгалтерскийУчет,
				|ЗатратыБухгалтерскийУчет,
				|НезавершенноеПроизводствоБухгалтерскийУчет,
				|ОССписанныеНаЗатратыОрганизаций,
				|ПартииТоваровНаСкладахБухгалтерскийУчет,
				|СтоимостьОСБухгалтерскийУчет,
				|ТоварыОрганизаций,
				|Хозрасчетный,
				|ПартииМатериаловВЭксплуатацииБухгалтерскийУчет,
				|ПартииТоваровПереданныеБухгалтерскийУчет,");
				
				
	РегистрыПоВидамУчета.Вставить("ОтражатьВМеждународномУчете", "БракВПроизводствеМеждународныйУчет,
				|НезавершенноеПроизводствоМеждународныйУчет,
				|ПартииМатериаловВЭксплуатацииМеждународныйУчет,
				|ПартииТоваровНаСкладахМеждународныйУчет,
				|ПартииТоваровПереданныеМеждународныйУчет,");
	
				
	Возврат РегистрыПоВидамУчета;
	
КонецФункции // РегистрыПоВидамУчета

// Функция проверяет принадлежность указанного регистра всем требуемым видам учета
//
// Параметры:
//  ИмяРегистра				- Строка, содержащая имя проверяемого регистра
//  СтруктураВидовУчета		- Структура, содержащая перечень видов учета со значением Истина, для которых нужно производить проверку
//  РегистрыПоВидамУчета	- структура, содержащая принадлежность регистров к видам учета
//
// Возвращаемое значение:
//   Булево
//
Функция РегистрПринадлежитВидамУчета(ИмяРегистра, СтруктураВидовУчета, РегистрыПоВидамУчета = Неопределено) Экспорт
	
	Если РегистрыПоВидамУчета = Неопределено Тогда
		РегистрыПоВидамУчета = ПолучитьРегистрыПоВидамУчета();
	КонецЕсли;
				
	Для Каждого Элемент ИЗ СтруктураВидовУчета Цикл
		Если 
			Элемент.Значение													//Необходимо проверять этот вид учета
			И РегистрыПоВидамУчета.Свойство(Элемент.Ключ)						//Структура содержит регистры принадлежащие к виду учета
			И Найти(РегистрыПоВидамУчета[Элемент.Ключ],ИмяРегистра + ",") > 0	//Регистр найден в списке регистров, принадлежащих к виду учета
			Тогда
			Возврат Истина
		КонецЕсли;
	КонецЦикла;	
	
	//Регистр не принадлежит к проверяемым видам учета
	Возврат Ложь;			
	
КонецФункции //РегистрПринадлежитВидамУчета	

// Процедура заполняет субконто в строке набора записей
// Параметры 
// Запись - Строка набора записей регистра бухгалтерии
// Строка - Структура, содержащая значения субконто
//
Процедура ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
	
	Для НомерСчета = 1 по 2 Цикл
		
		Если НомерСчета = 1 тогда 
			СчетДтКТ = "Дт"
		Иначе
			СчетДтКТ = "Кт"
		КонецЕсли;
		
		Для НомерСубконто = 1 по 3 цикл
			
			ЗначениеСубконто = Строка["Субконто"+СчетДтКТ+НомерСубконто];

			ВидСубконто = Строка["ВидСубконто"+СчетДтКТ+НомерСубконто];
			Если ВидСубконто.ТипЗначения <> Неопределено Тогда
				Запись["Субконто"+СчетДтКТ].Вставить(ВидСубконто, ЗначениеСубконто);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;

КонецПроцедуры // ЗаполнитьСубконтоВНабореЗаписей

// Добавляет записи из таблицы движений в набор записей
// Параметры 
// НаборЗаписей - Набор записей регистра накопления или регистра бухгалтерии
// Таблица - таблица значений содержащая движения соответствующего регистра (таблица движений)
//
Процедура ДобавитьСтрокиВНаборЗаписей(НаборЗаписей, Таблица) Экспорт
	
	НаборМетаданные = НаборЗаписей.Метаданные();
		
	ЭтоРегистрБухгалтерии = (Метаданные.РегистрыБухгалтерии.Найти(НаборМетаданные.Имя)<>Неопределено);
	
	Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
	
	Период = Неопределено;
	
	Для Каждого Строка Из Таблица Цикл
		
		Запись = НаборЗаписей.Добавить();
			
		ЗаполнитьЗначенияСвойств(Запись,Строка);
			
		Запись.Активность = Истина;

		Если Запись.Период = '00010101' Тогда
			
			Если Период = Неопределено Тогда
				
				Период = Регистратор.Дата;
			
			КонецЕсли;
			
			Запись.Период = Период;
			
		КонецЕсли;
			
		Если ЭтоРегистрБухгалтерии тогда
			ЗаполнитьСубконтоВНабореЗаписей(Запись,Строка)
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры // ДобавитьСтрокиВНаборЗаписей

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// возвращает "количество полных и неполных гривень"
// Параметры:
//	Сумма - число
// Возвращаемое значение:
//  число, равное ближайшему целому "сверху"
Функция ЦелМаксимальное(Сумма) Экспорт
	Возврат ?(Цел(Сумма) = Сумма, Сумма, Цел(Сумма) + 1);
	
КонецФункции // ЦелМаксимальное()

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	ДлинаСтроки = СтрДлина(Источник);
	Для Поз = 1 По ДлинаСтроки Цикл
		ИскомыйСимвол = Сред(Источник,Поз,1);
		ЗначениеСимвола = Найти(ШеснадцатиричныеСимволы, ВРег(ИскомыйСимвол));
		Если ЗначениеСимвола <=0 Тогда
			#Если Клиент Тогда
				Сообщить("В числе обнаружен неверный символ: """ + ИскомыйСимвол+ """ ");
			#КонецЕсли
			Результат = 0;
			Прервать;
		Иначе
			ЗначениеСимвола = ЗначениеСимвола - 1;
			Результат = Результат + ЗначениеСимвола * Pow(16, ДлинаСтроки-Поз);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16 + 1;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции


// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УЧЕТНОЙ ПОЛИТИКОЙ

// Функция возвращает структуру с параметрами учетной политики (Упр) на заданную дату.
//
// Параметры:
//	Период					- дата на которую необходимо получить учетную политику
//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
//							когда на дату нет учетной политики
// Возвращаемое значение:
// <Структура>				- если на дату нет учетной политики, то Неопределено
//
Функция ПолучитьПараметрыУчетнойПолитикиУпр(Период, СообщатьОбОшибке = Истина, Заголовок = "") Экспорт

	Если НЕ ЗначениеЗаполнено(Период) Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаУпр");
	
	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
		// поэтому необходимо найти строку с периодом раньше даты, 
		// на которую необходимо получить УП
		Если СтрокаУчетнойПолитики.Период <= Период Тогда
			Результат = Новый Структура;
			
			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
			КонецЦикла;
			
			Возврат Результат;	
		КонецЕсли; 
	КонецЦикла;
	
	Если СообщатьОбОшибке Тогда
		ТекстОшибки = "Не указаны параметры учетной политики (управленческий учет) на " + Формат(Период, "ДЛФ=DD");
		СообщитьОбОшибке(ТекстОшибки,,Заголовок);
	КонецЕсли; 
	
	Возврат Неопределено;	
	
КонецФункции // ПолучитьПараметрыУчетнойПолитикиУпр

// Функция возвращает структуру с параметрами учетной политики (регл учета)
// на заданную дату по указанной организации.
//
// Параметры:
//	Период					- дата на которую необходимо получить учетную политику
//	Организация				- Организация по которой необходимо получить учетную политику
//	СообщатьОбОшибке		- булево, если Истина, то вывести сообщение,
//
// Возвращаемое значение:
// <Структура>				- если на дату нет учетной политики, то Неопределено
//
Функция ПолучитьПараметрыУчетнойПолитикиРегл(Период, Организация, СообщатьОбОшибке = Истина, Заголовок = "") Экспорт	

	Если НЕ ЗначениеЗаполнено(Период) 
		ИЛИ НЕ ЗначениеЗаполнено(Организация)  Тогда
		
		Возврат Неопределено;	
	КонецЕсли;
	
	Запрос = Новый Запрос;
	ТекстЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	               |	Организации.ОтражатьВРегламентированномУчете КАК ОтражатьВРегламентированномУчете
	               |ИЗ
	               |	Справочник.Организации КАК Организации
	               |ГДЕ
	               |	Организации.Ссылка = &Ссылка";
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Организация);
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Если НЕ Выборка.ОтражатьВРегламентированномУчете Тогда
			Возврат Неопределено;	
		КонецЕсли;
	КонецЕсли;
	
	УчетнаяПолитика = глЗначениеПеременной("УчетнаяПолитикаРегл");
	
	Для каждого СтрокаУчетнойПолитики Из УчетнаяПолитика Цикл
		// Строки таблицы УчетнаяПолитика упорядочены по убыванию,
		// поэтому необходимо найти строку с периодом раньше даты, 
		// на которую необходимо получить УП
		Если СтрокаУчетнойПолитики.Организация = Организация
			И СтрокаУчетнойПолитики.Период <= Период Тогда
			
			Результат = Новый Структура;
			
			Для Каждого Колонка Из УчетнаяПолитика.Колонки Цикл
				Результат.Вставить(Колонка.Имя, СтрокаУчетнойПолитики[Колонка.Имя]);
			КонецЦикла;
			
			
			Результат.Вставить("ЕстьНалогНаПрибыль" , Результат.ЕстьНалогНаПрибыльНал);
			Результат.Вставить("ЕстьНДС"            , Результат.ЕстьНДСНал);
			Результат.Вставить("ЕстьЕдиныйНалог"    , Результат.ЕстьЕдиныйНалогНал);
			
			Возврат Результат;	
		КонецЕсли; 
	КонецЦикла;
	
	Если СообщатьОбОшибке Тогда
		ТекстОшибки = "Не указаны параметры учетной политики (бухгалтерский и налоговый учет) на " + Формат(Период, "ДЛФ=DD") + " для организации " + Организация;
		СообщитьОбОшибке(ТекстОшибки,,Заголовок);
	КонецЕсли; 
	
	Возврат Неопределено;	

КонецФункции // ПолучитьПараметрыУчетнойПолитикиРегл

// Временная функция. Необходимо использовать функции ПолучитьПараметрыУчетнойПолитикиУпр и ПолучитьПараметрыУчетнойПолитикиРегл
//
Функция ПолучитьПараметрыУчетнойПолитики(КонДата, УчетнаяПолитикаНеЗадана, Организация = Неопределено, Учет = "упр", СообщатьОбОшибке = Истина, Заголовок = "") Экспорт
	
	Если НРег(Учет) = "упр" Тогда
		ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата, СообщатьОбОшибке, Заголовок);
	Иначе
		ПараметрыУчетнойПолитки = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация, СообщатьОбОшибке, Заголовок);
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(ПараметрыУчетнойПолитки) Тогда
		УчетнаяПолитикаНеЗадана = Истина;
	КонецЕсли; 
	
	Возврат ПараметрыУчетнойПолитки;
	
КонецФункции // ПолучитьПараметрыУчетнойПолитики

// Процедура выводить сообщение о необходимости перезапуска программы при изменении учетной политики
// если в ИБ работают другие пользователи.
//
Процедура СообщитьОбИзмененииУчетнойПолитики() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы() ;
	Для Каждого ТекСоединение Из МассивСоединений Цикл
		Если (ТекСоединение.ИмяПриложения = "1CV8") 
		   И (НЕ ТекСоединение.НомерСоединения = НомерСоединенияИнформационнойБазы())
		   И (НЕ ТекСоединение.Пользователь = неопределено) Тогда
			  
				Сообщить("Внимание! Вы изменили настройки учетной политики.
						 |В настоящий момент в базе работают пользователи. 
						 |Для того чтобы новые настройки начали действовать у других пользователей
						 |им необходимо перезапустить программу. 
						 |Для Вас новые настройки уже вступили в силу, перезапускать программу не требуется.", СтатусСообщения.Важное);
						 
				Возврат;
							
		КонецЕсли;
	КонецЦикла;			
	
КонецПроцедуры

// Функция дополняет структуру шапки документа положениями учетной политики.
//
Процедура ДополнитьПоложениямиУчетнойПолитики(СтруктураШапкиДокумента, КонДата, Отказ, Организация, Учет = "Нал", СтруктураПолейУчетнойПолитикиНУ = неопределено) Экспорт
	
	Если Учет = "Упр" Тогда
		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиУпр(КонДата);
	Иначе
		СтруктураУП = ПолучитьПараметрыУчетнойПолитикиРегл(КонДата, Организация);
	КонецЕсли; 
	Если НЕ ЗначениеЗаполнено(СтруктураУП) Тогда
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Для каждого ПараметрУП Из СтруктураУП Цикл
		Если (ТипЗнч(СтруктураПолейУчетнойПолитикиНУ) = Тип("Структура"))
		   И НЕ (СтруктураПолейУчетнойПолитикиНУ.Количество() = 0) Тогда
		   
		   // Заполнение определенными параметрами учетной политики
			Если СтруктураПолейУчетнойПолитикиНУ.Свойство(ПараметрУП.Ключ) Тогда
				Если НЕ ЗначениеЗаполнено(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ]) Тогда
					СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);
				Иначе
					СтруктураШапкиДокумента.Вставить(СтруктураПолейУчетнойПолитикиНУ[ПараметрУП.Ключ],ПараметрУП.Значение);
				КонецЕсли; 
			КонецЕсли; 
			
		Иначе	
			
			// Заполнение всеми параметрами учетной политики
			СтруктураШапкиДокумента.Вставить(ПараметрУП.Ключ,ПараметрУП.Значение);  
			
		КонецЕсли; 
	КонецЦикла; 
	
КонецПроцедуры // ДополнитьПоложениямиУчетнойПолитики()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ИНТЕРНЕТ-ПОДДЕРЖКИ ПОЛЬЗОВАТЕЛЕЙ

#Если Клиент Тогда

// Процедура выполняет открытие HTML-страницы 
// по указанному URL

#КонецЕсли

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии) Экспорт

	КоличествоТочек = 0;
	ДлинаОписанияНомераРелиза = 0;

	Для х = 1 По СтрДлина(НомерВерсии) Цикл

		Если Сред(НомерВерсии, х, 1) = "." Тогда
			КоличествоТочек = КоличествоТочек + 1;
		КонецЕсли;

		Если КоличествоТочек = 3 Тогда
			ДлинаОписанияНомераРелиза = х - 1;
			Прервать;
		КонецЕсли;

	КонецЦикла;

	Возврат Лев(НомерВерсии, ДлинаОписанияНомераРелиза);

КонецФункции // ПолучитьНомерРелиза()

////////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕМЕННЫМИ

// Меняет местами значения двух доступных для записи переменных
//
// Параметры
//  Источник - первая переменная
//  Приемник – вторая переменная
//
Процедура ПоменятьПеременныеМестами(Источник, Приемник) Экспорт

	тмп = Источник;
	Источник = Приемник;
	Приемник = Тмп;

КонецПроцедуры // ПоменятьПеременныеМестами()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

// Отбирает из переданной таблицы строки по заданным критериям.
//
// Параметры:
//  Источник - ТаблицаЗначений, РезультатЗапроса, ОбластьЯчеекТабличногоДокумента. Таблица-источник.
//  СтруктураКритериев - Структура. Названия отборов и значения, по которым нужно отобрать строки.
//  СтруктураСложныхКритериев - Структура. Если свойство передано, то значение содержит вид сравнения.
//
// Возвращаемое значение:
//  РезультатЗапроса - таблица с нужными строками.
//
Функция ОтобратьСтрокиПоКритериям(Источник, СтруктураКритериев, СтруктураСложныхКритериев = Неопределено) Экспорт

	Перем ВидСравненияСложный;

	Если СтруктураСложныхКритериев = Неопределено Тогда
		СтруктураСложныхКритериев = Новый Структура;
	КонецЕсли;

	ПостроительЗапроса = Новый ПостроительЗапроса;
	ПостроительЗапроса.ИсточникДанных = Новый ОписаниеИсточникаДанных(Источник);

	Для Каждого Критерий Из СтруктураКритериев Цикл
		НовыйОтбор = ПостроительЗапроса.Отбор.Добавить(Критерий.Ключ);

		СтруктураСложныхКритериев.Свойство(Критерий.Ключ, ВидСравненияСложный);

		Если ВидСравненияСложный = Неопределено Тогда
			НовыйОтбор.Установить(Критерий.Значение);
		Иначе
			НовыйОтбор.Использование = Истина;
			НовыйОтбор.ВидСравнения = ВидСравненияСложный;
			НовыйОтбор.Значение = Критерий.Значение;
		КонецЕсли;
	КонецЦикла;

	Возврат ПостроительЗапроса.Результат;

КонецФункции // ОтобратьСтрокиПоКритериям()

// Возвращает дату начала периода по имеющимся данным о:
// дате окончании периода, значении перечисления Период, количестве периодов
// 
Функция ПолучитьДатуНачалаПериодаПоДатеОкончанияКоличествуПериодов(ДатаОкончания, ПериодСсылка, КоличествоПериодов) Экспорт
	
	Если КоличествоПериодов = 0 Тогда
		КоличествоПериодов = 1;
	КонецЕсли;
	
	Если ДатаОкончания = Неопределено Тогда
		
		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = КонецДня(ТекущаяДата());
		ИначеЕсли КоличествоПериодов < 0 Тогда
			ДатаОкончания = НачалоДня(ТекущаяДата());
		КонецЕсли;
		
	КонецЕсли;
	
	Если (ПериодСсылка = Перечисления.Периодичность.День) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Неделя) Тогда
		ДатаНачала = НачалоДня(ДатаОкончания - 60*60*24*7 * КоличествоПериодов);
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Декада) Тогда
		ДеньМесяца = День(ДатаОкончания);
		НачМесяца = НачалоМесяца(ДатаОкончания);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
		
		НомерДекады = НомерДекады - КоличествоПериодов + ?(КоличествоПериодов > 0, 1 , -1);
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
		
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * 24 * 60 * 60;
		
		Возврат ?(КоличествоПериодов>0, Дт, ПолучитьКонецДекады(Дт));
		
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Месяц) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Квартал) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(3 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Полугодие) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(6 * КоличествоПериодов)));
	ИначеЕсли (ПериодСсылка = Перечисления.Периодичность.Год) Тогда
		ДатаНачала = НачалоДня(ДобавитьМесяц(ДатаОкончания, -(12 * КоличествоПериодов)));
	КонецЕсли;
	
	Если КоличествоПериодов > 0 Тогда
		Возврат ДатаНачала + 60*60*24;
	ИначеЕсли КоличествоПериодов < 0 Тогда
		Возврат КонецДня(ДатаНачала - 60*60*24);
	КонецЕсли;
	
КонецФункции

Функция ПолучитьОсновнойДоговорКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	ДоговорыКонтрагентов.Ссылка КАК ДоступныйДоговорКонтрагента
	|ИЗ
	|	Справочник.ДоговорыКонтрагентов КАК ДоговорыКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновнойДоговорКонтрагента = ДоговорыКонтрагентов.Ссылка
	|ГДЕ
	|	ДоговорыКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновнойДоговорКонтрагента ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступныйДоговорКонтрагента;		
	Иначе
		Возврат Справочники.ДоговорыКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции

Функция ПолучитьОсновноеКонтактноеЛицоКонтрагента(Контрагент) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	КонтактныеЛицаКонтрагентов.Ссылка КАК ДоступноеКонтактноеЛицоКонтрагента
	|ИЗ
	|	Справочник.КонтактныеЛицаКонтрагентов КАК КонтактныеЛицаКонтрагентов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Контрагенты КАК Контрагенты
	|		ПО (Контрагенты.Ссылка = &Контрагент)
	|			И Контрагенты.ОсновноеКонтактноеЛицо = КонтактныеЛицаКонтрагентов.Ссылка
	|ГДЕ
	|	КонтактныеЛицаКонтрагентов.Владелец = &Контрагент
	|
	|УПОРЯДОЧИТЬ ПО
	|	ВЫБОР
	|		КОГДА Контрагенты.ОсновноеКонтактноеЛицо ЕСТЬ NULL 
	|			ТОГДА 1
	|		ИНАЧЕ 0
	|	КОНЕЦ";
	
	Запрос.УстановитьПараметр("Контрагент", Контрагент);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат Выборка.ДоступноеКонтактноеЛицоКонтрагента;		
	Иначе
		Возврат Справочники.КонтактныеЛицаКонтрагентов.ПустаяСсылка();		
	КонецЕсли;	
		
КонецФункции


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

Функция ОпределитьТекущийРежимРаботыМонопольный() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

Процедура ПредупреждениеОбОшибке(ТекстСообщения) Экспорт
	 
	#Если Клиент Тогда
		
		Предупреждение(ТекстСообщения);
	
	#Иначе
		
		ВызватьИсключение(ТекстСообщения);
		
	#КонецЕсли
	 
КонецПроцедуры // ПредупреждениеОбОшибке()

Процедура ЗапуститьПрограмму(ПутьКПрограмме, РабочийКаталог = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		ЗапуститьПриложение(ПутьКПрограмме, РабочийКаталог);
	
	#КонецЕсли
	
КонецПроцедуры // ЗапуститьПрограмму()

///////////////////////////////////////////////////////////////////////////////
//// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С XML

// Функция осуществляет построение дерева XML.
//
// Параметры
//  XML             - <ЧтениеXML>
//                  - Объект, при помощи которого осуществляется чтение
//                    файла отчета.
//
//  Дерево          - <Структура>
//                  - Дерево XML.
//
//  ПервыйВызов     - <Булево>
//                  - Служебный параметр.
//
// Возвращаемое значение:
//  <Булево>        - Результат выполнения.
//
Функция ПостроитьДеревоXML(XML, Дерево, ПервыйВызов = Истина)

	Результат = Истина;
	Имя       = "";
	Врем      = Неопределено;
	Врем2     = Неопределено;
	Врем3     = Неопределено;

	Если ПервыйВызов Тогда
		Дерево = Новый Структура();
	КонецЕсли;

	Если XML.Прочитать() Тогда
		Если XML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Имя  = XML.ЛокальноеИмя;
			Врем = Новый Структура();
			Пока ПостроитьДеревоXML(XML, Врем, Ложь) Цикл
			КонецЦикла;
			Пока XML.Имя <> Имя Цикл
				Если XML.ТипУзла = ТипУзлаXML.Текст Тогда
					Врем = XML.Значение;
				КонецЕсли;
				Если Не XML.Прочитать() Тогда
					Результат = Ложь;
					Возврат Результат;
				КонецЕсли;
			КонецЦикла;
			Дерево.Свойство(Имя, Врем2);
			Если Врем2 = Неопределено Тогда
				Врем2 = Врем;
			Иначе
				Если ТипЗнч(Врем2) = Тип("Массив") Тогда
					Врем2.Добавить(Врем);
				Иначе
					Врем3 = Новый Массив();
					Врем3.Добавить(Врем2);
					Врем3.Добавить(Врем);
					Врем2 = Врем3;
				КонецЕсли;
			КонецЕсли;
			Дерево.Вставить(Имя, Врем2);
		Иначе
			Результат = Ложь;
		КонецЕсли;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции // ПостроитьДеревоXML()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ

Процедура УдалитьРегистрациюДокументаВПоследовательностях(ДокументОбъект, ПроверятьДвижения=ложь)
	//Очистим коллекцию движений документа
	ТаблицаСтаройРегистрацииВПоследовательности = Новый ТаблицаЗначений();
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("ИмяПоследовательности");
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Организация");
	ТаблицаСтаройРегистрацииВПоследовательности.Колонки.Добавить("Период");
	
	КоллекцияПоследовательностей = ДокументОбъект.ПринадлежностьПоследовательностям;
	Для Каждого НаборЗаписейРегистрацииВПоследовательности ИЗ КоллекцияПоследовательностей Цикл
		Если (НаборЗаписейРегистрацииВПоследовательности.Количество() > 0) Тогда
			Если НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчет"  
			  ИЛИ НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя = "ПартионныйУчетБУ" Тогда
			    НаборЗаписейРегистрацииВПоследовательности.Прочитать();
				Для Каждого ЗаписьВПоследовательности Из НаборЗаписейРегистрацииВПоследовательности Цикл
					НоваяЗаписьРегистрации = ТаблицаСтаройРегистрацииВПоследовательности.Добавить();
					НоваяЗаписьРегистрации.ИмяПоследовательности = НаборЗаписейРегистрацииВПоследовательности.Метаданные().Имя;
					НоваяЗаписьРегистрации.Организация = ЗаписьВПоследовательности.Организация;
					НоваяЗаписьРегистрации.Период = ЗаписьВПоследовательности.Период;
				КонецЦикла;	
				НаборЗаписейРегистрацииВПоследовательности.Очистить();
			КонецЕсли;	
		   	НаборЗаписейРегистрацииВПоследовательности.Записать();
		КонецЕсли;
	КонецЦикла;
	
	//Если коллекция пуста, то привилегированно очистим набор записей
	УправлениеЗапасамиПартионныйУчет.УдалитьРегистрациюДокументаВПоследовательностяхНаСервере(ДокументОбъект.Ссылка, ПроверятьДвижения, ТаблицаСтаройРегистрацииВПоследовательности);
	ТаблицаСтаройРегистрацииВПоследовательности.Свернуть("ИмяПоследовательности,Организация,Период"); 
	ДокументОбъект.ДополнительныеСвойства.Вставить("ТаблицаСтаройРегистрацииВПоследовательности",ТаблицаСтаройРегистрацииВПоследовательности);
	
КонецПроцедуры//УдалитьРегистрациюДокументаВПоследовательностях

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ РАБОТЫ С ПОСЛЕДОВАТЕЛЬНОСТЯМИ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ

// Функция загружает таблицы документа в таблицы соответствующие структуре регистров
//	Параметры:
//		- Движение - движение документа (т.е. регистр)
//		- СтруктТаблицДокумента - структура содержашая таблицы документа. ключ - имя таблицы, значение - таблица значений с данными документа.
//
//	Возврат:
//		- Структура, в которой ключ - это имя таблицы документа, соответствующий параметру СтруктТаблицДокумента,
//		  значение - таблица значений, со структурой соответствующей структуре параметра (т.е. регистра) Движение
//		  В таблицы значений данные загружаются по соответствию с имен полей.
//
Функция ЗагрузитьТаблицыДокументаВСтруктуру(Движение, СтруктТаблицДокумента) Экспорт
	
	ПустаяТабРегистра = Движение.Выгрузить();
	ПустаяТабРегистра.Очистить();
	
	СтруктДанных = Новый Структура;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		ТабРегистра = ПустаяТабРегистра.Скопировать();
		
		Если ТабЧасть.Значение <> Неопределено И ТабЧасть.Значение.Количество() > 0 Тогда
			ЗагрузитьВТаблицуЗначений( ТабЧасть.Значение, ТабРегистра);
		КонецЕсли;
		
		СтруктДанных.Вставить( ТабЧасть.Ключ, ТабРегистра);
		
	КонецЦикла;
	
	Возврат СтруктДанных;

КонецФункции // ЗагрузитьТаблицыДокументаВСтруктуру()

// Процедура заполняет структуру таблиц документа, значением которое будет одинаковым для всех таблиц (например значением шапки документа)
//	Параметры:
//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//		- ИмяПоля - имя колонки в таблицах локумента, в которую будет установлено новое значение
//		- УстанавливаемоеЗначение - значение, которое надо установить в таблицы документа
//		- СтрТабЧасти - имена таб. частей документа в которые необходимо установить новое значение. строка, в которой
//						имена таб. частей разделены запятыми. необязательный параметр, по умолчанию - все таблицы.
//
Процедура УстановитьЗначениеВТаблицыДокумента(СтруктТаблицДокумента, ИмяПоля, УстанавливаемоеЗначение, СтрТабЧасти = "") Экспорт
	
	СтруктТабЧасти = ?( ПустаяСтрока(СтрТабЧасти), СтруктТаблицДокумента, Новый Структура(СтрТабЧасти));
	Для Каждого ТабЧасть Из СтруктТабЧасти Цикл
	
		Если СтруктТаблицДокумента[ТабЧасть.Ключ].Количество() > 0 Тогда
		    СтруктТаблицДокумента[ТабЧасть.Ключ].ЗаполнитьЗначения( УстанавливаемоеЗначение, ИмяПоля);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры // УстановитьЗначениеВТаблицыДокумента()

// Процедура формирует движение в регистр на основании данных в таблицах документов
//	Параметры:
//		- Движение - движение документа, в которое необходимо произвести добавление записей (т.е. регистр)
//		- ВидДвижения - вид движения накопления (приход/расход)
//		- СтруктТаблицДокумента - структура таблиц документа, сформированная функцией ЗагрузитьТаблицыДокументаВСтруктуру()
//		- ДатаДвижения - дата на которую будут формироваться записи
//
Процедура ЗаписатьТаблицыДокументаВРегистр(Движение, ВидДвижения, СтруктТаблицДокумента, ДатаДвижения) Экспорт
	
	Движение.мПериод = ДатаДвижения;
	Для Каждого ТабЧасть Из СтруктТаблицДокумента Цикл
	
		Если ТабЧасть.Значение.Количество() = 0 Тогда
			Продолжить; // Пропускаем пустые табличные части
		КонецЕсли;
		
		Движение.мТаблицаДвижений = ТабЧасть.Значение;
		Если ВидДвижения = Неопределено Тогда // Регистр сведений
			ВыполнитьДвижениеПоРегистру(Движение);
		Иначе // Регистр накопления
			ВыполнитьДвижениеПоРегистру(Движение, ВидДвижения);
		КонецЕсли;
	
	КонецЦикла;

КонецПроцедуры // ЗаписатьТаблицыДокументаВРегистр()

// Процедура удаляет строки с пустыми значениями из структуры таблиц документа
//	Параметры:
//		- ТаблицыДляДвиженийПоЗаказам - структура таблиц документа
//		- ИмяПоля - имя поля, значение которого проверяет на пустое значение.
//
Процедура УдалитьСтрокиИзТаблицДокумента(ТаблицыДляДвиженийПоЗаказам, ИмяПоля) Экспорт

	Для Каждого ТабЧасть Из ТаблицыДляДвиженийПоЗаказам Цикл
		КолвоСтрок = ТабЧасть.Значение.Количество(); 
		Для Инд = 1 По КолвоСтрок Цикл 
		     ТекСтрока = ТабЧасть.Значение[КолвоСтрок - Инд]; 

		     Если НЕ ЗначениеЗаполнено(ТекСтрока[ИмяПоля]) Тогда 
		          ТабЧасть.Значение.Удалить(ТекСтрока); 
		     КонецЕсли; 
		КонецЦикла; 
	КонецЦикла;
	
КонецПроцедуры // УдалитьСтрокиИзТаблицДокумента()

// Процедура переименовывает колонку таблицы значений, с сохранением истории переименований для возможности последующего "отката"
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований. Новые сведения о переименованных колонках добавляются сюда и возвращаются в вызвавшую процедуру
//		- ТекИмяКолонки - имя колонки которую надо переименовать
//		- НовоеИмяКолонки - новое имя колонки. Если параметр не задан, новое имя присваивается автоматически
//
Процедура ПереименоватьКолонкуТаблицыЗначений(ТабЗначений, ТабИмен, Знач ТекИмяКолонки, Знач НовоеИмяКолонки = "") Экспорт

	Если ТабИмен = Неопределено Тогда
		ТабИмен = Новый ТаблицаЗначений;
		ТабИмен.Колонки.Добавить("НовИмя", Новый ОписаниеТипов("Строка"));
		ТабИмен.Колонки.Добавить("ТекИмя",   Новый ОписаниеТипов("Строка"));
	КонецЕсли;
	
	ТекКолонка = ТабЗначений.Колонки.Найти(ТекИмяКолонки);
	Если ПустаяСтрока(НовоеИмяКолонки) Тогда
		// Генерируем новое имя для старой колонки, гарантируя что оно будет уникальным
		Индекс = 1;
		Пока Истина Цикл
			НовоеИмяКолонки = "_" + Строка(Индекс) + "_" + ТекИмяКолонки;
			Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			Индекс = Индекс + 1;
		КонецЦикла;
		// После выхода из цикла в переменной НовоеИмяКолонки должны получить новое имя колонки,
	Иначе
		// проверим, что нового имя колонки еще нет в таблице, если есть 
		// переименуем его в новое уникальное имя и добавим в таблицу имен
		Если ТабЗначений.Колонки.Найти(НовоеИмяКолонки) <> Неопределено Тогда
			НовоеИмяНовойКолонки = "";
			Индекс = 1;
			Пока Истина Цикл
				НовоеИмяНовойКолонки = "_" + Строка(Индекс) + "_" + НовоеИмяКолонки;
				Если ТабЗначений.Колонки.Найти(НовоеИмяНовойКолонки) = Неопределено Тогда
					Прервать;
				КонецЕсли;
				Индекс = Индекс + 1;
			КонецЦикла;
			// После выхода из цикла в переменной НовоеИмяНовойКолонки должны получить новое имя, 
			// в которое можно переименовать НовоеИмяКолонки, переименуем его и добавим в таблицу имен
			ТабЗначений.Колонки[НовоеИмяКолонки].Имя = НовоеИмяНовойКолонки;
			// Сохраним имя колонки в таб. имен
			НоваяСтрока = ТабИмен.Добавить();
			НоваяСтрока.НовИмя = НовоеИмяНовойКолонки;
			НоваяСтрока.ТекИмя = НовоеИмяКолонки;
		КонецЕсли;
	КонецЕсли;
	
	// Переименуем колонку
	ТабЗначений.Колонки[ТекИмяКолонки].Имя = НовоеИмяКолонки;
	
	// Сохраним имя колонки в таб. имен
	НоваяСтрока = ТабИмен.Добавить();
	НоваяСтрока.НовИмя = НовоеИмяКолонки;
	НоваяСтрока.ТекИмя = ТекИмяКолонки;

КонецПроцедуры // ПереименоватьКолонкуТаблицыЗначений()

// Процедура восстанавливает имена колонок таблицы значений, сохраненные в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
//	Параметры:
//		- ТабЗначений - таблица значений в которой производится переименование колонок
//		- ТабИмен - таблица с историей переименований, таблица создается и заполняется в процедуре ПереименоватьКолонкуТаблицыЗначений()
//
Процедура ВосстановитьИменаКолонокТаблицыЗначений(ТабЗначений, ТабИмен) Экспорт
	
	К = ТабИмен.Количество() - 1;
	Пока К >= 0 Цикл
		ТекСтрока = ТабИмен[К];
		ТабЗначений.Колонки[ТекСтрока.НовИмя].Имя = ТекСтрока.ТекИмя;
		К = К - 1;
	КонецЦикла;
	
	ТабИмен.Очистить();

КонецПроцедуры // ВосстановитьИменаКолонокТаблицыЗначений()

// ПРОЦЕДУРЫ И ФУНКЦИИ ДЛЯ ФОРМИРОВАНИЯ ДВИЖЕНИЙ ДОКУМЕНТОВ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ

// Устанавливает управляемую блокировку таблицы
//
// Параметры:
//  СтруктураПараметров 		- <Структура>. Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - <Строка> - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - <Строка> - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - <РежимБлокировкиДанных> - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - <Строка> - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  СтруктураЗначенийБлокировки	- <Структура> - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки, значение - блокируемое значение.
//									Если передано Неопределено или если структура не содержит ни одного элемента -
//									блокировки через УстановитьЗначение() не накладываются.
//  СтруктураИсточникаДанных	- <Структура> - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки, значение - поле источника данных.
//									Если передано Неопределено или если структура не содержит ни одного элемента -
//									блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//  Отказ 						- <Булево> - при ошибке в процессе установки блокировки в этот параметр процедура возвращает значение Истина
//  Заголовок 					- <Строка> - заголовок сообщения об ошибке при установке блокировки
//
Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, СтруктураЗначенийБлокировки = Неопределено, СтруктураИсточникаДанных = Неопределено, Отказ, Заголовок) Экспорт
	
	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИспользоватьЗначенияБлокировки = СтруктураЗначенийБлокировки <> Неопределено 
		И ТипЗнч(СтруктураЗначенийБлокировки) = Тип("Структура") 
		И СтруктураЗначенийБлокировки.Количество() > 0;
		
	ИспользоватьИсточникДанных     = СтруктураИсточникаДанных <> Неопределено 
		И ТипЗнч(СтруктураИсточникаДанных) = Тип("Структура") 
		И СтруктураИсточникаДанных.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");
	
	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Возврат;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	
	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления") + ".";
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);
	
	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;
	
	Если ИспользоватьЗначенияБлокировки Тогда
	
		Для каждого ЭлементСтруктуры Из СтруктураЗначенийБлокировки Цикл
			ЭлементБлокировки.УстановитьЗначение(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЦикла;
	
	КонецЕсли;
	
	Если ИспользоватьИсточникДанных Тогда
		
		ИсточникДанных = СтруктураПараметров.ИсточникДанных; 
		
		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда
		
			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементСтруктуры.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			ТекстЗапроса = 			
			"ВЫБРАТЬ РАЗЛИЧНЫЕ"
			+ ТекстЗапроса + "
			|ИЗ
			|	" + СтруктураПараметров.ИмяВременнойТаблицы + " КАК Таб";
			Запрос.Текст = ТекстЗапроса;
			Результат    = Запрос.Выполнить();
			
			ЭлементБлокировки.ИсточникДанных = Результат;
			
		Иначе
			
			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;
			
		КонецЕсли;
	
		Для каждого ЭлементСтруктуры Из СтруктураИсточникаДанных Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементСтруктуры.Ключ, ЭлементСтруктуры.Значение);
		КонецЦикла;
	
	КонецЕсли;
	
	Попытка
	
		Блокировка.Заблокировать();
	
	Исключение
		
		ОбщегоНазначения.СообщитьОбОшибке(ОписаниеОшибки(), Отказ, Заголовок);
	    ВызватьИсключение "Операция не выполнена";
	КонецПопытки;

КонецПроцедуры

// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УПРАВЛЯЕМЫМИ БЛОКИРОВКАМИ
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПАРАМЕТРОВ СЕАНСА, ПЕРЕМЕННЫХ МОДУЛЯ ПРИЛОЖЕНИЯ

// Функция определяет наличие клиентских подключений к базе других пользователей
Функция ЕстьДругиеПользователиВБазе() Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда			
			Возврат Истина;						
		КонецЕсли;		
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

// Функция собирает паспортные данные физ. лица на указанную дату
//
// Параметры: 
//  ФизЛицо.    - физ. лицо, для которго необходимо получить паспортные данные
//  ДатаПериода - дата получения сведений
//
// Возвращаемое значение:
//  Структура с паспортными данными.
//
Функция ПаспортныеДанные(ФизЛицо, ДатаПериода) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ПарФизЛицо",     ФизЛицо);
	Запрос.УстановитьПараметр("ПарДатаПериода", ДатаПериода);

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ДокументВид        КАК Вид,
	|	ДокументСерия      КАК Серия,
	|	ДокументНомер      КАК Номер,
	|	ДокументДатаВыдачи КАК ДатаВыдачи,
	|	ДокументКемВыдан   КАК Выдан
	|ИЗ
	|	РегистрСведений.ПаспортныеДанныеФизЛиц.СрезПоследних(&ПарДатаПериода, ФизЛицо = &ПарФизЛицо)
	|";

	Шапка = Запрос.Выполнить().Выбрать();
	Шапка.Следующий();

	Результат = Новый Структура("Вид, Серия, Номер, ДатаВыдачи, Выдан");

	Результат.Вид        = Шапка.Вид;
	Результат.Серия      = Шапка.Серия;
	Результат.Номер      = Шапка.Номер;
	Результат.ДатаВыдачи = Шапка.ДатаВыдачи;
	Результат.Выдан      = Шапка.Выдан;

	Возврат Результат;

КонецФункции // ПаспортныеДанные()

// Получает параметр учетной политики (налоговый учет) для заданной организации на заданную дату
//
// Параметры:
//	ИмяПараметра        - строка, имя запрашиваемого параметра учетной политики,
//	Организация         - ссылка на элемент справочника "Организации", для которого надо получить параметры,
//	Дата                - дата, на которую надо получить параметры, если не заполнено, то берется рабочая дата,
//	СтруктураПараметров - структура, содержащая все параметры учетной политики.
//
// Возвращаемое значение:
//	Значение учетной политики
//
Функция ВыгрузитьСтруктуруВСтроку(Структура,ПоЗначениям=Ложь,СтруктураПроверки = Неопределено) Экспорт
	
	НеПроверять = (СтруктураПроверки=Неопределено);
	
	НоваяСтрока = "";
	Для каждого Колонка из Структура Цикл
		Если НеПроверять тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение)или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)+",";
		ИначеЕсли СтруктураПроверки.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение) или не ПоЗначениям,Колонка.Ключ,Колонка.Значение)) тогда
			НоваяСтрока = НоваяСтрока + ?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)+",";
		Иначе
			//Нет в проверке!
			возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Если ЗначениеЗаполнено(НоваяСтрока) Тогда
		НоваяСтрока = Лев(НоваяСтрока,СтрДлина(НоваяСтрока)-1);
	КонецЕсли;
	Возврат НоваяСтрока;
КонецФункции

//Процедура для распределения записей из одной таблицы значений по базису (таблица значений или  набору записей)
//Источник 		: ТаблицаЗначений
//Базис 		: ТаблицаЗначений или НаборЗаписей
//Распределение : ключ - поля базиса, значение - поля источника
//Фильтр 		: ключ - поля базиса, значение - поля источника (если не укзан - по совпадающим колонкам)
//Игнорировать  : ключ - поля базиса, значение - поля источника
//Дополнить		: ключ - имя нового поля базиса, значение - значение для заполнения
Функция СформироватьКорректирующиеЗаписи(Источник,Базис,Распределение,Фильтр=неопределено,Игнорировать=Неопределено,Дополнить=Неопределено, НераспределенныеЗаписи_AsIs = ложь) Экспорт
	
	Если ТипЗнч(Базис) = Тип("ТаблицаЗначений") тогда
		Временный_Базис	   = Базис.Скопировать();
	иначе
		Временный_Базис	   = Базис.Выгрузить();
	Конецесли;
	
	КолонкиИсточника = Новый Структура();
	Для Каждого Колонка Из источник.Колонки Цикл
		КолонкиИсточника.Вставить(Колонка.Имя);
	КонецЦикла;
	КолонкиБазиса = Новый Структура();
	Для Каждого Колонка Из Временный_Базис.Колонки Цикл
		Если Не(НЕ ЗначениеЗаполнено(Колонка.Имя)) тогда
			КолонкиБазиса.Вставить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(Игнорировать) тогда
		 Игнорировать = новый Структура();
	Иначе
		//Зачистим колонки источника и базиса на игнорируемые колонки
		Для Каждого Колонка Из Игнорировать Цикл
			Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
				 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
			Конецесли;
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				 КолонкиБазиса.Удалить(Колонка.Ключ);
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Зачистим колонки источника на распределяемые колонки. Они учитываются отдельно.
	Для Каждого Колонка Из Распределение Цикл
		Если КолонкиИсточника.Свойство(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)) тогда
			 КолонкиИсточника.Удалить(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение));
		Иначе
			 Если Источник.Колонки.Найти(?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение))=Неопределено тогда
				 //Не хватает колонок к распределению
				 //Но одну и ту же колонку можно распределить дважды
				 Возврат ложь;
			 КонецЕсли;
		Конецесли;
		Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			 КолонкиБазиса.Удалить(Колонка.Ключ);
		Иначе
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	Если ЗначениеЗаполнено(Дополнить) тогда
		//Проверим на отсутствие дополняемых колонок!
		Для Каждого Колонка Из Дополнить Цикл
			Если КолонкиБазиса.Свойство(Колонка.Ключ) тогда
				//Такая колонка уже есть, нельзя добавить новую
				Возврат Ложь;
			Конецесли;
		КонецЦикла;
 	КонецЕсли;
	
	//Если фильтр не задан - по всем совпадающим колонкам
	Если Фильтр=Неопределено тогда
		Фильтр = Новый Структура();
		Для каждого Колонка из КолонкиБазиса цикл
			Если КолонкиИсточника.Свойство(Колонка.Ключ)  и не(Игнорировать.Свойство(Колонка.Ключ)) тогда
				Фильтр.Вставить(Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(Фильтр) тогда
		//Должно быть хоть одно объединяющее поле!
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Колонка Из Фильтр Цикл
		Если не КолонкиБазиса.Свойство(Колонка.Ключ) тогда
			  //Не хватает колонок базиса распределения
			 Возврат ложь;
		Конецесли;
	КонецЦикла;
	
	
	//Подготовить сворачивание для источника
	СтрокаСверткиИсточник = ВыгрузитьСтруктуруВСтроку(Фильтр,Истина,КолонкиИсточника);
	Если СтрокаСверткиИсточник = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в источнике!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюИсточник = ВыгрузитьСтруктуруВСтроку(Распределение,Истина);
	Если КолонкиКРаспределениюИсточник = ложь Тогда
		//попытка распределить поле, отсутствующее в источнике!
		Возврат ложь;
	КонецЕсли;
	
	//Подготовить сворачивание для базиса
	СтрокаСверткиБазис = ВыгрузитьСтруктуруВСтроку(КолонкиБазиса,Ложь);
	Если СтрокаСверткиБазис = ложь Тогда
		//попытка фильтровать по полю, отсутствующему в базисе!
		Возврат ложь;
	КонецЕсли;
	КолонкиКРаспределениюБазис = ВыгрузитьСтруктуруВСтроку(Распределение,Ложь);
	Если КолонкиКРаспределениюБазис = ложь Тогда
		//попытка распределить поле, отсутствующее в базисе!
		Возврат ложь;
	КонецЕсли;
	
	Временный_Источник = Источник.Скопировать();
	
	Временный_Базис.Свернуть(СтрокаСверткиБазис,КолонкиКРаспределениюБазис);
	Временный_Источник.Свернуть(СтрокаСверткиИсточник,КолонкиКРаспределениюИсточник);
	
	НоваяТаблица = новый ТаблицаЗначений();
	Для каждого Колонка из Временный_Базис.Колонки Цикл
		Если Колонка.ТипЗначения.СодержитТип(Тип("Число")) Тогда
			Разрядность = Колонка.ТипЗначения.КвалификаторыЧисла.Разрядность;
			РазрядностьДробнойЧасти = Колонка.ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
			
			ТипЗначения = Новый ОписаниеТипов(Колонка.ТипЗначения,,,КвалификаторЧисла);
		Иначе
			ТипЗначения = Колонка.ТипЗначения;
		КонецЕсли;
		
		НоваяТаблица.Колонки.Добавить(Колонка.Имя, ТипЗначения,,10);
	КонецЦикла;
	
	ТаблицаБазисовРаспределения = Новый ТаблицаЗначений();
	Для каждого Колонка из Распределение Цикл
		ТаблицаБазисовРаспределения.Колонки.Добавить(Колонка.Ключ);
	КонецЦикла;
	
	Для каждого СтрокаИсточника из Временный_Источник цикл
		Отбор = новый структура();
		Для каждого Колонка из Фильтр цикл
			Отбор.Вставить(Колонка.Ключ,СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)]);
		КонецЦикла;
		СтрокиБазиса = Временный_Базис.НайтиСтроки(Отбор);
		Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено;
		Если СтрокиБазиса.Количество() = 0 и НераспределенныеЗаписи_AsIs Тогда
			Временный_Базис_СтрокаНераспределеннойЗаписи = Временный_Базис.Добавить();
			ЗаполнитьЗначенияСвойств(Временный_Базис_СтрокаНераспределеннойЗаписи, СтрокаИсточника);
			СтрокиБазиса.Добавить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли;		
			
		ТаблицаБазисовРаспределения.Очистить();
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаТБР = ТаблицаБазисовРаспределения.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаТБР, Строка);
		КонецЦикла;
		Для каждого Колонка из Распределение цикл
			РаспределяемаяСумма =  СтрокаИсточника[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)];
			МассивДляРаспределения = ТаблицаБазисовРаспределения.ВыгрузитьКолонку(Колонка.Ключ);
			РазрядностьДробнойЧасти = Временный_Источник.Колонки[?(НЕ ЗначениеЗаполнено(Колонка.Значение),Колонка.Ключ,Колонка.Значение)].ТипЗначения.КвалификаторыЧисла.РазрядностьДробнойЧасти;
			МассивРезультата = РаспределитьПропорционально(РаспределяемаяСумма, МассивДляРаспределения,?(РазрядностьДробнойЧасти = 0, 3, РазрядностьДробнойЧасти));
			Если МассивРезультата = неопределено тогда
				ТаблицаБазисовРаспределения.ЗаполнитьЗначения(0,Колонка.Ключ);
			иначе
				ТаблицаБазисовРаспределения.ЗагрузитьКолонку(МассивРезультата,Колонка.Ключ);
			КонецЕсли;
		КонецЦикла;
		
		СтрокаРезультата = 0;
		Для каждого Строка из СтрокиБазиса Цикл
			СтрокаНовая = НоваяТаблица.Добавить();
			СрокаРекультатаРаспределения = ТаблицаБазисовРаспределения[СтрокаРезультата];
			СтрокаРезультата = СтрокаРезультата +1;
			Для каждого Колонка из Временный_Базис.Колонки цикл
				Если Распределение.Свойство(Колонка.Имя) тогда
					СтрокаНовая[Колонка.Имя] = СрокаРекультатаРаспределения[Колонка.Имя];
				Иначе
					СтрокаНовая[Колонка.Имя] = Строка[Колонка.Имя];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		Если не Временный_Базис_СтрокаНераспределеннойЗаписи = Неопределено Тогда
		    Временный_Базис.удалить(Временный_Базис_СтрокаНераспределеннойЗаписи);
		КонецЕсли; 
	КонецЦикла;
	Если ЗначениеЗаполнено(Дополнить) тогда
		Для каждого Колонка из Дополнить Цикл
			НоваяТаблица.Колонки.Добавить(Колонка.Ключ,,,10);
			НоваяТаблица.ЗаполнитьЗначения(Колонка.Значение,Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	СтрокиС0Распределением = Новый Массив();
	Для каждого Строка из НоваяТаблица цикл
		СуммаРаспределений0=Истина;
		Для каждого Колонка из распределение цикл
			Если ЗначениеЗаполнено(Строка[Колонка.Ключ]) тогда
				СуммаРаспределений0=Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если СуммаРаспределений0 тогда
			СтрокиС0Распределением.Добавить(Строка);
		Конецесли;
	КонецЦикла;
	Для каждого ПустаяСтрока из СтрокиС0Распределением Цикл 
		НоваяТаблица.Удалить(ПустаяСтрока);
	КонецЦикла;
	//Если ЗначениеЗаполнено(ИсключитьПослеРаспределения) тогда
	//	КолонкиРезультата = Новый Структура();
	//	Для каждого Колонка из НоваяТаблица.Колонки Цикл
	//		Если ИсключитьПослеРаспределения.Свойство(Колонка.Имя) = Истина  или Распределение.Свойство(Колонка.Имя) = Истина Тогда
	//			Продолжить;
	//		Иначе
	//			КолонкиРезультата.Вставить(Колонка.Имя);
	//		КонецЕсли;
	//	КонецЦикла;
	//	КолонкиКСворачиванию = ВыгрузитьСтруктуруВСтроку(КолонкиРезультата,Ложь);
	//	НоваяТаблица.Свернуть(КолонкиКСворачиванию,КолонкиКРаспределениюБазис);
	//КонецЕсли;
	
	Возврат НоваяТаблица;
КонецФункции

Функция ВыгрузитьСтрокиДереваВТаблицуЗначений(Источник,КоллекцияКолонокДереваЗначений) Экспорт

	Реквизиты = Новый Структура();
	Для каждого Колонка из КоллекцияКолонокДереваЗначений цикл
		Реквизиты.Вставить(Колонка.Имя);
	КонецЦикла;
	
	НоваяТЗ= Новый ТаблицаЗначений();
	
	Пока НоваяТЗ.Количество()<Источник.Количество() Цикл
		Строка = НоваяТЗ.Добавить();
	КонецЦикла;
	
	Для каждого ТекРеквизит из Реквизиты Цикл
		ИскомыйРеквизит = ТекРеквизит.Ключ;
		НовыйРеквизит 	= ?(ТекРеквизит.Значение = Неопределено,ТекРеквизит.Ключ,ТекРеквизит.Значение);
		ИсточникКолонка = КоллекцияКолонокДереваЗначений.Найти(ИскомыйРеквизит);
		НоваяТЗ.Колонки.Добавить(НовыйРеквизит, ИсточникКолонка.ТипЗначения);
		НоваяТЗ.ЗагрузитьКолонку(Источник.ВыгрузитьКолонку(ИскомыйРеквизит),НовыйРеквизит);
	КонецЦикла;
	
    Возврат НоваяТЗ;
КонецФункции // СформироватьТаблицуОплаты()

// Возвращает строку, описывающую период, определяемый переданными
// датой и периодичностью.
//
// Параметры
//  ДатаВПериоде:Дата - дата из периода
//  Периодичность: Строка - строка, определяющая периодичность
//
// Возвращаемое значение:
//   СтрокаПериод: строка   – представление периода для вывода в отчетах
//
Функция ПолучитьПериодСтрокой(ДатаВПериоде, Периодичность, КодЯзыка = "ru") Экспорт
	
	Если Периодичность = "Год" Тогда
		ФорматДаты = "ДФ='гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Квартал" Тогда
		ФорматДаты = "ДФ='к"" квартал"" гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Месяц" Тогда
		ФорматДаты = "ДФ='ММММ гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
		
	ИначеЕсли Периодичность = "Неделя" Тогда
		ФорматДаты = "ДФ='" + НСтр("ru='""Неделя (""';uk='""Тиждень (""'", КодЯзыка) + "дд.ММ.гггг'";
		
	ИначеЕсли Периодичность = "День" Тогда
		ФорматДаты = "ДФ='дд.ММ.гггг " + НСтр("ru='""г.""';uk='""р.""'", КодЯзыка) + "'";
	Иначе
		ФорматДаты = "";
		
	КонецЕсли;
	
	СтрокаПериод = "" + Формат(ДатаВПериоде, ФорматДаты + ";Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));

	Если Периодичность = "Неделя" И ТипЗнч(ДатаВПериоде) = Тип("Дата") Тогда
		СтрокаПериод = "" + НеделяГода(ДатаВПериоде) + НСтр("ru='-ая ';uk='-ий '",КодЯзыка) + СтрокаПериод + Формат(КонецНедели(ДатаВПериоде), "ДФ='"" - ""дд.ММ.гггг)'" + ";Л="+ Локализация.ОпределитьКодЯзыкаДляФормат(КодЯзыка));
	КонецЕсли;
	
	Возврат СтрокаПериод;
	
КонецФункции // ПолучитьПериодСтрокой()

// Процедура предназначена для получения момента определения остатков для заполнения документа.
//
// Параметры:
//  ДокОбъект - (ДокументОбъект), документ, для которого надо определить лату получения остатков.
//
// Возвращаемое значение.
//  Дата (момент времени) - дата остатков
//
Функция ПолучитьДатуОстатков(ДокОбъект) Экспорт
	
	ДатаОстатков = '00010101';
	Если НачалоДня(ДокОбъект.Дата) <> НачалоДня(ТекущаяДата()) 
	   И ДокОбъект.Дата <> '00010101' Тогда
	   
		Если НЕ ЗначениеЗаполнено(ДокОбъект.Ссылка) Тогда
			ДатаОстатков = КонецДня(ДокОбъект.Дата);
		Иначе
			ДатаОстатков = ДокОбъект.МоментВремени();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДатаОстатков;
	
КонецФункции

// Стандартная для данной конфигурации функция форматирования сумм
//
// Параметры: 
//  Сумма  - число, которое мы хотим форматировать, 
//  Валюта - ссылка на элемент справочника валют, если задан, то к в результирующую строку
//           будет добавлено представление валюты
//  ЧН     - строка, представляющая нулевое значение числа,
//  ЧРГ    - символ-разделитель групп целой части числа.
//
// Возвращаемое значение:
//  Отформатированная должным образом строковое представление суммы.
//
Функция ФорматСумм(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=2" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Валюта <> Неопределено Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()

//Смартис Лиманчук начало 31.01.2013
Функция ФорматСумм4(Сумма, Валюта = Неопределено, ЧН = "", ЧРГ = "") Экспорт

	ФорматнаяСтрока = "ЧЦ=15;ЧДЦ=4" +
					?(ПустаяСтрока(ЧН), "", ";" + "ЧН=" + ЧН) +
					?(ПустаяСтрока(ЧРГ),"", ";" + "ЧРГ=" + ЧРГ);
	РезультирующаяСтрока = СокрЛ(Формат(Сумма, ФорматнаяСтрока));
	
	Если Валюта <> Неопределено Тогда
		РезультирующаяСтрока = РезультирующаяСтрока + " " + СокрП(Валюта);
	КонецЕсли;

	Возврат РезультирующаяСтрока;

КонецФункции // ФорматСумм()
//Смартис Лиманчук окончание 31.01.2013

// Удаляет повторяющиеся значения из массива
//
// Параметры:
//	Массив
//
Процедура УдалитьПовторяющиесяЭлементы(Массив) Экспорт
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда
		
		// Удалим повторы
		Инд=0;
		КолВо = Массив.Количество();
		
		Пока Инд<КолВо Цикл
			
			Инд2 = Инд+1;
			Пока Инд2<КолВо Цикл
				
				Если Массив[Инд2] = Массив[Инд] Тогда
					Массив.Удалить(Инд2);
					КолВо = КолВо-1;
				Иначе
					Инд2 = Инд2+1;
				КонецЕсли;
				
			КонецЦикла; 
			
			//Установим для не заполненных значений тип "Неопределено"
			Если НЕ ЗначениеЗаполнено(Массив[Инд]) Тогда
				Массив[Инд] = Неопределено;
			КонецЕсли;

			Инд = Инд+1;
			
		КонецЦикла; 
		
	КонецЕсли;
	
КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф = Неопределено Или МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда	
		Возврат Неопределено;
	КонецЕсли;

	// Массив коэффициентов необходимо упорядочить, поэтому создадим таблицу для распределения
    УпорядоченнаяТаблица = Новый ТаблицаЗначений;
	УпорядоченнаяТаблица.Колонки.Добавить("Коэф", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(17,4)));
	УпорядоченнаяТаблица.Колонки.Добавить("ИсходныйИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15,0)));
	
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + МассивКоэф[К];
		
		СтрокаТаблицы = УпорядоченнаяТаблица.Добавить();
		СтрокаТаблицы.Коэф = МассивКоэф[К];
		СтрокаТаблицы.ИсходныйИндекс = К;
	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	УпорядоченнаяТаблица.Сортировать("Коэф Убыв");
	
	МассивСумм = Новый Массив(УпорядоченнаяТаблица.Количество());
	
	Для каждого СтрокаТаблицы Из УпорядоченнаяТаблица Цикл
		// Возвращаемый результат должен быть в том же порядке
		МассивСумм[СтрокаТаблицы.ИсходныйИндекс] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * МассивКоэф[СтрокаТаблицы.ИсходныйИндекс] / СуммаКоэф, Точность, 1), 0);
		
		ИсхСумма = ИсхСумма - МассивСумм[СтрокаТаблицы.ИсходныйИндекс]; 
		СуммаКоэф = СуммаКоэф - МассивКоэф[СтрокаТаблицы.ИсходныйИндекс]; 
	КонецЦикла;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Процедура копирует значения одной строки таблицы значеницй в другую
// структура колонок должна совпадать
//
// Параметры:
//		СтрокаПриемник - строка в которую копируем
//		СтрокаИсточник - строка из которой копируем
//      ИменаКол - имена колонок, разделенные запятыми, которые надо скопировать
//                 необязателен. По умолчанию - все колонки
//
Процедура КопироватьСтрокуТаблицыЗначений(СтрокаПриемник, СтрокаИсточник, ИменаКол) Экспорт

	Если ТипЗнч( ИменаКол) = Тип("ТаблицаЗначений") Тогда
		СписокСвойств = "";
		Для Каждого Кол Из ИменаКол.Колонки Цикл
			Если Не Кол.Имя = "НомерСтроки" Тогда
				Если Не ПустаяСтрока(СписокСвойств) Тогда
					СписокСвойств = СписокСвойств + ",";	
				КонецЕсли;
				СписокСвойств = СписокСвойств + Кол.Имя;
			КонецЕсли;
		КонецЦикла;
		ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, СписокСвойств,);
	Иначе // Строка с именами колонок
        ЗаполнитьЗначенияСвойств(СтрокаПриемник, СтрокаИсточник, ИменаКол,);
	КонецЕсли;

КонецПроцедуры // КопироватьСтрокуТаблицыЗначений()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт

	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;

	Номер = СокрЛП(Документ.Номер);
	
	МетаданныеДокумента = Неопределено;
	
	Если ТипЗнч(Документ) <> Тип("ВыборкаИзРезультатаЗапроса")
		И ТипЗнч(Документ) <> Тип("Структура") Тогда
		
		МетаданныеДокумента = Документ.Метаданные(); 
		Если МетаданныеДокумента.Реквизиты.Найти("НомерВходящегоДокумента") <> Неопределено Тогда			
			Если ЗначениеЗаполнено(Документ.НомерВходящегоДокумента) Тогда
				Номер = СокрЛП(Документ.НомерВходящегоДокумента);		
			КонецЕсли;		
		КонецЕсли;	
		
	КонецЕсли;
		
	ПрефиксДоверенности = "";
	Префикс = "";
	Если МассивПрефиксов = Неопределено Тогда
		
		Организация = Неопределено;
		
		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда

			Организация = Документ.Организация;
			
		Иначе
			
			Если МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено Тогда

				Организация = Документ.Организация;

			КонецЕсли;
			
			Если МетаданныеДокумента.Имя = "Доверенность" Тогда
				ПрефиксДоверенности = "Д";
			КонецЕсли;

		КонецЕсли;
		
		МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
		
	Иначе
		
		МассивПрефиксовДляОбхода = МассивПрефиксов;
		
	КонецЕсли;
	
	Если ПрефиксДоверенности <> "" Тогда
		МассивПрефиксовДляОбхода.Добавить(ПрефиксДоверенности);
	КонецЕсли;
	
	
	Если НЕ МетаданныеДокумента = Неопределено Тогда
		Если    МетаданныеДокумента.Имя = "НалоговаяНакладная"  
			ИЛИ МетаданныеДокумента.Имя = "Приложение2КНалоговойНакладной" Тогда
			ТекМесяц = '20000101';
			Для Инд = 1 По 12 Цикл
				МассивПрефиксовДляОбхода.Добавить("Н"+ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				МассивПрефиксовДляОбхода.Добавить("П"+ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				ТекМесяц = ДобавитьМесяц(ТекМесяц, 1);
			КонецЦикла;
			ТекМесяц = '20000101';
			Для Инд = 1 По 12 Цикл
				МассивПрефиксовДляОбхода.Добавить(ПолучитьМесячныйПрефиксНалоговыхДокументов(ТекМесяц));
				ТекМесяц = ДобавитьМесяц(ТекМесяц, 1);
			КонецЦикла;
			МассивПрефиксовДляОбхода.Добавить("U");
			МассивПрефиксовДляОбхода.Добавить("V");
			МассивПрефиксовДляОбхода.Добавить("W");

		КонецЕсли;
	КонецЕсли;
	
	
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;

	Возврат Номер;

КонецФункции // ПолучитьНомерНаПечать()

// Заменяет одни термины, которые используются в коде, другими - уместными в интерфейсе.
// Позволяет иметь один тот же код при разных названиях объектов.
//
// Параметры
//  СтрокаИзИнтерфейса - строка - заголовок колонки, надпись и т.п.
//
// Возвращаемое значение:
//  Строка - новый заголовок колонки, надпись и т.п. 
//
Функция ПреобразоватьСтрокуИнтерфейса(СтрокаИзИнтерфейса) Экспорт 

	Возврат СтрокаИзИнтерфейса

КонецФункции // ПреобразоватьСтрокуИнтерфейса()

// Возвращает головную организацию для заданной организации
// Если для организации реквизит ГоловнаяОрганизация не заполнен 
// это значит, что сама организация является голвной
//
// Параметры
//  Организация – СправочникСсылка.Организации
//                 <продолжение описания параметра>
//
// Возвращаемое значение:
//   СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ГоловнаяОрганизация
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	Если Не Выборка.Следующий() Тогда
		Возврат Справочники.Организации.ПустаяСсылка()
	КонецЕсли;
	Если Организация.Пустая() или Выборка.ГоловнаяОрганизация.Пустая() Тогда
		Возврат Организация;
	Иначе
		Возврат Выборка.ГоловнаяОрганизация;
	КонецЕсли;
КонецФункции // ГоловнаяОрганизация()

Функция ЭтоЮрЛицо(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	Организации.ЮрФизЛицо
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	Выборка = Запрос.Выполнить().Выбрать();
	Возврат Не Выборка.Следующий() Или Выборка.ЮрФизЛицо <> Перечисления.ЮрФизЛицо.ФизЛицо;
	
КонецФункции // ЭтоЮрЛицо()

Функция ЭтоДоступнаяОрганизация(Организация) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Организация",Организация);
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.ПометкаУдаления
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.Ссылка = &Организация";
	
	Возврат Не Запрос.Выполнить().Пустой() // если удалось прочитать закрытое поле - организация доступна
	
КонецФункции // ЭтоДоступнаяОрганизация()

///////////////////////////////////////////////////////////////////////////////
// РАБОТА С ПЕРЕЧИСЛЕНИЕМ "ПЕРИОДИЧНОСТЬ"
// Функции не обрабатывают значения "Декада" и "Полугодие"

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
		Возврат '00010101';
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
							
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
		
КонецФункции // ДатаКонцаПериода()

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт

	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = ДатаПериода + Смещение*7*24*3600;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;

	Возврат НоваяДатаПериода;

КонецФункции // ДобавитьИнтервал()

// Возвращает число дней в переданном периоде
//
// Параметры
//  Периодичность – Перечисление.Периодичность элемент перечисления, 
//		для которого вычисляется количество дней
//
// Возвращаемое значение:
//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
//
Функция ЧислоДнейВПериоде(Периодичность) Экспорт
		
	Если Периодичность=Перечисления.Периодичность.День Тогда
		ЧислоДнейВПериоде=1;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		ЧислоДнейВПериоде=7;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		ЧислоДнейВПериоде=30;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		ЧислоДнейВПериоде=90;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		ЧислоДнейВПериоде=365;
	Иначе
		ЧислоДнейВПериоде=0;
	КонецЕсли;
	
	Возврат ЧислоДнейВПериоде;	

КонецФункции // ЧислоДнейВПериоде()

////////////////////////////////////////////////////////////////////////////////
// КОММЕНТАРИИ РАСЧЕТОВ

Функция КомментарийРасчета(	ТекстСообщения, 
							РодительскаяСтрока = НеОпределено,
							ПредставлениеРасшифровкиКомментария = НеОпределено, 
							РасшифровкаКомментария = НеОпределено, 
							ВидСообщения = НеОпределено,
							РаскрытьКомментарий = Истина) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Если ВидСообщения = НеОпределено Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Информация;
		КонецЕсли;
		Если РасшифровкаКомментария <> НеОпределено Тогда
			Расшифровки = Новый Массив;
			// расшифровка сообщений представляет собой массив структур "Представление+Расшифровка"
			Расшифровки.Добавить(Новый Структура("Представление,Расшифровка", ПредставлениеРасшифровкиКомментария, РасшифровкаКомментария));
		Иначе
			Расшифровки = НеОпределено;
		КонецЕсли;
		Возврат Обработка.ДобавитьСообщение(
								ТекстСообщения, 
								ВидСообщения, 
								Расшифровки, 
								РодительскаяСтрока, 
								РаскрытьКомментарий);
	#Иначе
		Сообщить(ТекстСообщения);
	#КонецЕсли
	
КонецФункции

Процедура ОшибкаРасчета(ТекстОшибки) Экспорт
	
	#Если Клиент Тогда
		Обработка = глЗначениеПеременной("глОбработкаСообщений");
		Обработка.ДобавитьСообщение(ТекстОшибки, Перечисления.ВидыСообщений.Ошибка);
	#Иначе
		Сообщить(ТекстОшибки, СтатусСообщения.Важное);
	#КонецЕсли
КонецПроцедуры

// Формирует список обособленных структурных подразделений организации
Функция ПолучитьСписокОбособленныхПодразделенийОрганизации(Организация) Экспорт

	Запрос = Новый Запрос(
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка,
	|	Организации.Наименование
	|ИЗ
	|	Справочник.Организации КАК Организации
	|ГДЕ
	|	Организации.ГоловнаяОрганизация = &Организация");

	Запрос.УстановитьПараметр("Организация", Организация);

	СписокОрганизаций = Новый СписокЗначений;
	
	Выборка = Запрос.Выполнить().Выбрать(); 

	Пока Выборка.Следующий() Цикл
		СписокОрганизаций.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;

	Возврат СписокОрганизаций;
КонецФункции // ПолучитьСписокОбособленныхПодразделенийОрганизации()

//Удалает повторяющиеся элементы массива.
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь, УдалитьПустыеЭлементыСсылочногоТипа = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМасссиве = Новый Соответствие; 
		БылоНеопределено = Ложь;
		
		КолвоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КолвоЭлементовВМассиве Цикл 
			ЭлементМассива = Массив[КолвоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента = ТипЗнч(ЭлементМассива); 
			Если ЭлементМассива = Неопределено Тогда
				Если БылоНеопределено или НеИспользоватьНеопределено Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				Продолжить;
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
				ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				Если УдалитьПустыеЭлементыСсылочногоТипа
					И НЕ ЗначениеЗаполнено(ЭлементМассива)
					Тогда
					Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
					Продолжить;
				КонецЕсли;
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМасссиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КолвоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМасссиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧИЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Получает первичную информацию об ошибке
// Параметры:
//	ИнформацияОбОшибке - информация об ошибке
// Возвращает:
//	Информацию об ошибке, которая является первопричиной возникновения переданной ИнформацияОбОшибке
//  Если ошибка первичная, то возвращается сама ошибка, переданная в качестве параметра
Функция ПолучитьПричинуОшибки(ИнформацияОбОшибке) Экспорт
	ПричинаОшибки = ИнформацияОбОшибке.Причина;
	Если ПричинаОшибки = НеОпределено Тогда
		Возврат ИнформацияОбОшибке;
	КонецЕсли;
	Пока ПричинаОшибки.Причина <> НеОпределено Цикл
		ПричинаОшибки = ПричинаОшибки.Причина;
	КонецЦикла;
	Возврат ПричинаОшибки;
	
КонецФункции

// Возвращает выборку со значениями реквизитов переданной ссылки
//
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	" + ИменаРеквизитов + "
	|ИЗ
	|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Получить значение одного реквизита по ссылке.
// Например, для элемента справочника нужно получить наименование,
// в этом случае в качестве ИмяРеквизита нужно передать "Наименование".
//
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции

// Процедура устанавливает номер документа.
//
// Параметры:
//  ДокументОбъект  - ДокументОбъект. Экземпляр документа, которому 
//                    необходимо присвоить новый номер
//
Процедура УстановитьНомерДокумента(ДокументОбъект) Экспорт

	// Если  нет реквизита "Организация" или для нее не задан префикс, то 
	// используем пустой префикс,
	// иначе используем префикс организации.
	МетаданныеДокумента = ДокументОбъект.Метаданные();

	Если Не МетаданныеДокумента.Реквизиты.Найти("Организация") <> Неопределено
	 Или НЕ ЗначениеЗаполнено(ДокументОбъект.Организация.Префикс) Тогда

		ДокументОбъект.УстановитьНовыйНомер("00");

	Иначе

		ДокументОбъект.УстановитьНовыйНомер(ДокументОбъект.Организация.Префикс);

	КонецЕсли;

КонецПроцедуры // УстановитьНомерДокумента()

 

#Если Клиент Тогда
	
// Процедура возвращает паспортные данные физлица в виде строки
//
// Параметры: 
//  ФизЛицо - ссылка на элемент справочника "Физические лица",по которму необходимо
//            получить паспортные данные.
//
// Возвращаемое значение:
//  Строка с данными об удостоверении личности физичского лица
//
Функция ПолучитьПаспорныеДанныеСтрокой(ФизЛицо) Экспорт

	СтруктураПаспортныхДанных	= РегистрыСведений.ПаспортныеДанныеФизЛиц.ПолучитьПоследнее(РабочаяДата, Новый Структура("ФизЛицо",ФизЛицо));
	ВидДокумента				= СтруктураПаспортныхДанных.ДокументВид;
	Серия						= СтруктураПаспортныхДанных.ДокументСерия;
	Номер						= СтруктураПаспортныхДанных.ДокументНомер;
	ДатаВыдачи					= СтруктураПаспортныхДанных.ДокументДатаВыдачи;
	КемВыдан					= СтруктураПаспортныхДанных.ДокументКемВыдан;

	Если НЕ (НЕ ЗначениеЗаполнено(ДатаВыдачи)
		   И НЕ ЗначениеЗаполнено(ВидДокумента)
		   И НЕ ЗначениеЗаполнено(Серия + Номер + КемВыдан)) Тогда

		Возврат ?(ВидДокумента.Пустая(),"","" + ВидДокумента + ", ") 
				+ "Серия: " + Серия + ", № " + Номер 
				+ ", Выдан: " + Формат(ДатаВыдачи,"ДФ='дд ММММ гггг'") + " года, " 
				+ КемВыдан;

	Иначе
		Возврат "Отсутствуют данные об удостоверении личности."
	КонецЕсли;

КонецФункции // ПолучитьПаспорныеДанныеСтрокой()

#КонецЕсли

// Преобразовывает число, строку (числовую) в число, Истина в 1, Ложь в 0, остальные значения (Null, Неопределено, другие значения) в 0 
//
// Параметры:
//	Значение - Значение, которое необходимо преобразовать в число
//
// Возвращаемое значение:
// Число, полученное в результате преобразования
//
Функция ПреобразоватьВЧисло(Значение) Экспорт
	
	Если (Значение = Null) или (Значение = Неопределено) Тогда
		Возврат 0;
	Иначе
		Попытка
			Возврат Число(Значение);
		Исключение
			Возврат 0;
		КонецПопытки
	КонецЕсли;
	
КонецФункции // ПреобразоватьВЧисло()

Функция РазложитьЧислоВСтроку(Значение,Длина,ЛидирующиеНули=Ложь) Экспорт
	
	ФорматнаяСтрока = "ЧЦ="+Строка(Длина)+"; ЧДЦ=0; ЧГ=0";
	Если ЛидирующиеНули Тогда
		Строка0 = "0";
		Для Сч = 2 по Длина Цикл
			Строка0 = Строка0+"0";
		Конеццикла;
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН="+Строка0+"; ЧВН=";
	Иначе
		ФорматнаяСтрока = ФорматнаяСтрока + "; ЧН=0";
	КонецЕсли;
	
	Результат = Формат(Значение,ФорматнаяСтрока);
	
	Если НЕ ЛидирующиеНули Тогда
		
		Пока СтрДлина(Результат) < Длина Цикл
			Результат = " "+Результат;
		КонецЦикла;	
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


// Выводит информационное сообщение
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) Экспорт

	#Если Клиент Тогда
		
		Если Статус = Неопределено Тогда
			Статус = СтатусСообщения.Информация;
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			Сообщить(Заголовок);
			Заголовок = "";
		КонецЕсли;
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

// Выводит служебное информационное сообщение, если глЗначениеПеременной("ВыводитьСлужебнуюИнформацию") = Истина
// Предназначена для выдачи различных отладочных сообщений 
// Для установки глобальной переменной "ВыводитьСлужебнуюИнформацию" в Истина запускаем с параметром запуска "test"
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - строка, заголовок.
//  Статус         - СтатусСообщения
//
Процедура СообщитьСлужебнуюИнформацию(ТекстСообщения, Заголовок = "", Статус = Неопределено) Экспорт
	
	#Если Клиент Тогда
		
		Если глЗначениеПеременной("ВыводитьСлужебнуюИнформацию") = Истина Тогда
			СообщитьИнформацию(ТекстСообщения, Заголовок, Статус);
		КонецЕсли;
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьИнформацию()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СЧЕТАМИ И СУБКОНТО

// Устанавливает субконто "Склады" у указанного счета.
//
Процедура УстановитьСубконтоСкладыНаСчете(ИмяПланаСчетов, ВидСубконто, ИмяСчета, ВестиУчетПоСкладам = Ложь, СоздаватьВидСубконтоСклады = Истина)

	Попытка

		Счет              = ПланыСчетов[ИмяПланаСчетов][ИмяСчета];
		Объект            = Счет.ПолучитьОбъект();
		ВидСубконтоСклады = Объект.ВидыСубконто.Найти(ПланыВидовХарактеристик[ВидСубконто].Склады, "ВидСубконто");

		Если ВидСубконтоСклады = Неопределено Тогда
			
			Если НЕ СоздаватьВидСубконтоСклады Тогда
				Возврат;	
			КонецЕсли; 
			
			НовыйВид = Объект.ВидыСубконто.Добавить();

			НовыйВид.ВидСубконто    = ПланыВидовХарактеристик[ВидСубконто].Склады;
			НовыйВид.Количественный = Истина;
			НовыйВид.Суммовой       = ВестиУчетПоСкладам;

			Объект.Записать();
			#Если Клиент Тогда
				Состояние("Добавлен вид субконто ""Склады"" на счете " + Объект.Код + " плана счетов """ + ИмяПланаСчетов + """...");
			#КонецЕсли
			
		Иначе
			
			ВидСубконтоСклады.Суммовой = ВестиУчетПоСкладам;
			
			Объект.Записать();
			#Если Клиент Тогда
				Состояние("Обновление значений реквизитов субконто плана счетов """ + ИмяПланаСчетов + """...");
            #КонецЕсли
				
		КонецЕсли;

	Исключение
		#Если Клиент Тогда
			Состояние("В плане счетов """ + ИмяПланаСчетов + """ не определен счет " + ИмяСчета);
        #КонецЕсли
			
	КонецПопытки;

КонецПроцедуры // УстановитьСубконтоСкладыНаСчете()

// Устанавливает субконто "Склады" в счетах.
//
Процедура УстановитьСубконтоСкладыНаСчетах(ВестиУчетПоСкладам = Ложь, СоздаватьВидСубконтоСклады = Истина) Экспорт

	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "АктивыНаОтветственномХранении"                   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ОборудованиеПринятоеДляМонтажа"                  , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МатериалыПринятыеВПереработкуВсего"              , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МатериалыПринятыеВПереработку"                   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МатериалыПринятыеВПереработкуВПроизводстве"      , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МатериальныеЦенностиНаОтветственномХранении"     , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТоварыПринятыеНаКомиссиюВсего"                   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТоварыПринятыеНаКомиссию"                        , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ИмуществоВДоверительномУправлении"               , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ПриобретениеОсновныхСредств"                     , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ПриобретениеДругихНеоборотныхМатериальныхАктивов", ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ПроизводственныеЗапасы"                          , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "СырьеИМатериалы"                                 , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ПокупныеПолуфабрикатыИКомплектующиеИзделия"      , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "Топливо"                                         , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТараИТарныеМатериалы"                            , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "СтроительныеМатериалы"                           , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ЗапасныеЧасти"                                   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МатериалыСельскохозяйственногоНазначения"        , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ДругиеМатериалы"                                 , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "МалоценныеИБыстроизнашивающиесяПредметыНаСкладе" , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "Полуфабрикаты"                                   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ГотоваяПродукция"                                , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ПродукцияСельскохозяйственногоПроизводства"      , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТоварыНаСкладе"                                  , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТоварыВТорговле"                                 , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Хозрасчетный", "ВидыСубконтоХозрасчетные", "ТараПодТоварами"                                 , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "СырьеИМатериалы"            , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "СырьеИОсновныеМатериалы"    , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "Топливо"                    , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ТараИТарныеМатериалы" 	   , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ЗапасныеЧасти"              , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ПрочиеМатериалы"            , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "СтроительныеМатериалы"      , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ТоварыНаСкладе"             , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ТоварыВРознице"             , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "ГотоваяПродукция"           , ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "КомплектующиеИПолуфабрикаты", ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);
	УстановитьСубконтоСкладыНаСчете("Международный", "ВидыСубконтоМеждународные", "МалоценныеИБыстроизнашивающиесяПредметыНаСкладе", ВестиУчетПоСкладам, СоздаватьВидСубконтоСклады);

КонецПроцедуры // УстановитьСубконтоСкладыНаСчетах()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ ПОГРЕШНОСТЕЙ ОКРУГЛЕНИЯ

// Выполняет округление числовых значений с накоплением погрешностей округления, образовавшихся
//		в результате предыдущих вызовов функции
//
// Параметры
//  Число 		– Число. Округляемое значение
//  Точность	– Число. Точность округления
//	Погрешность	- Число. Переменная, в которой накапливается погрешность с предыдущих вызовов
//
// Возвращаемое значение:
//   Число   – округленное значение
//
Функция ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность = 0, 
	               СоответствиеПогрешностей = Неопределено, Ключ = Неопределено) Экспорт

	Если НЕ СоответствиеПогрешностей = Неопределено И ЗначениеЗаполнено(Ключ) Тогда
	
		// считываем погрешность округления, накопленную ранее при расчетах
		Погрешность = СоответствиеПогрешностей[Ключ];
		// погрешности округления еще нет -- первая сумма
		Если Погрешность = Неопределено Тогда
			Погрешность = 0;
		КонецЕсли;
		// округлим с учетом погрешности
		Округленное = ОкруглитьСУчетомПогрешности(Число, Точность, Погрешность);
		// сохраним погрешность округления
		СоответствиеПогрешностей.Вставить(Ключ, Погрешность);
	
	Иначе
		
		Если Число = 0 Тогда
			Возврат 0;
		КонецЕсли; 
	
		// выравнивание разрядности
		Число = Окр(Число, 27, ?(Число<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// сумма с учетом погрешности предыдущих вычислений
		Округляемое = Число + Погрешность;

		// для отрицательного числа меняем направление округления, чтобы избежать ошибки Окр(-0.5) = -1
		Округленное	= Окр(Округляемое, Точность, ?(Округляемое<0, РежимОкругления.Окр15как10, РежимОкругления.Окр15как20));
		
		// рассчитаем новую погрешность округления
		Погрешность	= Округляемое - Округленное;
		
	КонецЕсли;
	
	Возврат Округленное;

КонецФункции // ОкруглитьСУчетомПогрешности()

#Если Клиент Тогда
	
// Показывает таблицу значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьТаблицуЗначений(ТЗ, Заголовок = "") Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьТаблицуЗначений(ТЗ, Заголовок);
КонецПроцедуры // ПоказатьТаблицуЗначений(ТЗ)

// Показывает дерево значений в отдельной форме, в немодальном окне
//
// Параметры
//  ТЗ  – ТаблицаЗначений – Таблица значений, которую необходимо показать
//
Процедура ПоказатьДеревоЗначений(ДЗ, Заголовок = "") Экспорт
	Обработки.ПросмотрТаблицыЗначений.Создать().ПоказатьДеревоЗначений(ДЗ, Заголовок);
КонецПроцедуры // ПоказатьДеревоЗначений(ТЗ)

#КонецЕсли

// Функция формирует представление периода по дате начала и дате окончания.
//
// Параметры
//  ДатаНачала	   – Дата – дата начала периода.
//  ДатаОкончания  – Дата – дата окончания периода.
//  МесяцКратко  - когда Истина, месяц выводится первыми тремя символами
//  СДатами	   – Булево – признак того, что описание периода будет сформирован 
//					 без указания чисел месяца.
//  ГодКратко - когда Истина, год выводится 2-мя знаками
//
// Возвращаемое значение:
//   Строка   – строковое представление периода.
//
Функция ОписаниеПериода(ДатаНачала, ДатаОкончания, МесяцКратко = Истина, СДатами = Истина, ГодКратко = Истина) Экспорт
	
	ЧислоНачала		= День(ДатаНачала);
	ЧислоОкончания	= День(ДатаОкончания);
	
	ФорматГода = ?(ГодКратко, "ДФ = 'гг'", "ДФ = 'гггг'");
	
	Если МесяцКратко Тогда
		ОписаниеМесяцаГода = Лев(Формат(ДатаНачала,   "ДФ = 'MMMM'"),3) + " " + Формат(ДатаНачала,    ФорматГода);
		ОписаниеМесяца2    = Лев(Формат(ДатаОкончания,"ДФ = 'MMMM'"),3) + " " + Формат(ДатаОкончания, ФорматГода);
	Иначе
		Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
		ОписаниеМесяцаГода = Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		Месяц	= Формат(ДатаОкончания, "ДФ=MMMM");
		ОписаниеМесяца2    = Месяц + " " + Формат(ДатаОкончания, ФорматГода);
	КонецЕсли;
	
	Если Месяц(ДатаНачала) <> Месяц(ДатаОкончания) Тогда  
		
		Если (ДатаНачала = НачалоМесяца(ДатаНачала)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
			Перваяполовинадат = Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		Иначе
			Перваяполовинадат = "" + ЧислоНачала + " " + ОписаниеМесяцаГода; 
		КонецЕсли;
		
		Если (ДатаОкончания = КонецМесяца(ДатаОкончания)) Или Не СДатами Тогда
			Месяц	= Формат(ДатаОкончания, "ДФ=MMMM");
			ВтораяПоловинаДат = Месяц + " " + Формат(ДатаОкончания,    ФорматГода);
		Иначе
			ВтораяПоловинаДат = "" + ЧислоОкончания + " " + ОписаниеМесяца2;
		КонецЕсли;
		
		Возврат Перваяполовинадат + "-" + ВтораяПоловинаДат;
		
	Иначе
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) И ДатаОкончания + 86399 = КонецМесяца(ДатаОкончания) Или Не СДатами Тогда
			Месяц	= Формат(ДатаНачала, "ДФ=MMMM");
			Возврат Месяц + " " + Формат(ДатаНачала,    ФорматГода);
		ИначеЕсли ЧислоНачала = ЧислоОкончания Тогда
			Возврат "" + ЧислоНачала + " " + ОписаниеМесяцаГода;
		Иначе
			Возврат "" + ЧислоНачала + "-" + ЧислоОкончания + " " + ОписаниеМесяцаГода;
		КонецЕсли;
		
	КонецЕсли;
	
КонецФункции	// ОписаниеПериода 

// Удаляет субконто "Склады" у указанного счета.
//
Процедура УдалитьСубконтоСкладыНаСчете(ИмяПланаСчетов, ВидСубконто, ИмяСчета) Экспорт

	Попытка

		Счет              = ПланыСчетов[ИмяПланаСчетов][ИмяСчета];
		Объект            = Счет.ПолучитьОбъект();
		ВидСубконтоСклады = Объект.ВидыСубконто.Найти(ПланыВидовХарактеристик[ВидСубконто].Склады, "ВидСубконто");

		Если ВидСубконтоСклады <> Неопределено Тогда
			
			Объект.ВидыСубконто.Удалить(ВидСубконтоСклады);
			
			Объект.Записать();
			#Если Клиент Тогда
				Состояние("Удален вид субконто ""Склады"" на счете " + Объект.Код + " плана счетов """ + ИмяПланаСчетов + """...");
			#КонецЕсли
			
		КонецЕсли;

	Исключение
		#Если Клиент Тогда
			Состояние("В плане счетов """ + ИмяПланаСчетов + """ не определен счет " + ИмяСчета);
        #КонецЕсли
			
	КонецПопытки;

КонецПроцедуры // УдалитьСубконтоСкладыНаСчете()


Функция ИспользоватьРегистрТоварыОрганизацийРегл(ДатаДок) Экспорт 
	
	Если НЕ глЗначениеПеременной("ИспользоватьРегистрТоварыОрганизацийРегл") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если глЗначениеПеременной("ДатаНачалаИспользованияРегистраТоварыОрганизацийРегл") > ДатаДок Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции // ИспользоватьРегистрТоварыОрганизацийРегл()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБСЛУЖИВАНИЯ ОБЪЕКТОВ, НЕ ПОДДЕРЖИВАЕМЫХ В КОНФИГУРАЦИИ
//

// Выводит сообщение о том, что объект не используется в конфигурации
//
Процедура СообщитьОбъектНеИспользуется(МетаданныеОбъекта = Неопределено, Отказ = Истина, СтандартнаяОбработка = Ложь) Экспорт
	
	Перем ТипОбъекта;
	
	ТипОбъекта = "Объект";
	Если МетаданныеОбъекта <> Неопределено Тогда
		ПолноеИмяОбъекта = МетаданныеОбъекта.ПолноеИмя();
		ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
		Если ПозицияТочки <> 0 Тогда
			ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки-1);
		КонецЕсли;
	КонецЕсли;
	
	ОбщегоНазначения.СообщитьОбОшибке(ТипОбъекта+" не используется в конфигурации """ + Метаданные.Синоним + """", Отказ);
	СтандартнаяОбработка = Ложь;
	
КонецПроцедуры
//Коновалова 13,11,2012 +
Процедура ПроведениеЗаказовПокупателейОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт

	Если не Отказ ТОгда
		РН_ЗаказыПокуптелей = Источник.Движения.ЗаказыПокупателей;
		Для каждого стр из РН_ЗаказыПокуптелей Цикл
			стр.Подразделение = Источник.Подразделение;
		КонецЦикла;
		Источник.Движения.ЗаказыПокупателей.Записать();
	КонецЕсли;
	
КонецПроцедуры

Процедура ПроверкаНаСуммуЗаказаПокупателяОбработкаПроведения(Источник, Отказ, РежимПроведения) Экспорт
	Если не Отказ Тогда
		Если Источник.ВидОперации = Перечисления.ВидыОперацийЗаказПокупателя.ПродажаКомиссия ТОгда
				//ИЗМЕНЕНО Верескул Игорь(Начало 27.06.2014
			Если Источник.ВалютаДокумента = Константы.ВалютаРегламентированногоУчета.Получить() и 
				Источник.СуммаДокумента <= Константы.СуммаОграниченияДляЗаказаПокупателя.Получить() и
				Источник.Дата >=  '20121115000000' и НЕ Источник.РазрешитьПревышениеПорога Тогда
				//Окончание)Верескул Игорь 
				Источник.Записать(РежимЗаписиДокумента.ОтменаПроведения);
				Сообщить("Документ, сумма которого меньше или равна " + Константы.СуммаОграниченияДляЗаказаПокупателя.Получить() 
				+ " может быть только записан в систему (без проведения)");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры
//Коновалова 13,11,2012 -

//Коновалова 24012013 +
Функция ПроверкаПоДоступностиСтатейЗатрат(Подразделение_,Статья_) Экспорт
	
	Если Найти(Подразделение_.ПолныйКод(),Статья_.ПОдразделение.Код)<>0 ТОгда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

//Коновалова 24012013 -

Процедура ПриЗаписиНоменклатурыИЕдиниц(Источник, Отказ) Экспорт
	Если ТипЗнч(Источник) = Тип("СправочникОбъект.Номенклатура") Тогда
		ТекНоменклатура = Источник;
	Иначе
		ТекНоменклатура = Источник.Владелец;
	КонецЕсли;
	
	Если ТипЗнч(ТекНоменклатура) = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
		Возврат;
	КонецЕсли;
	
	ВидНоменклатурыПродукция = Справочники.ВидыНоменклатуры.НайтиПоКоду("000000003");
	Если ВидНоменклатурыПродукция = Справочники.ВидыНоменклатуры.ПустаяСсылка() Тогда
		Сообщить("Не удалось найти вид номеклатуры ""Продукция"" по коду ""000000003""");
		Возврат;
	ИначеЕсли СокрЛП(ВидНоменклатурыПродукция.Наименование) <> "Продукция" Тогда
		Сообщить("Вид номеклатуры по коду ""000000003"" должен быть ""Продукция""");
		Возврат;
	КонецЕсли;
	
	ЕХО = Справочники.КлассификаторЕдиницИзмерения.НайтиПоКоду("796"); //шт
	Если ЕХО = Справочники.КлассификаторЕдиницИзмерения.ПустаяСсылка() Тогда
		Сообщить("В справочнике ""Классификатор единиц измерения"" не удалось найти единицу ""шт"" по коду ""796""");
		Возврат;
	ИначеЕсли СокрЛП(ЕХО.Наименование) <> "шт" Тогда
		Сообщить("В справочнике ""Классификатор единиц измерения"" наименование единицы с кодом ""796"" отличается от ""шт""");
		Возврат;
	КонецЕсли;
	
	ЕДО = Справочники.КлассификаторЕдиницИзмерения.НайтиПоКоду("813"); //литр
	Если ЕДО = Справочники.КлассификаторЕдиницИзмерения.ПустаяСсылка() Тогда
		Сообщить("В справочнике ""Классификатор единиц измерения"" не удалось найти единицу ""литр"" по коду ""813""");
		Возврат;
	ИначеЕсли СокрЛП(ЕДО.Наименование) <> "литр"  Тогда
		Если СокрЛП(ЕДО.Наименование) <> "літр" Тогда
			Сообщить("В справочнике ""Классификатор единиц измерения"" наименование единицы с кодом ""813"" отличается от ""литр"" или ""літр""");
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Если ТекНоменклатура.ВидНоменклатуры = ВидНоменклатурыПродукция
		И ТекНоменклатура.ЕдиницаХраненияОстатков.ЕдиницаПоКлассификатору = ЕХО
		И ТекНоменклатура.ЕдиницаДляОтчетов.ЕдиницаПоКлассификатору = ЕДО Тогда
		
		СпособРаспределения = Справочники.СпособыРаспределенияЗатратНаВыпуск.ПоОбъемуВыпуска.ПолучитьОбъект();
		СпособРаспределенияИзменен = Ложь;
		Если НЕ СпособРаспределения.ТипФильтраПриРаспределенииЗатратНаВыпуск = Перечисления.ТипыФильтровПриРаспределенииЗатратНаВыпуск.Продукция Тогда
			СпособРаспределения.ТипФильтраПриРаспределенииЗатратНаВыпуск = Перечисления.ТипыФильтровПриРаспределенииЗатратНаВыпуск.Продукция;
			СпособРаспределенияИзменен = Истина;
		КонецЕсли;
		
		НайденнаяСтрока = СпособРаспределения.Фильтры.Найти(ТекНоменклатура.Ссылка, "Продукция");
		Если НайденнаяСтрока = Неопределено Тогда
			ТекСтрока = СпособРаспределения.Фильтры.Добавить();
			ТекСтрока.Продукция = ТекНоменклатура.Ссылка;
		Иначе
			ТекСтрока = НайденнаяСтрока;
		КонецЕсли;
		
		КоэффициентЕХО = ТекНоменклатура.ЕдиницаХраненияОстатков.Коэффициент;
		КоэффициентЕДО = ТекНоменклатура.ЕдиницаДляОтчетов.Коэффициент;
		
		НулевойКоэф = Ложь;
		Если КоэффициентЕХО = 0 Тогда
			Сообщить("Не удалось установить коэффициент для способа распределения затрат, так как у номенклатуры """ + СокрЛП(ТекНоменклатура.Наименование) + """ коэффициент единицы хранения остатков равен нулю");
			НулевойКоэф = Истина;
		КонецЕсли;
		Если КоэффициентЕДО = 0 Тогда
			Сообщить("Не удалось установить коэффициент для способа распределения затрат, так как у номенклатуры """ + СокрЛП(ТекНоменклатура.Наименование) + """ коэффициент единицы для отчетов равен нулю");
			НулевойКоэф = Истина;
		КонецЕсли;
		
		Если НЕ НулевойКоэф Тогда
			ТекКоэф = Окр(КоэффициентЕХО / КоэффициентЕДО, 3);
			Если ТекСтрока.Коэффициент <> ТекКоэф Тогда
				ТекСтрока.Коэффициент = ТекКоэф;
				СпособРаспределенияИзменен = Истина;
			КонецЕсли;
		КонецЕсли;
		
		Если СпособРаспределенияИзменен Тогда
			СпособРаспределения.Записать();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры


Функция ЕстьЗапрещенныеСимволыИмени(ИмяФайла) Экспорт

	Если Найти(ИмяФайла,  "/") > 0
	 ИЛИ Найти(ИмяФайла,  ":") > 0
	 ИЛИ Найти(ИмяФайла,  "*") > 0
	 ИЛИ Найти(ИмяФайла,  "&") > 0
	 ИЛИ Найти(ИмяФайла, """") > 0
	 ИЛИ Найти(ИмяФайла,  "<") > 0
	 ИЛИ Найти(ИмяФайла,  ">") > 0
	 ИЛИ Найти(ИмяФайла,  "|") > 0 
     ИЛИ Найти(ИмяФайла,  ",") > 0 
     Тогда
     
		Возврат Истина;
	Иначе            
		Возврат Ложь;
	КонецЕсли;

КонецФункции

Процедура ОбработкаОтчетаПоГруппеА(НастройкаКомпоновкиДанных)Экспорт
	Флаг1 = Ложь;
	Флаг2 = Ложь;
	Для каждого Элемент Из НастройкаКомпоновкиДанных.ПараметрыДанных.Элементы Цикл
		Если Элемент.Параметр = Новый ПараметрКомпоновкиДанных("КонецПериода") Тогда
			Если НЕ Флаг1 Тогда
				КП1	= Элемент; 	
				Флаг1 = Истина;	
			Иначе
				КП2 = Элемент;
			КонецЕсли; 
			
		КонецЕсли; 	
		Если Элемент.Параметр = Новый ПараметрКомпоновкиДанных("НачалоПериода") Тогда
			Если НЕ Флаг2 Тогда
				НП1	= Элемент; 	
				Флаг2 = Истина;	
			Иначе
				НП2 = Элемент;
			КонецЕсли; 
		КонецЕсли; 	
	КонецЦикла; 
	Если НП1.Значение < ПараметрыСеанса.КонтрольнаяДатаОграничения 
		И КП1.Значение < ПараметрыСеанса.КонтрольнаяДатаОграничения Тогда
		НП1.Значение = Дата(2009,1,1,0,0,0);
		КП1.Значение = Дата(2009,1,1,0,0,0);
	Иначе
		Если НП1.Значение < ПараметрыСеанса.КонтрольнаяДатаОграничения Тогда
			НП1.Значение = НачалоДня(ПараметрыСеанса.КонтрольнаяДатаОграничения);
			Если ЗначениеЗаполнено(НП2) Тогда
				НП2.Значение = НачалоДня(ПараметрыСеанса.КонтрольнаяДатаОграничения);	
			КонецЕсли;					
			Если НП1.Значение > КП1.Значение Тогда
				КП1.Значение = НП1.Значение;
				Если ЗначениеЗаполнено(КП2) Тогда
					КП2.Значение = НП2.Значение;	
				КонецЕсли; 					
			КонецЕсли;					 
		КонецЕсли; 
	КонецЕсли;
КонецПроцедуры
