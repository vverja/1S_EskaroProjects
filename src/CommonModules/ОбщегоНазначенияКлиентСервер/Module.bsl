////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Функция формирует текст в формате, необходимом для выдачи сообщений по табличной части.
//
// Параметры:
//  ИмяТЧ - Строка. Имя табличной части.
//  НомерСтроки - Число. Номер строки табличной части.
//  ИмяРеквизита - Строка. Имя реквизита.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ(ИмяТЧ, НомерСтроки, ИмяРеквизита) Экспорт

	Возврат ИмяТЧ + "[" + Формат(НомерСтроки - 1, "ЧН=0; ЧГ=0") + "]." + ИмяРеквизита;

КонецФункции // ПолучитьТекстДляВыдачиСообщенийПоСтрокеТЧ()
////////////////////////////////////////////////////////////////////////////////
// Клиентские и серверные процедуры общего назначения

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
//	Параметры
//	ТекстСообщенияПользователю	- Строка - текст сообщения.
//	ОбъектИлиСсылка				- Произвольный - Объект, с которым должно быть связано сообщение
//	Поле						- Строка - наименование реквизита формы
//	ПутьКДанным					- Строка - путь к данным (путь к реквизиту формы)
//	Отказ						- Булево - Выходной параметр. 
//                                Устанавливается в этой процедуре в значение Истина.
//
//	Примеры использования:
//	1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ПолеВРеквизитеФормыОбъект",
//		"Объект");
//
//	Альтернативный вариант использования в форме объекта:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"Объект.ПолеВРеквизитеФормыОбъект");
//
//	2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"), ,
//		"ИмяРеквизитаФормы");
//
//	3. Для вывода сообщения из кода на сервере:
//	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//		НСтр("ru = 'Сообщение об ошибке.'"),СсылкаНаОбъект,,,Отказ);
//
Процедура СообщитьПользователю(	Знач ТекстСообщенияПользователю,
								Знач ОбъектИлиСсылка = Неопределено,
								Знач Поле = "",
								Знач ПутьКДанным = "",
								Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	Сообщение.ПутьКДанным = ПутьКДанным;
	
	Если ОбъектИлиСсылка <> Неопределено Тогда
		Сообщение.УстановитьДанные(ОбъектИлиСсылка);
	КонецЕсли;
	
	Сообщение.Сообщить();
	Отказ = Истина;
	
КонецПроцедуры

// Проверяет, что почтовый адрес не содержит символов обрамления
// если символы обрамления вставлены правильно убирает их
// Параметры:
//  ПолноеИмяАдресата - строка - имя получателя
//  ПочтовыйАдрес     - строка - email адрес
// Возвращаемое значение:
//  Структура:
//   Ключ статус - булево - успех или неуспех операции
//   СообщениеОбОшибке - в случае неуспеха операции содержит сообщение об ошибке
//   Значение - структура - в случае успеха операции содержит записанную структуру почтового
//                          адреса: ключи - Адрес, Представление (строки)
//
Функция ПроверитьИПодготовитьПочтовыйАдрес(знач ПолноеИмяАдресата, знач ПочтовыйАдрес)
	
	СимволыОбрамления = "<>[]";
	
	ПочтовыйАдрес     = СокрЛП(ПочтовыйАдрес);
	ПолноеИмяАдресата = СокрЛП(ПолноеИмяАдресата);
	
	Если Лев(ПолноеИмяАдресата, 1) = "<" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = ">" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	ИначеЕсли Лев(ПолноеИмяАдресата, 1) = "[" Тогда
		Если Прав(ПолноеИмяАдресата, 1) = "]" Тогда
			ПолноеИмяАдресата = Сред(ПолноеИмяАдресата, 2, СтрДлина(ПолноеИмяАдресата)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в имени адресата.'");
		КонецЕсли;
	КонецЕсли;
	
	Если Лев(ПочтовыйАдрес, 1) = "<" Тогда
		Если Прав(ПочтовыйАдрес, 1) = ">" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	ИначеЕсли Лев(ПочтовыйАдрес, 1) = "[" Тогда
		Если Прав(ПочтовыйАдрес, 1) = "]" Тогда
			ПочтовыйАдрес = Сред(ПочтовыйАдрес, 2, СтрДлина(ПочтовыйАдрес)-2);
		Иначе
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЕсли;
	
	Для Индекс = 1 По СтрДлина(СимволыОбрамления) Цикл
		Если Найти(ПолноеИмяАдресата, Сред(СимволыОбрамления, Индекс, 1)) <> 0
		 Или Найти(ПочтовыйАдрес,     Сред(СимволыОбрамления, Индекс, 1)) <> 0 Тогда
			ВызватьИсключение НСтр("ru = 'Недопустимый символ в почтовом адресе.'");
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Адрес, Представление", ПочтовыйАдрес,ПолноеИмяАдресата);
	
КонецФункции

// Формирует структуру с ключами Статус (Истина) и Значение
//
Функция ЗаполнитьРезультат(знач Значение, знач Статус = Истина) Экспорт
	
	Если Статус Тогда
		Возврат Новый Структура("Статус, Значение", Истина, Значение);
	Иначе
		Возврат Новый Структура("Статус, СообщениеОбОшибке", Ложь, Значение);
	КонецЕсли;
	
КонецФункции

// Сдвигает маркер позиции пока встречается символ Символ
// возвращает номер позиции в строке, на которое установился маркер
//
Функция ПропуститьПробелы(знач Строка,
                          знач ТекущийИндекс,
                          знач ПропускаемыйСимвол)
	
	Результат = ТекущийИндекс;
	
	// убираем лишние пробелы если они есть
	Пока ТекущийИндекс < СтрДлина(Строка) Цикл
		Если Сред(Строка, ТекущийИндекс, 1) <> ПропускаемыйСимвол Тогда
			Возврат ТекущийИндекс;
		КонецЕсли;
		ТекущийИндекс = ТекущийИндекс + 1;
	КонецЦикла;
	
	Возврат ТекущийИндекс;
	
КонецФункции

//Процедуры подготовки исходных данных при проведении документов

//Обрабатывает таблицу значений: заполняет незаполненные колонки с НоменклатурнойГруппой и СтатьейЗатрат по данным других реквизитов
//Параметры:
//	ТаблицаДокумента - обрабатываемая таблица значений
//	СтруктураОбрабатываемыхКолонок - структура, содержит обрабатываемые колонки
//		Ключ - имя колонки которую необходимо заполнить
//		Значение - имя колонки, из которой необходимо взять значение для заполнения
Процедура ЗаполнитьНоменклатурнуюГруппуИСтатьюЗатратВТаблицеДокумента(ТаблицаДокумента, СтруктураОбрабатываемыхКолонок) Экспорт
	Возврат;
	Для Каждого СтрокаТаблицыЗначений ИЗ ТаблицаДокумента Цикл
		Для Каждого КолонкаТаблицы ИЗ СтруктураОбрабатываемыхКолонок Цикл
			//Колонка в текущей строке заполнена - не требуется ее заполнять
			Если ЗначениеЗаполнено(СтрокаТаблицыЗначений[КолонкаТаблицы.Ключ]) Тогда
				Продолжить;
			КонецЕсли;
			СтрокаТаблицыЗначений[КолонкаТаблицы.Ключ] = СтрокаТаблицыЗначений[КолонкаТаблицы.Значение];
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

//Обрабатывает таблицу значений: заполняет незаполненные счета учета НДС в строках таблиц счетом учета НДС из СтруктураШапкиДокумента 
//Параметры:
//	СтруктураШапкиДокумента - Структура шапки документа
//	ТаблицаДокумента - обрабатываемая таблица значений
Процедура ЗаполнитьСчетУчетаНДСВТаблицеДокумента(СтруктураШапкиДокумента, ТаблицаДокумента) Экспорт
	Для Каждого СтрокаТаблицыЗначений ИЗ ТаблицаДокумента Цикл
		Если НЕ ЗначениеЗаполнено(СтрокаТаблицыЗначений.СчетУчетаНДС) Тогда
			СтрокаТаблицыЗначений.СчетУчетаНДС = СтруктураШапкиДокумента.СчетУчетаНДС;
		КонецЕсли;	
	КонецЦикла;
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о счетах расчетов по умолчанию, если эти данные не заполнились из шапки документа
Процедура ДобавитьВСтруктуруШапкиСведенияОСчетахРасчетов(ДокументОбъект, СтруктураШапкиДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	//Получим структуру счетов учета расчетов: 
	//	ключ - имя реквизита шапки, значение - счет учета расчетов по умолчанию
	СтруктураСчетовУчетаРасчетов = ДокументОбъект.ЗаполнитьСтруктуруСчетовУчетаШапки();
	//Заполним недостающие свойства в структуре шапки документа 
	Для Каждого СчетУчетаРасчетов Из СтруктураСчетовУчетаРасчетов Цикл
		Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ]) Тогда
			СтруктураШапкиДокумента[СчетУчетаРасчетов.Ключ] = СчетУчетаРасчетов.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

//Процедура добавляет в СтруктуруШапкиДокумента сведения о подразделении организации, 
//Если в шапке документа «Подразделение организации» оказалось незаполненным, то соответствующее свойство структуры заполняется вычисленным по подразделению
//Если Подразделение организации не удалось определить по подразделению, то выдается ошибка
Процедура ДополнитьСтруктуруШапкиПодразделениемОрганизации(Заголовок, СтруктураШапкиДокумента, Отказ) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		СтруктураШапкиДокумента.ПодразделениеОрганизации = РаботаСДиалогамиСервер.ПодразделениеОрганизации(СтруктураШапкиДокумента.Подразделение, СтруктураШапкиДокумента.Организация);
	КонецЕсли;	
	
	Если НЕ ЗначениеЗаполнено(СтруктураШапкиДокумента.ПодразделениеОрганизации) Тогда
		ОбщегоНазначения.СообщитьОбОшибке(Нстр("ru = 'Не заполнено подразделение организации'"), Отказ, Заголовок);
	КонецЕсли;	
КонецПроцедуры//ДополнитьСтруктуруШапкиПодразделениемОрганизации()

//Процедура добавляет в ТаблицуДокумента сведения о подразделении организации, 
//Если в табличной части документа «Подразделение организации» оказалось незаполненным, то соответствующая колонка таблицы заполняется вычисленным значением по подразделению
//Окончательная проверка заполненности подразделения организации выполняется в модуле документа
Процедура ДополнитьТаблицуДокументаПодразделениемОрганизации(СтруктураШапкиДокумента, ТаблицаДокумента) Экспорт
	Если НЕ СтруктураШапкиДокумента.ОтражатьВБухгалтерскомУчете Тогда
		Возврат;
	КонецЕсли;	
	
	Если ТаблицаДокумента.Колонки.Найти("Подразделение") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "Подразделение";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизации";
	ИначеЕсли ТаблицаДокумента.Колонки.Найти("ПодразделениеПолучатель") <> Неопределено Тогда
		ИмяКолонкиПодразделение = "ПодразделениеПолучатель";
		ИмяКолонкиПодразделениеОрганизации = "ПодразделениеОрганизацииПолучатель";
	Иначе
		Возврат;//Нет колонки с подразделением
	КонецЕсли;	
	
	Для Каждого ТекущаяСтрока Из ТаблицаДокумента Цикл
		Если НЕ ЗначениеЗаполнено(ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации]) Тогда
			ТекущаяСтрока[ИмяКолонкиПодразделениеОрганизации] = РаботаСДиалогамиСервер.ПодразделениеОрганизации(ТекущаяСтрока[ИмяКолонкиПодразделение], СтруктураШапкиДокумента.Организация);
		КонецЕсли;	
	КонецЦикла;	
КонецПроцедуры

// Проверяет правильность заполнения шапки документа по структуре шапки документа.
// Если какой-то из реквизитов шапки, влияющий на проведение, не заполнен или
// заполнен не корректно, то выставляется флаг отказа в проведении.
// Проверяется также правильность заполнения реквизитов ссылочных полей документа.
// Проверка выполняется по объекту и по выборке из результата запроса по шапке.
//
// Параметры: 
//  ДокументОбъект             - объект проводимого документа, 
//  СтруктураОбязательныхПолей - структура, содержащая имена полей, которые собственно и надо проверить.
//  СтруктураШапкиДокумента    - структура шапки проводимого документа
//  Отказ                      - флаг отказа в проведении.
//  Заголовок                  - строка, заголовок сообщения об ошибке проведения.
//
Процедура ПроверитьЗаполнениеВычисляемыхРеквизитовШапки(ДокументОбъект, СтруктураОбязательныхПолей, СтруктураШапкиДокумента, Отказ, Заголовок) Экспорт
	
	МетаданныеРеквизиты = ДокументОбъект.Метаданные().Реквизиты;
	
	Для каждого КлючЗначение Из СтруктураОбязательныхПолей Цикл

		Значение = СтруктураШапкиДокумента[КлючЗначение.Ключ];
		Если НЕ ЗначениеЗаполнено(Значение) Тогда

			Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
				ПредставлениеРеквизита = МетаданныеРеквизиты[КлючЗначение.Ключ].Представление();
				СтрокаСообщения = "Не заполнен """ + СокрЛП(ПредставлениеРеквизита) + """";
			Иначе
				СтрокаСообщения = КлючЗначение.Значение;
			КонецЕсли;
			ОбщегоНазначения.СообщитьОбОшибке(СтрокаСообщения, Отказ, Заголовок);

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ПроверитьЗаполнениеШапкиДокумента()

// Снимает один элемент условного оформления, если это список значений.
// Параметры
// УсловноеОформление - условное оформление элемента формы
// ИдентификаторПользовательскойНастройки - строка - идентефикатор настройки
// Значение - значение, которое требуется удалить из списка оформления
//
Процедура СнятьУсловноеОформлениеСпискаЗначений(
						УсловноеОформление,
						знач ИдентификаторПользовательскойНастройки,
						знач Значение) Экспорт
	
	Для Каждого ЭлементУО Из УсловноеОформление.Элементы Цикл
		Если ЭлементУО.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки Тогда
			Если ЭлементУО.Отбор.Элементы.Количество() = 0 Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписокОтбора = ЭлементУО.Отбор.Элементы[0];
			Если ЭлементСписокОтбора.ПравоеЗначение = Неопределено Тогда
				Возврат;
			КонецЕсли;
			ЭлементСписка = ЭлементСписокОтбора.ПравоеЗначение.НайтиПоЗначению(Значение);
			Если ЭлементСписка <> Неопределено Тогда
				ЭлементСписокОтбора.ПравоеЗначение.Удалить(ЭлементСписка);
			КонецЕсли;
			ЭлементСписокОтбора.ПравоеЗначение = ЭлементСписокОтбора.ПравоеЗначение;
			Возврат;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры


// Удаляет отбор у отбора системы компоновки данных
//
// Пример использования:
//   УдалитьОтборУСписка(Список.Отбор, Новый ПолеКомпоновкиДанных("Куратор"));
//
Процедура УдалитьОтборУСписка(ОтборСКД, ЛевоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	
	МассивОтборов = Новый Массив;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			МассивОтборов.Добавить(ЭлементОтбора);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементОтбора Из МассивОтборов Цикл
		ЭлементыОтбора.Удалить(ЭлементОтбора);
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает отбор у отбора системы компоновки данных.
//
//  Пример использования:
//   ОбщегоНазначенияКлиентСервер.УстановитьОтборУСпискаНаРавенство(
//                   Список.Отбор,
//                   Новый ПолеКомпоновкиДанных("ИмяСвойства"),
//                   ЗначениеОтбора);
//
Процедура УстановитьОтборУСпискаНаРавенство(ОтборСКД,
                                            знач ЛевоеЗначение,
                                            знач ПравоеЗначение) Экспорт
	
	ЭлементыОтбора = ОтборСКД.Элементы;
	ЭлементОтбораДанных = Неопределено;
	
	Для Каждого ЭлементОтбора Из ЭлементыОтбора Цикл
		Если ЭлементОтбора.ЛевоеЗначение = ЛевоеЗначение Тогда
			Если ЭлементОтбораДанных = Неопределено Тогда
				ЭлементОтбораДанных = ЭлементОтбора;
			Иначе
				ЭлементОтбора.Использование = Ложь;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Если ЭлементОтбораДанных = Неопределено Тогда
		ЭлементОтбораДанных = ЭлементыОтбора.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементОтбораДанных.ЛевоеЗначение = ЛевоеЗначение;
	КонецЕсли;
	
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = ПравоеЗначение;
	ЭлементОтбораДанных.Использование = Истина;
	
КонецПроцедуры

// Дополняет таблицу значений-приемник данными из таблицы значений-источник
//
// Параметры:
//  ТаблицаИсточник - Таблица значений - таблица из которой будут браться строки для заполнения
//  ТаблицаПриемник - Таблица значений - таблица в которую будут добавлены строки из таблицы-источника
//  
Процедура ДополнитьТаблицу(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыИсточник ИЗ ТаблицаИсточник Цикл
		
		ЗаполнитьЗначенияСвойств(ТаблицаПриемник.Добавить(), СтрокаТаблицыИсточник);
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Блок функций для работы с почтовыми адресами
//

// Функция проверяет что введенная строка с e-mail адресами введена правильно
//
// Формат строки:
// Z = ИмяПользователя|[Имя Пользователя] [<]пользователь@почтовыйсервер[>], Строка = Z[<разделитель*>Z]..
// 
//   прим.: разделитель* - имеется в виду любой разделитель адресов
//
// Параметры:
// СтрокаАдресов - строка - правильная строка с почтовыми адресами
//
// Возвращаемое значение:
// Структура
// ключ Статус - булево - успех или неуспех преобразования
// в случае успеха содержит ключ Значение:
//           Массив структур, где
//                  Адрес- e-mail получателя
//                  Представление   - имя получателя
// в случае неуспеха содержит ключ СообщениеОбОшибке - строка
//
//  ВАЖНО: Функция возвращает массив структур, в которых одно поле (любое)
//         может быть незаполнено. Может использоваться различными
//         подсистемами для собственного сопоставления имени пользователя
//         некому e-mail адресу. Поэтому, необходимо перед непосредственной
//         отправкой проверить, что поле почтового адреса заполнено.
//
Функция РазобратьСтрокуСПочтовымиАдресами(знач СтрокаАдресов) Экспорт
	
	Результат = Новый Массив;
	
	НедопустимыеСимволы = "!#$%^&*()+-`~|\/=";
	ДопустимыеСимволыEMAIL = "abcdefghijklmnopqrstuvwxyz.-_0123456789";
	СимволыРазделители = ";,";
	
	Индекс = 1;               // номер обрабатываемого символа
	Накопитель = "";          // накопитель символов, после анализа перемещается либо в полное имя
	                          // либо в почтовый адрес
	ПолноеИмяАдресата = "";   // переменная, накапливающая имя адресата
	ПочтовыйАдрес = "";       // переменная, накапливающая e-mail адрес
	СтадияРазбора = 1; // 1 - формирование полного имени: ожидаются любые допустимые символы имени адресата
	                   // 2 - формирование почтового адреса: ожидаются любые допустимые символы email адреса
	                   // 3 - завершение формирования очередного почтового адреса - ожидаются символы разделители либо пробелы
	
	Пока Индекс <= СтрДлина(СтрокаАдресов) Цикл
		
		Символ = Сред(СтрокаАдресов, Индекс, 1);
		
		Если      Символ = " " Тогда
			Индекс = ? ((ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1) > Индекс,
			             ПропуститьПробелы(СтрокаАдресов, Индекс, " ") - 1,
			             Индекс);
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель + " ";
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
				СтадияРазбора = 3;
			КонецЕсли;
			Накопитель = "";
		ИначеЕсли Символ = "@" Тогда
			Если      СтадияРазбора = 1 Тогда
				СтадияРазбора = 2;
				Накопитель = Накопитель + Символ;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			ИначеЕсли СтадияРазбора = 3 Тогда
				ВызватьИсключение НСтр("ru = 'Неверный формат почтового адреса.'");
			КонецЕсли;
		ИначеЕсли Найти(СимволыРазделители, Символ) > 0 Тогда
			
			Если      СтадияРазбора = 1 Тогда
				ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
			ИначеЕсли СтадияРазбора = 2 Тогда
				ПочтовыйАдрес = Накопитель;
			КонецЕсли;
			
			СтадияРазбора = 1;
			
			Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
				Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
			КонецЕсли;
			
			ПочтовыйАдрес = "";
			ПолноеИмяАдресата = "";
			Накопитель = "";
		Иначе
			Если Найти(НедопустимыеСимволы, Символ) > 0 Тогда
				ВызватьИсключение НСтр("ru = 'Недопустимые символы в почтовом адресе.'");
			КонецЕсли;
			
			Накопитель = Накопитель + Символ;
		КонецЕсли;
		
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Если      СтадияРазбора = 1 Тогда
		ПолноеИмяАдресата = ПолноеИмяАдресата + Накопитель;
	ИначеЕсли СтадияРазбора = 2 Тогда
		ПочтовыйАдрес = Накопитель;
	КонецЕсли;

	Если Не (ПустаяСтрока(ПолноеИмяАдресата) И ПустаяСтрока(ПочтовыйАдрес)) Тогда
		Результат.Добавить(ПроверитьИПодготовитьПочтовыйАдрес(ПолноеИмяАдресата, ПочтовыйАдрес));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Если Не ВебКлиент Тогда
// Генерирует имя временного каталога возвращает путь к нему
//
Функция ПолучитьИмяКаталога(знач Идентификатор) Экспорт
	
	Индекс = 0;
	
	Пока Истина Цикл
		
		ПутьККаталогу = КаталогВременныхФайлов () + Идентификатор + строка(Индекс) + "\";
		КаталогНаДиске = Новый Файл(ПутьККаталогу);
		Если НЕ КаталогНаДиске.Существует() Тогда
			СоздатьКаталог(ПутьККаталогу);
			Возврат ПутьККаталогу;
		КонецЕсли;
		Индекс = Индекс + 1;
		
	КонецЦикла;
	
КонецФункции
#КонецЕсли

// Возвращает дату из строки в формате ЧЧ.ММ.ГГГГ
//
Функция ПолучитьДатуИзСтроки(Строка) Экспорт
	
	Возврат Дата(Сред(Строка, 7, 4)+Сред(Строка, 4, 2)+Лев(Строка, 2));
	
КонецФункции

// Получает представление сообщения ошибке на основании Информации об ошибке
// Может вызываться в операторных скобках Попытка ... Исключение ... КонецПопытки;
// для получения сообщения об ошибке.
//
Функция ПолучитьПредставлениеОписанияОшибки(ИнформацияОбОшибке) Экспорт
	
	Возврат ? (ИнформацияОбОшибке.Причина = Неопределено, ИнформацияОбОшибке.Описание, ИнформацияОбОшибке.Причина.Описание);
	
КонецФункции

// Составляет полное имя файла из имени каталога и имени файла.
//
// Параметры
//  ИмяКаталога  – Строка, содержащая путь к каталогу файла на диске.
//  ИмяФайла     – Строка, содержащая имя файла, без имени каталога.
//
// Возвращаемое значение:
//   Строка – полное имя файла с учетом каталога.
//
Функция ПолучитьИмяФайла(Знач ИмяКаталога, Знач ИмяФайла) Экспорт

	Если Не ПустаяСтрока(ИмяФайла) Тогда
		
		Слэш = "";
		Если (Прав(ИмяКаталога, 1) <> "\") И (Прав(ИмяКаталога, 1) <> "/") Тогда
			Слэш = ?(Найти(ИмяКаталога, "\") = 0, "/", "\");
		КонецЕсли;
		
		Возврат ИмяКаталога + Слэш + ИмяФайла;
		
	Иначе
		
		Возврат ИмяКаталога;
		
	КонецЕсли;

КонецФункции

Процедура УдалитьКаталогСФайлами(Путь) Экспорт
	
	Каталог = Новый Файл(Путь);
	
	Если Каталог.Существует() Тогда
		УдалитьФайлы(Путь);
	КонецЕсли;
	
КонецПроцедуры
